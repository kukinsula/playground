[00;38;05;242m/******/[m ([00;38;05;171mfunction[m(modules) { [00;38;05;242m// webpackBootstrap[m
[00;38;05;242m/******/[m 	[00;38;05;242m// The module cache[m
[00;38;05;242m/******/[m 	[00;38;05;171mvar[m installedModules = {};
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m 	[00;38;05;242m// The require function[m
[00;38;05;242m/******/[m 	[00;38;05;171mfunction[m [00;38;05;75m__webpack_require__[m(moduleId) {
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m 		[00;38;05;242m// Check if module is in cache[m
[00;38;05;242m/******/[m 		[00;38;05;171mif[m(installedModules[moduleId]) {
[00;38;05;242m/******/[m 			[00;38;05;171mreturn[m installedModules[moduleId].exports;
[00;38;05;242m/******/[m 		}
[00;38;05;242m/******/[m 		[00;38;05;242m// Create a new module (and put it into the cache)[m
[00;38;05;242m/******/[m 		[00;38;05;171mvar[m module = installedModules[moduleId] = {
[00;38;05;242m/******/[m 			i: moduleId,
[00;38;05;242m/******/[m 			l: [00;38;05;171mfalse[m,
[00;38;05;242m/******/[m 			exports: {}
[00;38;05;242m/******/[m 		};
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m 		[00;38;05;242m// Execute the module function[m
[00;38;05;242m/******/[m 		modules[moduleId].[00;38;05;75mcall[m(module.exports, module, module.exports, __webpack_require__);
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m 		[00;38;05;242m// Flag the module as loaded[m
[00;38;05;242m/******/[m 		module.l = [00;38;05;171mtrue[m;
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m 		[00;38;05;242m// Return the exports of the module[m
[00;38;05;242m/******/[m 		[00;38;05;171mreturn[m module.exports;
[00;38;05;242m/******/[m 	}
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m 	[00;38;05;242m// expose the modules object (__webpack_modules__)[m
[00;38;05;242m/******/[m 	__webpack_require__.m = modules;
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m 	[00;38;05;242m// expose the module cache[m
[00;38;05;242m/******/[m 	__webpack_require__.c = installedModules;
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m 	[00;38;05;242m// identity function for calling harmony imports with the correct context[m
[00;38;05;242m/******/[m 	__webpack_require__.i = [00;38;05;171mfunction[m(value) { [00;38;05;171mreturn[m value; };
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m 	[00;38;05;242m// define getter function for harmony exports[m
[00;38;05;242m/******/[m 	__webpack_require__.d = [00;38;05;171mfunction[m(exports, name, getter) {
[00;38;05;242m/******/[m 		[00;38;05;171mif[m(!__webpack_require__.[00;38;05;75mo[m(exports, name)) {
[00;38;05;242m/******/[m 			Object.[00;38;05;75mdefineProperty[m(exports, name, {
[00;38;05;242m/******/[m 				configurable: [00;38;05;171mfalse[m,
[00;38;05;242m/******/[m 				enumerable: [00;38;05;171mtrue[m,
[00;38;05;242m/******/[m 				get: getter
[00;38;05;242m/******/[m 			});
[00;38;05;242m/******/[m 		}
[00;38;05;242m/******/[m 	};
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m 	[00;38;05;242m// getDefaultExport function for compatibility with non-harmony modules[m
[00;38;05;242m/******/[m 	__webpack_require__.n = [00;38;05;171mfunction[m(module) {
[00;38;05;242m/******/[m 		[00;38;05;171mvar[m getter = module && module.__esModule ?
[00;38;05;242m/******/[m 			[00;38;05;171mfunction[m [00;38;05;75mgetDefault[m() { [00;38;05;171mreturn[m module[[00;38;05;196m'default'[m]; } :
[00;38;05;242m/******/[m 			[00;38;05;171mfunction[m [00;38;05;75mgetModuleExports[m() { [00;38;05;171mreturn[m module; };
[00;38;05;242m/******/[m 		__webpack_require__.[00;38;05;75md[m(getter, [00;38;05;196m'a'[m, getter);
[00;38;05;242m/******/[m 		[00;38;05;171mreturn[m getter;
[00;38;05;242m/******/[m 	};
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m 	[00;38;05;242m// Object.prototype.hasOwnProperty.call[m
[00;38;05;242m/******/[m 	__webpack_require__.o = [00;38;05;171mfunction[m(object, property) { [00;38;05;171mreturn[m Object.[00;38;05;171mprototype[m.hasOwnProperty.[00;38;05;75mcall[m(object, property); };
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m 	[00;38;05;242m// __webpack_public_path__[m
[00;38;05;242m/******/[m 	__webpack_require__.p = [00;38;05;196m""[m;
[00;38;05;242m/******/[m
[00;38;05;242m/******/[m 	[00;38;05;242m// Load entry module and return exports[m
[00;38;05;242m/******/[m 	[00;38;05;171mreturn[m [00;38;05;75m__webpack_require__[m(__webpack_require__.s = 21);
[00;38;05;242m/******/[m })
[00;38;05;242m/************************************************************************/[m
[00;38;05;242m/******/[m ([
[00;38;05;242m/* 0 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports) {

[00;38;05;171mvar[m g;

[00;38;05;242m// This works in non-strict mode[m
g = ([00;38;05;171mfunction[m() {
	[00;38;05;171mreturn[m [00;38;05;171mthis[m;
})();

[00;38;05;171mtry[m {
	[00;38;05;242m// This works if eval is allowed (see CSP)[m
	g = g || [00;38;05;75mFunction[m([00;38;05;196m"return this"[m)() || (1,eval)([00;38;05;196m"this"[m);
} [00;38;05;171mcatch[m(e) {
	[00;38;05;242m// This works if the window reference is available[m
	[00;38;05;171mif[m([00;38;05;171mtypeof[m window === [00;38;05;196m"object"[m)
		g = window;
}

[00;38;05;242m// g can still be undefined, but nothing to do about it...[m
[00;38;05;242m// We return undefined, instead of nothing here, so it's[m
[00;38;05;242m// easier to handle this case. if(!global) { ...}[m

module.exports = g;


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 1 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;
[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(global) {[00;38;05;242m/*![m
[00;38;05;242m * The buffer module from node.js, for the browser.[m
[00;38;05;242m *[m
[00;38;05;242m * @author   Feross Aboukhadijeh [m[00;38;05;75m<feross@feross.org>[m[00;38;05;242m [m[00;38;05;75m<http://feross.org>[m
[00;38;05;242m * @license  MIT[m
[00;38;05;242m */[m
[00;38;05;242m/* eslint-disable no-proto */[m



[00;38;05;171mvar[m base64 = [00;38;05;75m__webpack_require__[m(22)
[00;38;05;171mvar[m ieee754 = [00;38;05;75m__webpack_require__[m(25)
[00;38;05;171mvar[m isArray = [00;38;05;75m__webpack_require__[m(9)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

[00;38;05;242m/**[m
[00;38;05;242m * If `Buffer.TYPED_ARRAY_SUPPORT`:[m
[00;38;05;242m *   === true    Use Uint8Array implementation (fastest)[m
[00;38;05;242m *   === false   Use Object implementation (most compatible, even IE6)[m
[00;38;05;242m *[m
[00;38;05;242m * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,[m
[00;38;05;242m * Opera 11.6+, iOS 4.2+.[m
[00;38;05;242m *[m
[00;38;05;242m * Due to various browser bugs, sometimes the Object implementation will be used even[m
[00;38;05;242m * when the browser supports typed arrays.[m
[00;38;05;242m *[m
[00;38;05;242m * Note:[m
[00;38;05;242m *[m
[00;38;05;242m *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,[m
[00;38;05;242m *     See: [m[00;38;05;75mhttps://bugzilla.mozilla.org/show_bug.cgi[m[00;38;05;242m?id=695438.[m
[00;38;05;242m *[m
[00;38;05;242m *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.[m
[00;38;05;242m *[m
[00;38;05;242m *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of[m
[00;38;05;242m *     incorrect length in some situations.[m

[00;38;05;242m * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they[m
[00;38;05;242m * get the Object implementation, which is slower but behaves correctly.[m
[00;38;05;242m */[m
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : [00;38;05;75mtypedArraySupport[m()

[00;38;05;242m/*[m
[00;38;05;242m * Export kMaxLength after typed array support is determined.[m
[00;38;05;242m */[m
exports.kMaxLength = [00;38;05;75mkMaxLength[m()

[00;38;05;171mfunction[m [00;38;05;75mtypedArraySupport[m () {
  [00;38;05;171mtry[m {
    [00;38;05;171mvar[m arr = [00;38;05;171mnew[m [00;38;05;75mUint8Array[m(1)
    arr.__proto__ = {__proto__: Uint8Array.[00;38;05;171mprototype[m, foo: [00;38;05;171mfunction[m () { [00;38;05;171mreturn[m 42 }}
    [00;38;05;171mreturn[m arr.[00;38;05;75mfoo[m() === 42 && [00;38;05;242m// typed array instances can be augmented[m
        [00;38;05;171mtypeof[m arr.subarray === [00;38;05;196m'function'[m && [00;38;05;242m// chrome 9-10 lack `subarray`[m
        arr.[00;38;05;75msubarray[m(1, 1).byteLength === 0 [00;38;05;242m// ie10 has broken `subarray`[m
  } [00;38;05;171mcatch[m (e) {
    [00;38;05;171mreturn[m [00;38;05;171mfalse[m
  }
}

[00;38;05;171mfunction[m [00;38;05;75mkMaxLength[m () {
  [00;38;05;171mreturn[m Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

[00;38;05;171mfunction[m [00;38;05;75mcreateBuffer[m (that, length) {
  [00;38;05;171mif[m ([00;38;05;75mkMaxLength[m() < length) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'Invalid typed array length'[m)
  }
  [00;38;05;171mif[m (Buffer.TYPED_ARRAY_SUPPORT) {
    [00;38;05;242m// Return an augmented `Uint8Array` instance, for best performance[m
    that = [00;38;05;171mnew[m [00;38;05;75mUint8Array[m(length)
    that.__proto__ = Buffer.[00;38;05;171mprototype[m
  } [00;38;05;171melse[m {
    [00;38;05;242m// Fallback: Return an object instance of the Buffer class[m
    [00;38;05;171mif[m (that === [00;38;05;171mnull[m) {
      that = [00;38;05;171mnew[m [00;38;05;75mBuffer[m(length)
    }
    that.length = length
  }

  [00;38;05;171mreturn[m that
}

[00;38;05;242m/**[m
[00;38;05;242m * The Buffer constructor returns instances of `Uint8Array` that have their[m
[00;38;05;242m * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of[m
[00;38;05;242m * `Uint8Array`, so the returned instances will have all the node `Buffer` methods[m
[00;38;05;242m * and the `Uint8Array` methods. Square bracket notation works as expected -- it[m
[00;38;05;242m * returns a single octet.[m
[00;38;05;242m *[m
[00;38;05;242m * The `Uint8Array` prototype remains unmodified.[m
[00;38;05;242m */[m

[00;38;05;171mfunction[m [00;38;05;75mBuffer[m (arg, encodingOrOffset, length) {
  [00;38;05;171mif[m (!Buffer.TYPED_ARRAY_SUPPORT && !([00;38;05;171mthis[m [00;38;05;171minstanceof[m Buffer)) {
    [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mBuffer[m(arg, encodingOrOffset, length)
  }

  [00;38;05;242m// Common case.[m
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m arg === [00;38;05;196m'number'[m) {
    [00;38;05;171mif[m ([00;38;05;171mtypeof[m encodingOrOffset === [00;38;05;196m'string'[m) {
      [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m(
        [00;38;05;196m'If encoding is specified then the first argument must be a string'[m
      )
    }
    [00;38;05;171mreturn[m [00;38;05;75mallocUnsafe[m([00;38;05;171mthis[m, arg)
  }
  [00;38;05;171mreturn[m [00;38;05;75mfrom[m([00;38;05;171mthis[m, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 [00;38;05;242m// not used by this implementation[m

[00;38;05;242m// TODO: Legacy, not needed anymore. Remove in next major version.[m
Buffer._augment = [00;38;05;171mfunction[m (arr) {
  arr.__proto__ = Buffer.[00;38;05;171mprototype[m
  [00;38;05;171mreturn[m arr
}

[00;38;05;171mfunction[m [00;38;05;75mfrom[m (that, value, encodingOrOffset, length) {
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m value === [00;38;05;196m'number'[m) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'"value" argument must not be a number'[m)
  }

  [00;38;05;171mif[m ([00;38;05;171mtypeof[m ArrayBuffer !== [00;38;05;196m'undefined'[m && value [00;38;05;171minstanceof[m ArrayBuffer) {
    [00;38;05;171mreturn[m [00;38;05;75mfromArrayBuffer[m(that, value, encodingOrOffset, length)
  }

  [00;38;05;171mif[m ([00;38;05;171mtypeof[m value === [00;38;05;196m'string'[m) {
    [00;38;05;171mreturn[m [00;38;05;75mfromString[m(that, value, encodingOrOffset)
  }

  [00;38;05;171mreturn[m [00;38;05;75mfromObject[m(that, value)
}

[00;38;05;242m/**[m
[00;38;05;242m * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError[m
[00;38;05;242m * if value is a number.[m
[00;38;05;242m * Buffer.from(str[, encoding])[m
[00;38;05;242m * Buffer.from(array)[m
[00;38;05;242m * Buffer.from(buffer)[m
[00;38;05;242m * Buffer.from(arrayBuffer[, byteOffset[, length]])[m
[00;38;05;242m **/[m
Buffer.from = [00;38;05;171mfunction[m (value, encodingOrOffset, length) {
  [00;38;05;171mreturn[m [00;38;05;75mfrom[m([00;38;05;171mnull[m, value, encodingOrOffset, length)
}

[00;38;05;171mif[m (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.[00;38;05;171mprototype[m.__proto__ = Uint8Array.[00;38;05;171mprototype[m
  Buffer.__proto__ = Uint8Array
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m Symbol !== [00;38;05;196m'undefined'[m && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    [00;38;05;242m// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97[m
    Object.[00;38;05;75mdefineProperty[m(Buffer, Symbol.species, {
      value: [00;38;05;171mnull[m,
      configurable: [00;38;05;171mtrue[m
    })
  }
}

[00;38;05;171mfunction[m [00;38;05;75massertSize[m (size) {
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m size !== [00;38;05;196m'number'[m) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'"size" argument must be a number'[m)
  } [00;38;05;171melse[m [00;38;05;171mif[m (size < 0) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'"size" argument must not be negative'[m)
  }
}

[00;38;05;171mfunction[m [00;38;05;75malloc[m (that, size, fill, encoding) {
  [00;38;05;75massertSize[m(size)
  [00;38;05;171mif[m (size <= 0) {
    [00;38;05;171mreturn[m [00;38;05;75mcreateBuffer[m(that, size)
  }
  [00;38;05;171mif[m (fill !== undefined) {
    [00;38;05;242m// Only pay attention to encoding if it's a string. This[m
    [00;38;05;242m// prevents accidentally sending in a number that would[m
    [00;38;05;242m// be interpretted as a start offset.[m
    [00;38;05;171mreturn[m [00;38;05;171mtypeof[m encoding === [00;38;05;196m'string'[m
      ? [00;38;05;75mcreateBuffer[m(that, size).[00;38;05;75mfill[m(fill, encoding)
      : [00;38;05;75mcreateBuffer[m(that, size).[00;38;05;75mfill[m(fill)
  }
  [00;38;05;171mreturn[m [00;38;05;75mcreateBuffer[m(that, size)
}

[00;38;05;242m/**[m
[00;38;05;242m * Creates a new filled Buffer instance.[m
[00;38;05;242m * alloc(size[, fill[, encoding]])[m
[00;38;05;242m **/[m
Buffer.alloc = [00;38;05;171mfunction[m (size, fill, encoding) {
  [00;38;05;171mreturn[m [00;38;05;75malloc[m([00;38;05;171mnull[m, size, fill, encoding)
}

[00;38;05;171mfunction[m [00;38;05;75mallocUnsafe[m (that, size) {
  [00;38;05;75massertSize[m(size)
  that = [00;38;05;75mcreateBuffer[m(that, size < 0 ? 0 : [00;38;05;75mchecked[m(size) | 0)
  [00;38;05;171mif[m (!Buffer.TYPED_ARRAY_SUPPORT) {
    [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  [00;38;05;171mreturn[m that
}

[00;38;05;242m/**[m
[00;38;05;242m * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.[m
[00;38;05;242m * */[m
Buffer.allocUnsafe = [00;38;05;171mfunction[m (size) {
  [00;38;05;171mreturn[m [00;38;05;75mallocUnsafe[m([00;38;05;171mnull[m, size)
}
[00;38;05;242m/**[m
[00;38;05;242m * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.[m
[00;38;05;242m */[m
Buffer.allocUnsafeSlow = [00;38;05;171mfunction[m (size) {
  [00;38;05;171mreturn[m [00;38;05;75mallocUnsafe[m([00;38;05;171mnull[m, size)
}

[00;38;05;171mfunction[m [00;38;05;75mfromString[m (that, string, encoding) {
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m encoding !== [00;38;05;196m'string'[m || encoding === [00;38;05;196m''[m) {
    encoding = [00;38;05;196m'utf8'[m
  }

  [00;38;05;171mif[m (!Buffer.[00;38;05;75misEncoding[m(encoding)) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'"encoding" must be a valid string encoding'[m)
  }

  [00;38;05;171mvar[m length = [00;38;05;75mbyteLength[m(string, encoding) | 0
  that = [00;38;05;75mcreateBuffer[m(that, length)

  [00;38;05;171mvar[m actual = that.[00;38;05;75mwrite[m(string, encoding)

  [00;38;05;171mif[m (actual !== length) {
    [00;38;05;242m// Writing a hex string, for example, that contains invalid characters will[m
    [00;38;05;242m// cause everything after the first invalid character to be ignored. (e.g.[m
    [00;38;05;242m// 'abxxcd' will be treated as 'ab')[m
    that = that.[00;38;05;75mslice[m(0, actual)
  }

  [00;38;05;171mreturn[m that
}

[00;38;05;171mfunction[m [00;38;05;75mfromArrayLike[m (that, array) {
  [00;38;05;171mvar[m length = array.length < 0 ? 0 : [00;38;05;75mchecked[m(array.length) | 0
  that = [00;38;05;75mcreateBuffer[m(that, length)
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  [00;38;05;171mreturn[m that
}

[00;38;05;171mfunction[m [00;38;05;75mfromArrayBuffer[m (that, array, byteOffset, length) {
  array.byteLength [00;38;05;242m// this throws if `array` is not a valid ArrayBuffer[m

  [00;38;05;171mif[m (byteOffset < 0 || array.byteLength < byteOffset) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'[m\'[00;38;05;196moffset[m\'[00;38;05;196m is out of bounds'[m)
  }

  [00;38;05;171mif[m (array.byteLength < byteOffset + (length || 0)) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'[m\'[00;38;05;196mlength[m\'[00;38;05;196m is out of bounds'[m)
  }

  [00;38;05;171mif[m (byteOffset === undefined && length === undefined) {
    array = [00;38;05;171mnew[m [00;38;05;75mUint8Array[m(array)
  } [00;38;05;171melse[m [00;38;05;171mif[m (length === undefined) {
    array = [00;38;05;171mnew[m [00;38;05;75mUint8Array[m(array, byteOffset)
  } [00;38;05;171melse[m {
    array = [00;38;05;171mnew[m [00;38;05;75mUint8Array[m(array, byteOffset, length)
  }

  [00;38;05;171mif[m (Buffer.TYPED_ARRAY_SUPPORT) {
    [00;38;05;242m// Return an augmented `Uint8Array` instance, for best performance[m
    that = array
    that.__proto__ = Buffer.[00;38;05;171mprototype[m
  } [00;38;05;171melse[m {
    [00;38;05;242m// Fallback: Return an object instance of the Buffer class[m
    that = [00;38;05;75mfromArrayLike[m(that, array)
  }
  [00;38;05;171mreturn[m that
}

[00;38;05;171mfunction[m [00;38;05;75mfromObject[m (that, obj) {
  [00;38;05;171mif[m (Buffer.[00;38;05;75misBuffer[m(obj)) {
    [00;38;05;171mvar[m len = [00;38;05;75mchecked[m(obj.length) | 0
    that = [00;38;05;75mcreateBuffer[m(that, len)

    [00;38;05;171mif[m (that.length === 0) {
      [00;38;05;171mreturn[m that
    }

    obj.[00;38;05;75mcopy[m(that, 0, 0, len)
    [00;38;05;171mreturn[m that
  }

  [00;38;05;171mif[m (obj) {
    [00;38;05;171mif[m (([00;38;05;171mtypeof[m ArrayBuffer !== [00;38;05;196m'undefined'[m &&
        obj.buffer [00;38;05;171minstanceof[m ArrayBuffer) || [00;38;05;196m'length'[m [00;38;05;171min[m obj) {
      [00;38;05;171mif[m ([00;38;05;171mtypeof[m obj.length !== [00;38;05;196m'number'[m || [00;38;05;75misnan[m(obj.length)) {
        [00;38;05;171mreturn[m [00;38;05;75mcreateBuffer[m(that, 0)
      }
      [00;38;05;171mreturn[m [00;38;05;75mfromArrayLike[m(that, obj)
    }

    [00;38;05;171mif[m (obj.type === [00;38;05;196m'Buffer'[m && [00;38;05;75misArray[m(obj.data)) {
      [00;38;05;171mreturn[m [00;38;05;75mfromArrayLike[m(that, obj.data)
    }
  }

  [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.'[m)
}

[00;38;05;171mfunction[m [00;38;05;75mchecked[m (length) {
  [00;38;05;242m// Note: cannot use `length < kMaxLength()` here because that fails when[m
  [00;38;05;242m// length is NaN (which is otherwise coerced to zero.)[m
  [00;38;05;171mif[m (length >= [00;38;05;75mkMaxLength[m()) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'Attempt to allocate Buffer larger than maximum '[m +
                         [00;38;05;196m'size: 0x'[m + [00;38;05;75mkMaxLength[m().[00;38;05;75mtoString[m(16) + [00;38;05;196m' bytes'[m)
  }
  [00;38;05;171mreturn[m length | 0
}

[00;38;05;171mfunction[m [00;38;05;75mSlowBuffer[m (length) {
  [00;38;05;171mif[m (+length != length) { [00;38;05;242m// eslint-disable-line eqeqeq[m
    length = 0
  }
  [00;38;05;171mreturn[m Buffer.[00;38;05;75malloc[m(+length)
}

Buffer.isBuffer = [00;38;05;171mfunction[m [00;38;05;75misBuffer[m (b) {
  [00;38;05;171mreturn[m !!(b != [00;38;05;171mnull[m && b._isBuffer)
}

Buffer.compare = [00;38;05;171mfunction[m [00;38;05;75mcompare[m (a, b) {
  [00;38;05;171mif[m (!Buffer.[00;38;05;75misBuffer[m(a) || !Buffer.[00;38;05;75misBuffer[m(b)) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'Arguments must be Buffers'[m)
  }

  [00;38;05;171mif[m (a === b) [00;38;05;171mreturn[m 0

  [00;38;05;171mvar[m x = a.length
  [00;38;05;171mvar[m y = b.length

  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0, len = Math.[00;38;05;75mmin[m(x, y); i < len; ++i) {
    [00;38;05;171mif[m (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      [00;38;05;171mbreak[m
    }
  }

  [00;38;05;171mif[m (x < y) [00;38;05;171mreturn[m -1
  [00;38;05;171mif[m (y < x) [00;38;05;171mreturn[m 1
  [00;38;05;171mreturn[m 0
}

Buffer.isEncoding = [00;38;05;171mfunction[m [00;38;05;75misEncoding[m (encoding) {
  [00;38;05;171mswitch[m ([00;38;05;75mString[m(encoding).[00;38;05;75mtoLowerCase[m()) {
    [00;38;05;171mcase[m [00;38;05;196m'hex'[m:
    [00;38;05;171mcase[m [00;38;05;196m'utf8'[m:
    [00;38;05;171mcase[m [00;38;05;196m'utf-8'[m:
    [00;38;05;171mcase[m [00;38;05;196m'ascii'[m:
    [00;38;05;171mcase[m [00;38;05;196m'latin1'[m:
    [00;38;05;171mcase[m [00;38;05;196m'binary'[m:
    [00;38;05;171mcase[m [00;38;05;196m'base64'[m:
    [00;38;05;171mcase[m [00;38;05;196m'ucs2'[m:
    [00;38;05;171mcase[m [00;38;05;196m'ucs-2'[m:
    [00;38;05;171mcase[m [00;38;05;196m'utf16le'[m:
    [00;38;05;171mcase[m [00;38;05;196m'utf-16le'[m:
      [00;38;05;171mreturn[m [00;38;05;171mtrue[m
    [00;38;05;171mdefault[m:
      [00;38;05;171mreturn[m [00;38;05;171mfalse[m
  }
}

Buffer.concat = [00;38;05;171mfunction[m [00;38;05;75mconcat[m (list, length) {
  [00;38;05;171mif[m (![00;38;05;75misArray[m(list)) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'"list" argument must be an Array of Buffers'[m)
  }

  [00;38;05;171mif[m (list.length === 0) {
    [00;38;05;171mreturn[m Buffer.[00;38;05;75malloc[m(0)
  }

  [00;38;05;171mvar[m i
  [00;38;05;171mif[m (length === undefined) {
    length = 0
    [00;38;05;171mfor[m (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  [00;38;05;171mvar[m buffer = Buffer.[00;38;05;75mallocUnsafe[m(length)
  [00;38;05;171mvar[m pos = 0
  [00;38;05;171mfor[m (i = 0; i < list.length; ++i) {
    [00;38;05;171mvar[m buf = list[i]
    [00;38;05;171mif[m (!Buffer.[00;38;05;75misBuffer[m(buf)) {
      [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'"list" argument must be an Array of Buffers'[m)
    }
    buf.[00;38;05;75mcopy[m(buffer, pos)
    pos += buf.length
  }
  [00;38;05;171mreturn[m buffer
}

[00;38;05;171mfunction[m [00;38;05;75mbyteLength[m (string, encoding) {
  [00;38;05;171mif[m (Buffer.[00;38;05;75misBuffer[m(string)) {
    [00;38;05;171mreturn[m string.length
  }
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m ArrayBuffer !== [00;38;05;196m'undefined'[m && [00;38;05;171mtypeof[m ArrayBuffer.isView === [00;38;05;196m'function'[m &&
      (ArrayBuffer.[00;38;05;75misView[m(string) || string [00;38;05;171minstanceof[m ArrayBuffer)) {
    [00;38;05;171mreturn[m string.byteLength
  }
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m string !== [00;38;05;196m'string'[m) {
    string = [00;38;05;196m''[m + string
  }

  [00;38;05;171mvar[m len = string.length
  [00;38;05;171mif[m (len === 0) [00;38;05;171mreturn[m 0

  [00;38;05;242m// Use a for loop to avoid recursion[m
  [00;38;05;171mvar[m loweredCase = [00;38;05;171mfalse[m
  [00;38;05;171mfor[m (;;) {
    [00;38;05;171mswitch[m (encoding) {
      [00;38;05;171mcase[m [00;38;05;196m'ascii'[m:
      [00;38;05;171mcase[m [00;38;05;196m'latin1'[m:
      [00;38;05;171mcase[m [00;38;05;196m'binary'[m:
        [00;38;05;171mreturn[m len
      [00;38;05;171mcase[m [00;38;05;196m'utf8'[m:
      [00;38;05;171mcase[m [00;38;05;196m'utf-8'[m:
      [00;38;05;171mcase[m undefined:
        [00;38;05;171mreturn[m [00;38;05;75mutf8ToBytes[m(string).length
      [00;38;05;171mcase[m [00;38;05;196m'ucs2'[m:
      [00;38;05;171mcase[m [00;38;05;196m'ucs-2'[m:
      [00;38;05;171mcase[m [00;38;05;196m'utf16le'[m:
      [00;38;05;171mcase[m [00;38;05;196m'utf-16le'[m:
        [00;38;05;171mreturn[m len * 2
      [00;38;05;171mcase[m [00;38;05;196m'hex'[m:
        [00;38;05;171mreturn[m len >>> 1
      [00;38;05;171mcase[m [00;38;05;196m'base64'[m:
        [00;38;05;171mreturn[m [00;38;05;75mbase64ToBytes[m(string).length
      [00;38;05;171mdefault[m:
        [00;38;05;171mif[m (loweredCase) [00;38;05;171mreturn[m [00;38;05;75mutf8ToBytes[m(string).length [00;38;05;242m// assume utf8[m
        encoding = ([00;38;05;196m''[m + encoding).[00;38;05;75mtoLowerCase[m()
        loweredCase = [00;38;05;171mtrue[m
    }
  }
}
Buffer.byteLength = byteLength

[00;38;05;171mfunction[m [00;38;05;75mslowToString[m (encoding, start, end) {
  [00;38;05;171mvar[m loweredCase = [00;38;05;171mfalse[m

  [00;38;05;242m// No need to verify that "this.length <= MAX_UINT32" since it's a read-only[m
  [00;38;05;242m// property of a typed array.[m

  [00;38;05;242m// This behaves neither like String nor Uint8Array in that we set start/end[m
  [00;38;05;242m// to their upper/lower bounds if the value passed is out of range.[m
  [00;38;05;242m// undefined is handled specially as per ECMA-262 6th Edition,[m
  [00;38;05;242m// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.[m
  [00;38;05;171mif[m (start === undefined || start < 0) {
    start = 0
  }
  [00;38;05;242m// Return early if start > this.length. Done here to prevent potential uint32[m
  [00;38;05;242m// coercion fail below.[m
  [00;38;05;171mif[m (start > [00;38;05;171mthis[m.length) {
    [00;38;05;171mreturn[m [00;38;05;196m''[m
  }

  [00;38;05;171mif[m (end === undefined || end > [00;38;05;171mthis[m.length) {
    end = [00;38;05;171mthis[m.length
  }

  [00;38;05;171mif[m (end <= 0) {
    [00;38;05;171mreturn[m [00;38;05;196m''[m
  }

  [00;38;05;242m// Force coersion to uint32. This will also coerce falsey/NaN values to 0.[m
  end >>>= 0
  start >>>= 0

  [00;38;05;171mif[m (end <= start) {
    [00;38;05;171mreturn[m [00;38;05;196m''[m
  }

  [00;38;05;171mif[m (!encoding) encoding = [00;38;05;196m'utf8'[m

  [00;38;05;171mwhile[m ([00;38;05;171mtrue[m) {
    [00;38;05;171mswitch[m (encoding) {
      [00;38;05;171mcase[m [00;38;05;196m'hex'[m:
        [00;38;05;171mreturn[m [00;38;05;75mhexSlice[m([00;38;05;171mthis[m, start, end)

      [00;38;05;171mcase[m [00;38;05;196m'utf8'[m:
      [00;38;05;171mcase[m [00;38;05;196m'utf-8'[m:
        [00;38;05;171mreturn[m [00;38;05;75mutf8Slice[m([00;38;05;171mthis[m, start, end)

      [00;38;05;171mcase[m [00;38;05;196m'ascii'[m:
        [00;38;05;171mreturn[m [00;38;05;75masciiSlice[m([00;38;05;171mthis[m, start, end)

      [00;38;05;171mcase[m [00;38;05;196m'latin1'[m:
      [00;38;05;171mcase[m [00;38;05;196m'binary'[m:
        [00;38;05;171mreturn[m [00;38;05;75mlatin1Slice[m([00;38;05;171mthis[m, start, end)

      [00;38;05;171mcase[m [00;38;05;196m'base64'[m:
        [00;38;05;171mreturn[m [00;38;05;75mbase64Slice[m([00;38;05;171mthis[m, start, end)

      [00;38;05;171mcase[m [00;38;05;196m'ucs2'[m:
      [00;38;05;171mcase[m [00;38;05;196m'ucs-2'[m:
      [00;38;05;171mcase[m [00;38;05;196m'utf16le'[m:
      [00;38;05;171mcase[m [00;38;05;196m'utf-16le'[m:
        [00;38;05;171mreturn[m [00;38;05;75mutf16leSlice[m([00;38;05;171mthis[m, start, end)

      [00;38;05;171mdefault[m:
        [00;38;05;171mif[m (loweredCase) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'Unknown encoding: '[m + encoding)
        encoding = (encoding + [00;38;05;196m''[m).[00;38;05;75mtoLowerCase[m()
        loweredCase = [00;38;05;171mtrue[m
    }
  }
}

[00;38;05;242m// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect[m
[00;38;05;242m// Buffer instances.[m
Buffer.[00;38;05;171mprototype[m._isBuffer = [00;38;05;171mtrue[m

[00;38;05;171mfunction[m [00;38;05;75mswap[m (b, n, m) {
  [00;38;05;171mvar[m i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.[00;38;05;171mprototype[m.swap16 = [00;38;05;171mfunction[m [00;38;05;75mswap16[m () {
  [00;38;05;171mvar[m len = [00;38;05;171mthis[m.length
  [00;38;05;171mif[m (len % 2 !== 0) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'Buffer size must be a multiple of 16-bits'[m)
  }
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < len; i += 2) {
    [00;38;05;75mswap[m([00;38;05;171mthis[m, i, i + 1)
  }
  [00;38;05;171mreturn[m [00;38;05;171mthis[m
}

Buffer.[00;38;05;171mprototype[m.swap32 = [00;38;05;171mfunction[m [00;38;05;75mswap32[m () {
  [00;38;05;171mvar[m len = [00;38;05;171mthis[m.length
  [00;38;05;171mif[m (len % 4 !== 0) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'Buffer size must be a multiple of 32-bits'[m)
  }
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < len; i += 4) {
    [00;38;05;75mswap[m([00;38;05;171mthis[m, i, i + 3)
    [00;38;05;75mswap[m([00;38;05;171mthis[m, i + 1, i + 2)
  }
  [00;38;05;171mreturn[m [00;38;05;171mthis[m
}

Buffer.[00;38;05;171mprototype[m.swap64 = [00;38;05;171mfunction[m [00;38;05;75mswap64[m () {
  [00;38;05;171mvar[m len = [00;38;05;171mthis[m.length
  [00;38;05;171mif[m (len % 8 !== 0) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'Buffer size must be a multiple of 64-bits'[m)
  }
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < len; i += 8) {
    [00;38;05;75mswap[m([00;38;05;171mthis[m, i, i + 7)
    [00;38;05;75mswap[m([00;38;05;171mthis[m, i + 1, i + 6)
    [00;38;05;75mswap[m([00;38;05;171mthis[m, i + 2, i + 5)
    [00;38;05;75mswap[m([00;38;05;171mthis[m, i + 3, i + 4)
  }
  [00;38;05;171mreturn[m [00;38;05;171mthis[m
}

Buffer.[00;38;05;171mprototype[m.toString = [00;38;05;171mfunction[m [00;38;05;75mtoString[m () {
  [00;38;05;171mvar[m length = [00;38;05;171mthis[m.length | 0
  [00;38;05;171mif[m (length === 0) [00;38;05;171mreturn[m [00;38;05;196m''[m
  [00;38;05;171mif[m (arguments.length === 0) [00;38;05;171mreturn[m [00;38;05;75mutf8Slice[m([00;38;05;171mthis[m, 0, length)
  [00;38;05;171mreturn[m slowToString.[00;38;05;75mapply[m([00;38;05;171mthis[m, arguments)
}

Buffer.[00;38;05;171mprototype[m.equals = [00;38;05;171mfunction[m [00;38;05;75mequals[m (b) {
  [00;38;05;171mif[m (!Buffer.[00;38;05;75misBuffer[m(b)) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'Argument must be a Buffer'[m)
  [00;38;05;171mif[m ([00;38;05;171mthis[m === b) [00;38;05;171mreturn[m [00;38;05;171mtrue[m
  [00;38;05;171mreturn[m Buffer.[00;38;05;75mcompare[m([00;38;05;171mthis[m, b) === 0
}

Buffer.[00;38;05;171mprototype[m.inspect = [00;38;05;171mfunction[m [00;38;05;75minspect[m () {
  [00;38;05;171mvar[m str = [00;38;05;196m''[m
  [00;38;05;171mvar[m max = exports.INSPECT_MAX_BYTES
  [00;38;05;171mif[m ([00;38;05;171mthis[m.length > 0) {
    str = [00;38;05;171mthis[m.[00;38;05;75mtoString[m([00;38;05;196m'hex'[m, 0, max).[00;38;05;75mmatch[m([00;38;05;208m/.{2}/g[m).[00;38;05;75mjoin[m([00;38;05;196m' '[m)
    [00;38;05;171mif[m ([00;38;05;171mthis[m.length > max) str += [00;38;05;196m' ... '[m
  }
  [00;38;05;171mreturn[m [00;38;05;196m'<Buffer '[m + str + [00;38;05;196m'>'[m
}

Buffer.[00;38;05;171mprototype[m.compare = [00;38;05;171mfunction[m [00;38;05;75mcompare[m (target, start, end, thisStart, thisEnd) {
  [00;38;05;171mif[m (!Buffer.[00;38;05;75misBuffer[m(target)) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'Argument must be a Buffer'[m)
  }

  [00;38;05;171mif[m (start === undefined) {
    start = 0
  }
  [00;38;05;171mif[m (end === undefined) {
    end = target ? target.length : 0
  }
  [00;38;05;171mif[m (thisStart === undefined) {
    thisStart = 0
  }
  [00;38;05;171mif[m (thisEnd === undefined) {
    thisEnd = [00;38;05;171mthis[m.length
  }

  [00;38;05;171mif[m (start < 0 || end > target.length || thisStart < 0 || thisEnd > [00;38;05;171mthis[m.length) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'out of range index'[m)
  }

  [00;38;05;171mif[m (thisStart >= thisEnd && start >= end) {
    [00;38;05;171mreturn[m 0
  }
  [00;38;05;171mif[m (thisStart >= thisEnd) {
    [00;38;05;171mreturn[m -1
  }
  [00;38;05;171mif[m (start >= end) {
    [00;38;05;171mreturn[m 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  [00;38;05;171mif[m ([00;38;05;171mthis[m === target) [00;38;05;171mreturn[m 0

  [00;38;05;171mvar[m x = thisEnd - thisStart
  [00;38;05;171mvar[m y = end - start
  [00;38;05;171mvar[m len = Math.[00;38;05;75mmin[m(x, y)

  [00;38;05;171mvar[m thisCopy = [00;38;05;171mthis[m.[00;38;05;75mslice[m(thisStart, thisEnd)
  [00;38;05;171mvar[m targetCopy = target.[00;38;05;75mslice[m(start, end)

  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < len; ++i) {
    [00;38;05;171mif[m (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      [00;38;05;171mbreak[m
    }
  }

  [00;38;05;171mif[m (x < y) [00;38;05;171mreturn[m -1
  [00;38;05;171mif[m (y < x) [00;38;05;171mreturn[m 1
  [00;38;05;171mreturn[m 0
}

[00;38;05;242m// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,[m
[00;38;05;242m// OR the last index of `val` in `buffer` at offset <= `byteOffset`.[m
[00;38;05;242m//[m
[00;38;05;242m// Arguments:[m
[00;38;05;242m// - buffer - a Buffer to search[m
[00;38;05;242m// - val - a string, Buffer, or number[m
[00;38;05;242m// - byteOffset - an index into `buffer`; will be clamped to an int32[m
[00;38;05;242m// - encoding - an optional encoding, relevant is val is a string[m
[00;38;05;242m// - dir - true for indexOf, false for lastIndexOf[m
[00;38;05;171mfunction[m [00;38;05;75mbidirectionalIndexOf[m (buffer, val, byteOffset, encoding, dir) {
  [00;38;05;242m// Empty buffer means no match[m
  [00;38;05;171mif[m (buffer.length === 0) [00;38;05;171mreturn[m -1

  [00;38;05;242m// Normalize byteOffset[m
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m byteOffset === [00;38;05;196m'string'[m) {
    encoding = byteOffset
    byteOffset = 0
  } [00;38;05;171melse[m [00;38;05;171mif[m (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } [00;38;05;171melse[m [00;38;05;171mif[m (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  [00;38;05;242m// Coerce to Number.[m
  [00;38;05;171mif[m ([00;38;05;75misNaN[m(byteOffset)) {
    [00;38;05;242m// byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer[m
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  [00;38;05;242m// Normalize byteOffset: negative offsets start from the end of the buffer[m
  [00;38;05;171mif[m (byteOffset < 0) byteOffset = buffer.length + byteOffset
  [00;38;05;171mif[m (byteOffset >= buffer.length) {
    [00;38;05;171mif[m (dir) [00;38;05;171mreturn[m -1
    [00;38;05;171melse[m byteOffset = buffer.length - 1
  } [00;38;05;171melse[m [00;38;05;171mif[m (byteOffset < 0) {
    [00;38;05;171mif[m (dir) byteOffset = 0
    [00;38;05;171melse[m [00;38;05;171mreturn[m -1
  }

  [00;38;05;242m// Normalize val[m
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m val === [00;38;05;196m'string'[m) {
    val = Buffer.[00;38;05;75mfrom[m(val, encoding)
  }

  [00;38;05;242m// Finally, search either indexOf (if dir is true) or lastIndexOf[m
  [00;38;05;171mif[m (Buffer.[00;38;05;75misBuffer[m(val)) {
    [00;38;05;242m// Special case: looking for empty string/buffer always fails[m
    [00;38;05;171mif[m (val.length === 0) {
      [00;38;05;171mreturn[m -1
    }
    [00;38;05;171mreturn[m [00;38;05;75marrayIndexOf[m(buffer, val, byteOffset, encoding, dir)
  } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;171mtypeof[m val === [00;38;05;196m'number'[m) {
    val = val & 0xFF [00;38;05;242m// Search for a byte value [0-255][m
    [00;38;05;171mif[m (Buffer.TYPED_ARRAY_SUPPORT &&
        [00;38;05;171mtypeof[m Uint8Array.[00;38;05;171mprototype[m.indexOf === [00;38;05;196m'function'[m) {
      [00;38;05;171mif[m (dir) {
        [00;38;05;171mreturn[m Uint8Array.[00;38;05;171mprototype[m.indexOf.[00;38;05;75mcall[m(buffer, val, byteOffset)
      } [00;38;05;171melse[m {
        [00;38;05;171mreturn[m Uint8Array.[00;38;05;171mprototype[m.lastIndexOf.[00;38;05;75mcall[m(buffer, val, byteOffset)
      }
    }
    [00;38;05;171mreturn[m [00;38;05;75marrayIndexOf[m(buffer, [ val ], byteOffset, encoding, dir)
  }

  [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'val must be string, number or Buffer'[m)
}

[00;38;05;171mfunction[m [00;38;05;75marrayIndexOf[m (arr, val, byteOffset, encoding, dir) {
  [00;38;05;171mvar[m indexSize = 1
  [00;38;05;171mvar[m arrLength = arr.length
  [00;38;05;171mvar[m valLength = val.length

  [00;38;05;171mif[m (encoding !== undefined) {
    encoding = [00;38;05;75mString[m(encoding).[00;38;05;75mtoLowerCase[m()
    [00;38;05;171mif[m (encoding === [00;38;05;196m'ucs2'[m || encoding === [00;38;05;196m'ucs-2'[m ||
        encoding === [00;38;05;196m'utf16le'[m || encoding === [00;38;05;196m'utf-16le'[m) {
      [00;38;05;171mif[m (arr.length < 2 || val.length < 2) {
        [00;38;05;171mreturn[m -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  [00;38;05;171mfunction[m [00;38;05;75mread[m (buf, i) {
    [00;38;05;171mif[m (indexSize === 1) {
      [00;38;05;171mreturn[m buf[i]
    } [00;38;05;171melse[m {
      [00;38;05;171mreturn[m buf.[00;38;05;75mreadUInt16BE[m(i * indexSize)
    }
  }

  [00;38;05;171mvar[m i
  [00;38;05;171mif[m (dir) {
    [00;38;05;171mvar[m foundIndex = -1
    [00;38;05;171mfor[m (i = byteOffset; i < arrLength; i++) {
      [00;38;05;171mif[m ([00;38;05;75mread[m(arr, i) === [00;38;05;75mread[m(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        [00;38;05;171mif[m (foundIndex === -1) foundIndex = i
        [00;38;05;171mif[m (i - foundIndex + 1 === valLength) [00;38;05;171mreturn[m foundIndex * indexSize
      } [00;38;05;171melse[m {
        [00;38;05;171mif[m (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } [00;38;05;171melse[m {
    [00;38;05;171mif[m (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    [00;38;05;171mfor[m (i = byteOffset; i >= 0; i--) {
      [00;38;05;171mvar[m found = [00;38;05;171mtrue[m
      [00;38;05;171mfor[m ([00;38;05;171mvar[m j = 0; j < valLength; j++) {
        [00;38;05;171mif[m ([00;38;05;75mread[m(arr, i + j) !== [00;38;05;75mread[m(val, j)) {
          found = [00;38;05;171mfalse[m
          [00;38;05;171mbreak[m
        }
      }
      [00;38;05;171mif[m (found) [00;38;05;171mreturn[m i
    }
  }

  [00;38;05;171mreturn[m -1
}

Buffer.[00;38;05;171mprototype[m.includes = [00;38;05;171mfunction[m [00;38;05;75mincludes[m (val, byteOffset, encoding) {
  [00;38;05;171mreturn[m [00;38;05;171mthis[m.[00;38;05;75mindexOf[m(val, byteOffset, encoding) !== -1
}

Buffer.[00;38;05;171mprototype[m.indexOf = [00;38;05;171mfunction[m [00;38;05;75mindexOf[m (val, byteOffset, encoding) {
  [00;38;05;171mreturn[m [00;38;05;75mbidirectionalIndexOf[m([00;38;05;171mthis[m, val, byteOffset, encoding, [00;38;05;171mtrue[m)
}

Buffer.[00;38;05;171mprototype[m.lastIndexOf = [00;38;05;171mfunction[m [00;38;05;75mlastIndexOf[m (val, byteOffset, encoding) {
  [00;38;05;171mreturn[m [00;38;05;75mbidirectionalIndexOf[m([00;38;05;171mthis[m, val, byteOffset, encoding, [00;38;05;171mfalse[m)
}

[00;38;05;171mfunction[m [00;38;05;75mhexWrite[m (buf, string, offset, length) {
  offset = [00;38;05;75mNumber[m(offset) || 0
  [00;38;05;171mvar[m remaining = buf.length - offset
  [00;38;05;171mif[m (!length) {
    length = remaining
  } [00;38;05;171melse[m {
    length = [00;38;05;75mNumber[m(length)
    [00;38;05;171mif[m (length > remaining) {
      length = remaining
    }
  }

  [00;38;05;242m// must be an even number of digits[m
  [00;38;05;171mvar[m strLen = string.length
  [00;38;05;171mif[m (strLen % 2 !== 0) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'Invalid hex string'[m)

  [00;38;05;171mif[m (length > strLen / 2) {
    length = strLen / 2
  }
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < length; ++i) {
    [00;38;05;171mvar[m parsed = [00;38;05;75mparseInt[m(string.[00;38;05;75msubstr[m(i * 2, 2), 16)
    [00;38;05;171mif[m ([00;38;05;75misNaN[m(parsed)) [00;38;05;171mreturn[m i
    buf[offset + i] = parsed
  }
  [00;38;05;171mreturn[m i
}

[00;38;05;171mfunction[m [00;38;05;75mutf8Write[m (buf, string, offset, length) {
  [00;38;05;171mreturn[m [00;38;05;75mblitBuffer[m([00;38;05;75mutf8ToBytes[m(string, buf.length - offset), buf, offset, length)
}

[00;38;05;171mfunction[m [00;38;05;75masciiWrite[m (buf, string, offset, length) {
  [00;38;05;171mreturn[m [00;38;05;75mblitBuffer[m([00;38;05;75masciiToBytes[m(string), buf, offset, length)
}

[00;38;05;171mfunction[m [00;38;05;75mlatin1Write[m (buf, string, offset, length) {
  [00;38;05;171mreturn[m [00;38;05;75masciiWrite[m(buf, string, offset, length)
}

[00;38;05;171mfunction[m [00;38;05;75mbase64Write[m (buf, string, offset, length) {
  [00;38;05;171mreturn[m [00;38;05;75mblitBuffer[m([00;38;05;75mbase64ToBytes[m(string), buf, offset, length)
}

[00;38;05;171mfunction[m [00;38;05;75mucs2Write[m (buf, string, offset, length) {
  [00;38;05;171mreturn[m [00;38;05;75mblitBuffer[m([00;38;05;75mutf16leToBytes[m(string, buf.length - offset), buf, offset, length)
}

Buffer.[00;38;05;171mprototype[m.write = [00;38;05;171mfunction[m [00;38;05;75mwrite[m (string, offset, length, encoding) {
  [00;38;05;242m// Buffer#write(string)[m
  [00;38;05;171mif[m (offset === undefined) {
    encoding = [00;38;05;196m'utf8'[m
    length = [00;38;05;171mthis[m.length
    offset = 0
  [00;38;05;242m// Buffer#write(string, encoding)[m
  } [00;38;05;171melse[m [00;38;05;171mif[m (length === undefined && [00;38;05;171mtypeof[m offset === [00;38;05;196m'string'[m) {
    encoding = offset
    length = [00;38;05;171mthis[m.length
    offset = 0
  [00;38;05;242m// Buffer#write(string, offset[, length][, encoding])[m
  } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;75misFinite[m(offset)) {
    offset = offset | 0
    [00;38;05;171mif[m ([00;38;05;75misFinite[m(length)) {
      length = length | 0
      [00;38;05;171mif[m (encoding === undefined) encoding = [00;38;05;196m'utf8'[m
    } [00;38;05;171melse[m {
      encoding = length
      length = undefined
    }
  [00;38;05;242m// legacy write(string, encoding, offset, length) - remove in v0.13[m
  } [00;38;05;171melse[m {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m(
      [00;38;05;196m'Buffer.write(string, encoding, offset[, length]) is no longer supported'[m
    )
  }

  [00;38;05;171mvar[m remaining = [00;38;05;171mthis[m.length - offset
  [00;38;05;171mif[m (length === undefined || length > remaining) length = remaining

  [00;38;05;171mif[m ((string.length > 0 && (length < 0 || offset < 0)) || offset > [00;38;05;171mthis[m.length) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'Attempt to write outside buffer bounds'[m)
  }

  [00;38;05;171mif[m (!encoding) encoding = [00;38;05;196m'utf8'[m

  [00;38;05;171mvar[m loweredCase = [00;38;05;171mfalse[m
  [00;38;05;171mfor[m (;;) {
    [00;38;05;171mswitch[m (encoding) {
      [00;38;05;171mcase[m [00;38;05;196m'hex'[m:
        [00;38;05;171mreturn[m [00;38;05;75mhexWrite[m([00;38;05;171mthis[m, string, offset, length)

      [00;38;05;171mcase[m [00;38;05;196m'utf8'[m:
      [00;38;05;171mcase[m [00;38;05;196m'utf-8'[m:
        [00;38;05;171mreturn[m [00;38;05;75mutf8Write[m([00;38;05;171mthis[m, string, offset, length)

      [00;38;05;171mcase[m [00;38;05;196m'ascii'[m:
        [00;38;05;171mreturn[m [00;38;05;75masciiWrite[m([00;38;05;171mthis[m, string, offset, length)

      [00;38;05;171mcase[m [00;38;05;196m'latin1'[m:
      [00;38;05;171mcase[m [00;38;05;196m'binary'[m:
        [00;38;05;171mreturn[m [00;38;05;75mlatin1Write[m([00;38;05;171mthis[m, string, offset, length)

      [00;38;05;171mcase[m [00;38;05;196m'base64'[m:
        [00;38;05;242m// Warning: maxLength not taken into account in base64Write[m
        [00;38;05;171mreturn[m [00;38;05;75mbase64Write[m([00;38;05;171mthis[m, string, offset, length)

      [00;38;05;171mcase[m [00;38;05;196m'ucs2'[m:
      [00;38;05;171mcase[m [00;38;05;196m'ucs-2'[m:
      [00;38;05;171mcase[m [00;38;05;196m'utf16le'[m:
      [00;38;05;171mcase[m [00;38;05;196m'utf-16le'[m:
        [00;38;05;171mreturn[m [00;38;05;75mucs2Write[m([00;38;05;171mthis[m, string, offset, length)

      [00;38;05;171mdefault[m:
        [00;38;05;171mif[m (loweredCase) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'Unknown encoding: '[m + encoding)
        encoding = ([00;38;05;196m''[m + encoding).[00;38;05;75mtoLowerCase[m()
        loweredCase = [00;38;05;171mtrue[m
    }
  }
}

Buffer.[00;38;05;171mprototype[m.toJSON = [00;38;05;171mfunction[m [00;38;05;75mtoJSON[m () {
  [00;38;05;171mreturn[m {
    type: [00;38;05;196m'Buffer'[m,
    data: Array.[00;38;05;171mprototype[m.slice.[00;38;05;75mcall[m([00;38;05;171mthis[m._arr || [00;38;05;171mthis[m, 0)
  }
}

[00;38;05;171mfunction[m [00;38;05;75mbase64Slice[m (buf, start, end) {
  [00;38;05;171mif[m (start === 0 && end === buf.length) {
    [00;38;05;171mreturn[m base64.[00;38;05;75mfromByteArray[m(buf)
  } [00;38;05;171melse[m {
    [00;38;05;171mreturn[m base64.[00;38;05;75mfromByteArray[m(buf.[00;38;05;75mslice[m(start, end))
  }
}

[00;38;05;171mfunction[m [00;38;05;75mutf8Slice[m (buf, start, end) {
  end = Math.[00;38;05;75mmin[m(buf.length, end)
  [00;38;05;171mvar[m res = []

  [00;38;05;171mvar[m i = start
  [00;38;05;171mwhile[m (i < end) {
    [00;38;05;171mvar[m firstByte = buf[i]
    [00;38;05;171mvar[m codePoint = [00;38;05;171mnull[m
    [00;38;05;171mvar[m bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    [00;38;05;171mif[m (i + bytesPerSequence <= end) {
      [00;38;05;171mvar[m secondByte, thirdByte, fourthByte, tempCodePoint

      [00;38;05;171mswitch[m (bytesPerSequence) {
        [00;38;05;171mcase[m 1:
          [00;38;05;171mif[m (firstByte < 0x80) {
            codePoint = firstByte
          }
          [00;38;05;171mbreak[m
        [00;38;05;171mcase[m 2:
          secondByte = buf[i + 1]
          [00;38;05;171mif[m ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            [00;38;05;171mif[m (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          [00;38;05;171mbreak[m
        [00;38;05;171mcase[m 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          [00;38;05;171mif[m ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            [00;38;05;171mif[m (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          [00;38;05;171mbreak[m
        [00;38;05;171mcase[m 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          [00;38;05;171mif[m ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            [00;38;05;171mif[m (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    [00;38;05;171mif[m (codePoint === [00;38;05;171mnull[m) {
      [00;38;05;242m// we did not generate a valid codePoint so insert a[m
      [00;38;05;242m// replacement char (U+FFFD) and advance only 1 byte[m
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } [00;38;05;171melse[m [00;38;05;171mif[m (codePoint > 0xFFFF) {
      [00;38;05;242m// encode to utf16 (surrogate pair dance)[m
      codePoint -= 0x10000
      res.[00;38;05;75mpush[m(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.[00;38;05;75mpush[m(codePoint)
    i += bytesPerSequence
  }

  [00;38;05;171mreturn[m [00;38;05;75mdecodeCodePointsArray[m(res)
}

[00;38;05;242m// Based on http://stackoverflow.com/a/22747272/680742, the browser with[m
[00;38;05;242m// the lowest limit is Chrome, with 0x10000 args.[m
[00;38;05;242m// We go 1 magnitude less, for safety[m
[00;38;05;171mvar[m MAX_ARGUMENTS_LENGTH = 0x1000

[00;38;05;171mfunction[m [00;38;05;75mdecodeCodePointsArray[m (codePoints) {
  [00;38;05;171mvar[m len = codePoints.length
  [00;38;05;171mif[m (len <= MAX_ARGUMENTS_LENGTH) {
    [00;38;05;171mreturn[m String.fromCharCode.[00;38;05;75mapply[m(String, codePoints) [00;38;05;242m// avoid extra slice()[m
  }

  [00;38;05;242m// Decode in chunks to avoid "call stack size exceeded".[m
  [00;38;05;171mvar[m res = [00;38;05;196m''[m
  [00;38;05;171mvar[m i = 0
  [00;38;05;171mwhile[m (i < len) {
    res += String.fromCharCode.[00;38;05;75mapply[m(
      String,
      codePoints.[00;38;05;75mslice[m(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  [00;38;05;171mreturn[m res
}

[00;38;05;171mfunction[m [00;38;05;75masciiSlice[m (buf, start, end) {
  [00;38;05;171mvar[m ret = [00;38;05;196m''[m
  end = Math.[00;38;05;75mmin[m(buf.length, end)

  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = start; i < end; ++i) {
    ret += String.[00;38;05;75mfromCharCode[m(buf[i] & 0x7F)
  }
  [00;38;05;171mreturn[m ret
}

[00;38;05;171mfunction[m [00;38;05;75mlatin1Slice[m (buf, start, end) {
  [00;38;05;171mvar[m ret = [00;38;05;196m''[m
  end = Math.[00;38;05;75mmin[m(buf.length, end)

  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = start; i < end; ++i) {
    ret += String.[00;38;05;75mfromCharCode[m(buf[i])
  }
  [00;38;05;171mreturn[m ret
}

[00;38;05;171mfunction[m [00;38;05;75mhexSlice[m (buf, start, end) {
  [00;38;05;171mvar[m len = buf.length

  [00;38;05;171mif[m (!start || start < 0) start = 0
  [00;38;05;171mif[m (!end || end < 0 || end > len) end = len

  [00;38;05;171mvar[m out = [00;38;05;196m''[m
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = start; i < end; ++i) {
    out += [00;38;05;75mtoHex[m(buf[i])
  }
  [00;38;05;171mreturn[m out
}

[00;38;05;171mfunction[m [00;38;05;75mutf16leSlice[m (buf, start, end) {
  [00;38;05;171mvar[m bytes = buf.[00;38;05;75mslice[m(start, end)
  [00;38;05;171mvar[m res = [00;38;05;196m''[m
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < bytes.length; i += 2) {
    res += String.[00;38;05;75mfromCharCode[m(bytes[i] + bytes[i + 1] * 256)
  }
  [00;38;05;171mreturn[m res
}

Buffer.[00;38;05;171mprototype[m.slice = [00;38;05;171mfunction[m [00;38;05;75mslice[m (start, end) {
  [00;38;05;171mvar[m len = [00;38;05;171mthis[m.length
  start = ~~start
  end = end === undefined ? len : ~~end

  [00;38;05;171mif[m (start < 0) {
    start += len
    [00;38;05;171mif[m (start < 0) start = 0
  } [00;38;05;171melse[m [00;38;05;171mif[m (start > len) {
    start = len
  }

  [00;38;05;171mif[m (end < 0) {
    end += len
    [00;38;05;171mif[m (end < 0) end = 0
  } [00;38;05;171melse[m [00;38;05;171mif[m (end > len) {
    end = len
  }

  [00;38;05;171mif[m (end < start) end = start

  [00;38;05;171mvar[m newBuf
  [00;38;05;171mif[m (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = [00;38;05;171mthis[m.[00;38;05;75msubarray[m(start, end)
    newBuf.__proto__ = Buffer.[00;38;05;171mprototype[m
  } [00;38;05;171melse[m {
    [00;38;05;171mvar[m sliceLen = end - start
    newBuf = [00;38;05;171mnew[m [00;38;05;75mBuffer[m(sliceLen, undefined)
    [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < sliceLen; ++i) {
      newBuf[i] = [00;38;05;171mthis[m[i + start]
    }
  }

  [00;38;05;171mreturn[m newBuf
}

[00;38;05;242m/*[m
[00;38;05;242m * Need to make sure that buffer isn't trying to write out of bounds.[m
[00;38;05;242m */[m
[00;38;05;171mfunction[m [00;38;05;75mcheckOffset[m (offset, ext, length) {
  [00;38;05;171mif[m ((offset % 1) !== 0 || offset < 0) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'offset is not uint'[m)
  [00;38;05;171mif[m (offset + ext > length) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'Trying to access beyond buffer length'[m)
}

Buffer.[00;38;05;171mprototype[m.readUIntLE = [00;38;05;171mfunction[m [00;38;05;75mreadUIntLE[m (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, byteLength, [00;38;05;171mthis[m.length)

  [00;38;05;171mvar[m val = [00;38;05;171mthis[m[offset]
  [00;38;05;171mvar[m mul = 1
  [00;38;05;171mvar[m i = 0
  [00;38;05;171mwhile[m (++i < byteLength && (mul *= 0x100)) {
    val += [00;38;05;171mthis[m[offset + i] * mul
  }

  [00;38;05;171mreturn[m val
}

Buffer.[00;38;05;171mprototype[m.readUIntBE = [00;38;05;171mfunction[m [00;38;05;75mreadUIntBE[m (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  [00;38;05;171mif[m (!noAssert) {
    [00;38;05;75mcheckOffset[m(offset, byteLength, [00;38;05;171mthis[m.length)
  }

  [00;38;05;171mvar[m val = [00;38;05;171mthis[m[offset + --byteLength]
  [00;38;05;171mvar[m mul = 1
  [00;38;05;171mwhile[m (byteLength > 0 && (mul *= 0x100)) {
    val += [00;38;05;171mthis[m[offset + --byteLength] * mul
  }

  [00;38;05;171mreturn[m val
}

Buffer.[00;38;05;171mprototype[m.readUInt8 = [00;38;05;171mfunction[m [00;38;05;75mreadUInt8[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 1, [00;38;05;171mthis[m.length)
  [00;38;05;171mreturn[m [00;38;05;171mthis[m[offset]
}

Buffer.[00;38;05;171mprototype[m.readUInt16LE = [00;38;05;171mfunction[m [00;38;05;75mreadUInt16LE[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 2, [00;38;05;171mthis[m.length)
  [00;38;05;171mreturn[m [00;38;05;171mthis[m[offset] | ([00;38;05;171mthis[m[offset + 1] << 8)
}

Buffer.[00;38;05;171mprototype[m.readUInt16BE = [00;38;05;171mfunction[m [00;38;05;75mreadUInt16BE[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 2, [00;38;05;171mthis[m.length)
  [00;38;05;171mreturn[m ([00;38;05;171mthis[m[offset] << 8) | [00;38;05;171mthis[m[offset + 1]
}

Buffer.[00;38;05;171mprototype[m.readUInt32LE = [00;38;05;171mfunction[m [00;38;05;75mreadUInt32LE[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 4, [00;38;05;171mthis[m.length)

  [00;38;05;171mreturn[m (([00;38;05;171mthis[m[offset]) |
      ([00;38;05;171mthis[m[offset + 1] << 8) |
      ([00;38;05;171mthis[m[offset + 2] << 16)) +
      ([00;38;05;171mthis[m[offset + 3] * 0x1000000)
}

Buffer.[00;38;05;171mprototype[m.readUInt32BE = [00;38;05;171mfunction[m [00;38;05;75mreadUInt32BE[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 4, [00;38;05;171mthis[m.length)

  [00;38;05;171mreturn[m ([00;38;05;171mthis[m[offset] * 0x1000000) +
    (([00;38;05;171mthis[m[offset + 1] << 16) |
    ([00;38;05;171mthis[m[offset + 2] << 8) |
    [00;38;05;171mthis[m[offset + 3])
}

Buffer.[00;38;05;171mprototype[m.readIntLE = [00;38;05;171mfunction[m [00;38;05;75mreadIntLE[m (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, byteLength, [00;38;05;171mthis[m.length)

  [00;38;05;171mvar[m val = [00;38;05;171mthis[m[offset]
  [00;38;05;171mvar[m mul = 1
  [00;38;05;171mvar[m i = 0
  [00;38;05;171mwhile[m (++i < byteLength && (mul *= 0x100)) {
    val += [00;38;05;171mthis[m[offset + i] * mul
  }
  mul *= 0x80

  [00;38;05;171mif[m (val >= mul) val -= Math.[00;38;05;75mpow[m(2, 8 * byteLength)

  [00;38;05;171mreturn[m val
}

Buffer.[00;38;05;171mprototype[m.readIntBE = [00;38;05;171mfunction[m [00;38;05;75mreadIntBE[m (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, byteLength, [00;38;05;171mthis[m.length)

  [00;38;05;171mvar[m i = byteLength
  [00;38;05;171mvar[m mul = 1
  [00;38;05;171mvar[m val = [00;38;05;171mthis[m[offset + --i]
  [00;38;05;171mwhile[m (i > 0 && (mul *= 0x100)) {
    val += [00;38;05;171mthis[m[offset + --i] * mul
  }
  mul *= 0x80

  [00;38;05;171mif[m (val >= mul) val -= Math.[00;38;05;75mpow[m(2, 8 * byteLength)

  [00;38;05;171mreturn[m val
}

Buffer.[00;38;05;171mprototype[m.readInt8 = [00;38;05;171mfunction[m [00;38;05;75mreadInt8[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 1, [00;38;05;171mthis[m.length)
  [00;38;05;171mif[m (!([00;38;05;171mthis[m[offset] & 0x80)) [00;38;05;171mreturn[m ([00;38;05;171mthis[m[offset])
  [00;38;05;171mreturn[m ((0xff - [00;38;05;171mthis[m[offset] + 1) * -1)
}

Buffer.[00;38;05;171mprototype[m.readInt16LE = [00;38;05;171mfunction[m [00;38;05;75mreadInt16LE[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 2, [00;38;05;171mthis[m.length)
  [00;38;05;171mvar[m val = [00;38;05;171mthis[m[offset] | ([00;38;05;171mthis[m[offset + 1] << 8)
  [00;38;05;171mreturn[m (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.[00;38;05;171mprototype[m.readInt16BE = [00;38;05;171mfunction[m [00;38;05;75mreadInt16BE[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 2, [00;38;05;171mthis[m.length)
  [00;38;05;171mvar[m val = [00;38;05;171mthis[m[offset + 1] | ([00;38;05;171mthis[m[offset] << 8)
  [00;38;05;171mreturn[m (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.[00;38;05;171mprototype[m.readInt32LE = [00;38;05;171mfunction[m [00;38;05;75mreadInt32LE[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 4, [00;38;05;171mthis[m.length)

  [00;38;05;171mreturn[m ([00;38;05;171mthis[m[offset]) |
    ([00;38;05;171mthis[m[offset + 1] << 8) |
    ([00;38;05;171mthis[m[offset + 2] << 16) |
    ([00;38;05;171mthis[m[offset + 3] << 24)
}

Buffer.[00;38;05;171mprototype[m.readInt32BE = [00;38;05;171mfunction[m [00;38;05;75mreadInt32BE[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 4, [00;38;05;171mthis[m.length)

  [00;38;05;171mreturn[m ([00;38;05;171mthis[m[offset] << 24) |
    ([00;38;05;171mthis[m[offset + 1] << 16) |
    ([00;38;05;171mthis[m[offset + 2] << 8) |
    ([00;38;05;171mthis[m[offset + 3])
}

Buffer.[00;38;05;171mprototype[m.readFloatLE = [00;38;05;171mfunction[m [00;38;05;75mreadFloatLE[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 4, [00;38;05;171mthis[m.length)
  [00;38;05;171mreturn[m ieee754.[00;38;05;75mread[m([00;38;05;171mthis[m, offset, [00;38;05;171mtrue[m, 23, 4)
}

Buffer.[00;38;05;171mprototype[m.readFloatBE = [00;38;05;171mfunction[m [00;38;05;75mreadFloatBE[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 4, [00;38;05;171mthis[m.length)
  [00;38;05;171mreturn[m ieee754.[00;38;05;75mread[m([00;38;05;171mthis[m, offset, [00;38;05;171mfalse[m, 23, 4)
}

Buffer.[00;38;05;171mprototype[m.readDoubleLE = [00;38;05;171mfunction[m [00;38;05;75mreadDoubleLE[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 8, [00;38;05;171mthis[m.length)
  [00;38;05;171mreturn[m ieee754.[00;38;05;75mread[m([00;38;05;171mthis[m, offset, [00;38;05;171mtrue[m, 52, 8)
}

Buffer.[00;38;05;171mprototype[m.readDoubleBE = [00;38;05;171mfunction[m [00;38;05;75mreadDoubleBE[m (offset, noAssert) {
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckOffset[m(offset, 8, [00;38;05;171mthis[m.length)
  [00;38;05;171mreturn[m ieee754.[00;38;05;75mread[m([00;38;05;171mthis[m, offset, [00;38;05;171mfalse[m, 52, 8)
}

[00;38;05;171mfunction[m [00;38;05;75mcheckInt[m (buf, value, offset, ext, max, min) {
  [00;38;05;171mif[m (!Buffer.[00;38;05;75misBuffer[m(buf)) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'"buffer" argument must be a Buffer instance'[m)
  [00;38;05;171mif[m (value > max || value < min) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'"value" argument is out of bounds'[m)
  [00;38;05;171mif[m (offset + ext > buf.length) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'Index out of range'[m)
}

Buffer.[00;38;05;171mprototype[m.writeUIntLE = [00;38;05;171mfunction[m [00;38;05;75mwriteUIntLE[m (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  [00;38;05;171mif[m (!noAssert) {
    [00;38;05;171mvar[m maxBytes = Math.[00;38;05;75mpow[m(2, 8 * byteLength) - 1
    [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, byteLength, maxBytes, 0)
  }

  [00;38;05;171mvar[m mul = 1
  [00;38;05;171mvar[m i = 0
  [00;38;05;171mthis[m[offset] = value & 0xFF
  [00;38;05;171mwhile[m (++i < byteLength && (mul *= 0x100)) {
    [00;38;05;171mthis[m[offset + i] = (value / mul) & 0xFF
  }

  [00;38;05;171mreturn[m offset + byteLength
}

Buffer.[00;38;05;171mprototype[m.writeUIntBE = [00;38;05;171mfunction[m [00;38;05;75mwriteUIntBE[m (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  [00;38;05;171mif[m (!noAssert) {
    [00;38;05;171mvar[m maxBytes = Math.[00;38;05;75mpow[m(2, 8 * byteLength) - 1
    [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, byteLength, maxBytes, 0)
  }

  [00;38;05;171mvar[m i = byteLength - 1
  [00;38;05;171mvar[m mul = 1
  [00;38;05;171mthis[m[offset + i] = value & 0xFF
  [00;38;05;171mwhile[m (--i >= 0 && (mul *= 0x100)) {
    [00;38;05;171mthis[m[offset + i] = (value / mul) & 0xFF
  }

  [00;38;05;171mreturn[m offset + byteLength
}

Buffer.[00;38;05;171mprototype[m.writeUInt8 = [00;38;05;171mfunction[m [00;38;05;75mwriteUInt8[m (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, 1, 0xff, 0)
  [00;38;05;171mif[m (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.[00;38;05;75mfloor[m(value)
  [00;38;05;171mthis[m[offset] = (value & 0xff)
  [00;38;05;171mreturn[m offset + 1
}

[00;38;05;171mfunction[m [00;38;05;75mobjectWriteUInt16[m (buf, value, offset, littleEndian) {
  [00;38;05;171mif[m (value < 0) value = 0xffff + value + 1
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0, j = Math.[00;38;05;75mmin[m(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.[00;38;05;171mprototype[m.writeUInt16LE = [00;38;05;171mfunction[m [00;38;05;75mwriteUInt16LE[m (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, 2, 0xffff, 0)
  [00;38;05;171mif[m (Buffer.TYPED_ARRAY_SUPPORT) {
    [00;38;05;171mthis[m[offset] = (value & 0xff)
    [00;38;05;171mthis[m[offset + 1] = (value >>> 8)
  } [00;38;05;171melse[m {
    [00;38;05;75mobjectWriteUInt16[m([00;38;05;171mthis[m, value, offset, [00;38;05;171mtrue[m)
  }
  [00;38;05;171mreturn[m offset + 2
}

Buffer.[00;38;05;171mprototype[m.writeUInt16BE = [00;38;05;171mfunction[m [00;38;05;75mwriteUInt16BE[m (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, 2, 0xffff, 0)
  [00;38;05;171mif[m (Buffer.TYPED_ARRAY_SUPPORT) {
    [00;38;05;171mthis[m[offset] = (value >>> 8)
    [00;38;05;171mthis[m[offset + 1] = (value & 0xff)
  } [00;38;05;171melse[m {
    [00;38;05;75mobjectWriteUInt16[m([00;38;05;171mthis[m, value, offset, [00;38;05;171mfalse[m)
  }
  [00;38;05;171mreturn[m offset + 2
}

[00;38;05;171mfunction[m [00;38;05;75mobjectWriteUInt32[m (buf, value, offset, littleEndian) {
  [00;38;05;171mif[m (value < 0) value = 0xffffffff + value + 1
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0, j = Math.[00;38;05;75mmin[m(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.[00;38;05;171mprototype[m.writeUInt32LE = [00;38;05;171mfunction[m [00;38;05;75mwriteUInt32LE[m (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, 4, 0xffffffff, 0)
  [00;38;05;171mif[m (Buffer.TYPED_ARRAY_SUPPORT) {
    [00;38;05;171mthis[m[offset + 3] = (value >>> 24)
    [00;38;05;171mthis[m[offset + 2] = (value >>> 16)
    [00;38;05;171mthis[m[offset + 1] = (value >>> 8)
    [00;38;05;171mthis[m[offset] = (value & 0xff)
  } [00;38;05;171melse[m {
    [00;38;05;75mobjectWriteUInt32[m([00;38;05;171mthis[m, value, offset, [00;38;05;171mtrue[m)
  }
  [00;38;05;171mreturn[m offset + 4
}

Buffer.[00;38;05;171mprototype[m.writeUInt32BE = [00;38;05;171mfunction[m [00;38;05;75mwriteUInt32BE[m (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, 4, 0xffffffff, 0)
  [00;38;05;171mif[m (Buffer.TYPED_ARRAY_SUPPORT) {
    [00;38;05;171mthis[m[offset] = (value >>> 24)
    [00;38;05;171mthis[m[offset + 1] = (value >>> 16)
    [00;38;05;171mthis[m[offset + 2] = (value >>> 8)
    [00;38;05;171mthis[m[offset + 3] = (value & 0xff)
  } [00;38;05;171melse[m {
    [00;38;05;75mobjectWriteUInt32[m([00;38;05;171mthis[m, value, offset, [00;38;05;171mfalse[m)
  }
  [00;38;05;171mreturn[m offset + 4
}

Buffer.[00;38;05;171mprototype[m.writeIntLE = [00;38;05;171mfunction[m [00;38;05;75mwriteIntLE[m (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  [00;38;05;171mif[m (!noAssert) {
    [00;38;05;171mvar[m limit = Math.[00;38;05;75mpow[m(2, 8 * byteLength - 1)

    [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, byteLength, limit - 1, -limit)
  }

  [00;38;05;171mvar[m i = 0
  [00;38;05;171mvar[m mul = 1
  [00;38;05;171mvar[m sub = 0
  [00;38;05;171mthis[m[offset] = value & 0xFF
  [00;38;05;171mwhile[m (++i < byteLength && (mul *= 0x100)) {
    [00;38;05;171mif[m (value < 0 && sub === 0 && [00;38;05;171mthis[m[offset + i - 1] !== 0) {
      sub = 1
    }
    [00;38;05;171mthis[m[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  [00;38;05;171mreturn[m offset + byteLength
}

Buffer.[00;38;05;171mprototype[m.writeIntBE = [00;38;05;171mfunction[m [00;38;05;75mwriteIntBE[m (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  [00;38;05;171mif[m (!noAssert) {
    [00;38;05;171mvar[m limit = Math.[00;38;05;75mpow[m(2, 8 * byteLength - 1)

    [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, byteLength, limit - 1, -limit)
  }

  [00;38;05;171mvar[m i = byteLength - 1
  [00;38;05;171mvar[m mul = 1
  [00;38;05;171mvar[m sub = 0
  [00;38;05;171mthis[m[offset + i] = value & 0xFF
  [00;38;05;171mwhile[m (--i >= 0 && (mul *= 0x100)) {
    [00;38;05;171mif[m (value < 0 && sub === 0 && [00;38;05;171mthis[m[offset + i + 1] !== 0) {
      sub = 1
    }
    [00;38;05;171mthis[m[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  [00;38;05;171mreturn[m offset + byteLength
}

Buffer.[00;38;05;171mprototype[m.writeInt8 = [00;38;05;171mfunction[m [00;38;05;75mwriteInt8[m (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, 1, 0x7f, -0x80)
  [00;38;05;171mif[m (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.[00;38;05;75mfloor[m(value)
  [00;38;05;171mif[m (value < 0) value = 0xff + value + 1
  [00;38;05;171mthis[m[offset] = (value & 0xff)
  [00;38;05;171mreturn[m offset + 1
}

Buffer.[00;38;05;171mprototype[m.writeInt16LE = [00;38;05;171mfunction[m [00;38;05;75mwriteInt16LE[m (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, 2, 0x7fff, -0x8000)
  [00;38;05;171mif[m (Buffer.TYPED_ARRAY_SUPPORT) {
    [00;38;05;171mthis[m[offset] = (value & 0xff)
    [00;38;05;171mthis[m[offset + 1] = (value >>> 8)
  } [00;38;05;171melse[m {
    [00;38;05;75mobjectWriteUInt16[m([00;38;05;171mthis[m, value, offset, [00;38;05;171mtrue[m)
  }
  [00;38;05;171mreturn[m offset + 2
}

Buffer.[00;38;05;171mprototype[m.writeInt16BE = [00;38;05;171mfunction[m [00;38;05;75mwriteInt16BE[m (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, 2, 0x7fff, -0x8000)
  [00;38;05;171mif[m (Buffer.TYPED_ARRAY_SUPPORT) {
    [00;38;05;171mthis[m[offset] = (value >>> 8)
    [00;38;05;171mthis[m[offset + 1] = (value & 0xff)
  } [00;38;05;171melse[m {
    [00;38;05;75mobjectWriteUInt16[m([00;38;05;171mthis[m, value, offset, [00;38;05;171mfalse[m)
  }
  [00;38;05;171mreturn[m offset + 2
}

Buffer.[00;38;05;171mprototype[m.writeInt32LE = [00;38;05;171mfunction[m [00;38;05;75mwriteInt32LE[m (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, 4, 0x7fffffff, -0x80000000)
  [00;38;05;171mif[m (Buffer.TYPED_ARRAY_SUPPORT) {
    [00;38;05;171mthis[m[offset] = (value & 0xff)
    [00;38;05;171mthis[m[offset + 1] = (value >>> 8)
    [00;38;05;171mthis[m[offset + 2] = (value >>> 16)
    [00;38;05;171mthis[m[offset + 3] = (value >>> 24)
  } [00;38;05;171melse[m {
    [00;38;05;75mobjectWriteUInt32[m([00;38;05;171mthis[m, value, offset, [00;38;05;171mtrue[m)
  }
  [00;38;05;171mreturn[m offset + 4
}

Buffer.[00;38;05;171mprototype[m.writeInt32BE = [00;38;05;171mfunction[m [00;38;05;75mwriteInt32BE[m (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  [00;38;05;171mif[m (!noAssert) [00;38;05;75mcheckInt[m([00;38;05;171mthis[m, value, offset, 4, 0x7fffffff, -0x80000000)
  [00;38;05;171mif[m (value < 0) value = 0xffffffff + value + 1
  [00;38;05;171mif[m (Buffer.TYPED_ARRAY_SUPPORT) {
    [00;38;05;171mthis[m[offset] = (value >>> 24)
    [00;38;05;171mthis[m[offset + 1] = (value >>> 16)
    [00;38;05;171mthis[m[offset + 2] = (value >>> 8)
    [00;38;05;171mthis[m[offset + 3] = (value & 0xff)
  } [00;38;05;171melse[m {
    [00;38;05;75mobjectWriteUInt32[m([00;38;05;171mthis[m, value, offset, [00;38;05;171mfalse[m)
  }
  [00;38;05;171mreturn[m offset + 4
}

[00;38;05;171mfunction[m [00;38;05;75mcheckIEEE754[m (buf, value, offset, ext, max, min) {
  [00;38;05;171mif[m (offset + ext > buf.length) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'Index out of range'[m)
  [00;38;05;171mif[m (offset < 0) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'Index out of range'[m)
}

[00;38;05;171mfunction[m [00;38;05;75mwriteFloat[m (buf, value, offset, littleEndian, noAssert) {
  [00;38;05;171mif[m (!noAssert) {
    [00;38;05;75mcheckIEEE754[m(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.[00;38;05;75mwrite[m(buf, value, offset, littleEndian, 23, 4)
  [00;38;05;171mreturn[m offset + 4
}

Buffer.[00;38;05;171mprototype[m.writeFloatLE = [00;38;05;171mfunction[m [00;38;05;75mwriteFloatLE[m (value, offset, noAssert) {
  [00;38;05;171mreturn[m [00;38;05;75mwriteFloat[m([00;38;05;171mthis[m, value, offset, [00;38;05;171mtrue[m, noAssert)
}

Buffer.[00;38;05;171mprototype[m.writeFloatBE = [00;38;05;171mfunction[m [00;38;05;75mwriteFloatBE[m (value, offset, noAssert) {
  [00;38;05;171mreturn[m [00;38;05;75mwriteFloat[m([00;38;05;171mthis[m, value, offset, [00;38;05;171mfalse[m, noAssert)
}

[00;38;05;171mfunction[m [00;38;05;75mwriteDouble[m (buf, value, offset, littleEndian, noAssert) {
  [00;38;05;171mif[m (!noAssert) {
    [00;38;05;75mcheckIEEE754[m(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.[00;38;05;75mwrite[m(buf, value, offset, littleEndian, 52, 8)
  [00;38;05;171mreturn[m offset + 8
}

Buffer.[00;38;05;171mprototype[m.writeDoubleLE = [00;38;05;171mfunction[m [00;38;05;75mwriteDoubleLE[m (value, offset, noAssert) {
  [00;38;05;171mreturn[m [00;38;05;75mwriteDouble[m([00;38;05;171mthis[m, value, offset, [00;38;05;171mtrue[m, noAssert)
}

Buffer.[00;38;05;171mprototype[m.writeDoubleBE = [00;38;05;171mfunction[m [00;38;05;75mwriteDoubleBE[m (value, offset, noAssert) {
  [00;38;05;171mreturn[m [00;38;05;75mwriteDouble[m([00;38;05;171mthis[m, value, offset, [00;38;05;171mfalse[m, noAssert)
}

[00;38;05;242m// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)[m
Buffer.[00;38;05;171mprototype[m.copy = [00;38;05;171mfunction[m [00;38;05;75mcopy[m (target, targetStart, start, end) {
  [00;38;05;171mif[m (!start) start = 0
  [00;38;05;171mif[m (!end && end !== 0) end = [00;38;05;171mthis[m.length
  [00;38;05;171mif[m (targetStart >= target.length) targetStart = target.length
  [00;38;05;171mif[m (!targetStart) targetStart = 0
  [00;38;05;171mif[m (end > 0 && end < start) end = start

  [00;38;05;242m// Copy 0 bytes; we're done[m
  [00;38;05;171mif[m (end === start) [00;38;05;171mreturn[m 0
  [00;38;05;171mif[m (target.length === 0 || [00;38;05;171mthis[m.length === 0) [00;38;05;171mreturn[m 0

  [00;38;05;242m// Fatal error conditions[m
  [00;38;05;171mif[m (targetStart < 0) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'targetStart out of bounds'[m)
  }
  [00;38;05;171mif[m (start < 0 || start >= [00;38;05;171mthis[m.length) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'sourceStart out of bounds'[m)
  [00;38;05;171mif[m (end < 0) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'sourceEnd out of bounds'[m)

  [00;38;05;242m// Are we oob?[m
  [00;38;05;171mif[m (end > [00;38;05;171mthis[m.length) end = [00;38;05;171mthis[m.length
  [00;38;05;171mif[m (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  [00;38;05;171mvar[m len = end - start
  [00;38;05;171mvar[m i

  [00;38;05;171mif[m ([00;38;05;171mthis[m === target && start < targetStart && targetStart < end) {
    [00;38;05;242m// descending copy from end[m
    [00;38;05;171mfor[m (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = [00;38;05;171mthis[m[i + start]
    }
  } [00;38;05;171melse[m [00;38;05;171mif[m (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    [00;38;05;242m// ascending copy from start[m
    [00;38;05;171mfor[m (i = 0; i < len; ++i) {
      target[i + targetStart] = [00;38;05;171mthis[m[i + start]
    }
  } [00;38;05;171melse[m {
    Uint8Array.[00;38;05;171mprototype[m.set.[00;38;05;75mcall[m(
      target,
      [00;38;05;171mthis[m.[00;38;05;75msubarray[m(start, start + len),
      targetStart
    )
  }

  [00;38;05;171mreturn[m len
}

[00;38;05;242m// Usage:[m
[00;38;05;242m//    buffer.fill(number[, offset[, end]])[m
[00;38;05;242m//    buffer.fill(buffer[, offset[, end]])[m
[00;38;05;242m//    buffer.fill(string[, offset[, end]][, encoding])[m
Buffer.[00;38;05;171mprototype[m.fill = [00;38;05;171mfunction[m [00;38;05;75mfill[m (val, start, end, encoding) {
  [00;38;05;242m// Handle string cases:[m
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m val === [00;38;05;196m'string'[m) {
    [00;38;05;171mif[m ([00;38;05;171mtypeof[m start === [00;38;05;196m'string'[m) {
      encoding = start
      start = 0
      end = [00;38;05;171mthis[m.length
    } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;171mtypeof[m end === [00;38;05;196m'string'[m) {
      encoding = end
      end = [00;38;05;171mthis[m.length
    }
    [00;38;05;171mif[m (val.length === 1) {
      [00;38;05;171mvar[m code = val.[00;38;05;75mcharCodeAt[m(0)
      [00;38;05;171mif[m (code < 256) {
        val = code
      }
    }
    [00;38;05;171mif[m (encoding !== undefined && [00;38;05;171mtypeof[m encoding !== [00;38;05;196m'string'[m) {
      [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'encoding must be a string'[m)
    }
    [00;38;05;171mif[m ([00;38;05;171mtypeof[m encoding === [00;38;05;196m'string'[m && !Buffer.[00;38;05;75misEncoding[m(encoding)) {
      [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'Unknown encoding: '[m + encoding)
    }
  } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;171mtypeof[m val === [00;38;05;196m'number'[m) {
    val = val & 255
  }

  [00;38;05;242m// Invalid ranges are not set to a default, so can range check early.[m
  [00;38;05;171mif[m (start < 0 || [00;38;05;171mthis[m.length < start || [00;38;05;171mthis[m.length < end) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'Out of range index'[m)
  }

  [00;38;05;171mif[m (end <= start) {
    [00;38;05;171mreturn[m [00;38;05;171mthis[m
  }

  start = start >>> 0
  end = end === undefined ? [00;38;05;171mthis[m.length : end >>> 0

  [00;38;05;171mif[m (!val) val = 0

  [00;38;05;171mvar[m i
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m val === [00;38;05;196m'number'[m) {
    [00;38;05;171mfor[m (i = start; i < end; ++i) {
      [00;38;05;171mthis[m[i] = val
    }
  } [00;38;05;171melse[m {
    [00;38;05;171mvar[m bytes = Buffer.[00;38;05;75misBuffer[m(val)
      ? val
      : [00;38;05;75mutf8ToBytes[m([00;38;05;171mnew[m [00;38;05;75mBuffer[m(val, encoding).[00;38;05;75mtoString[m())
    [00;38;05;171mvar[m len = bytes.length
    [00;38;05;171mfor[m (i = 0; i < end - start; ++i) {
      [00;38;05;171mthis[m[i + start] = bytes[i % len]
    }
  }

  [00;38;05;171mreturn[m [00;38;05;171mthis[m
}

[00;38;05;242m// HELPER FUNCTIONS[m
[00;38;05;242m// ================[m

[00;38;05;171mvar[m INVALID_BASE64_RE = [00;38;05;208m/[^+\/0-9A-Za-z-_]/g[m

[00;38;05;171mfunction[m [00;38;05;75mbase64clean[m (str) {
  [00;38;05;242m// Node strips out invalid characters like \n and \t from the string, base64-js does not[m
  str = [00;38;05;75mstringtrim[m(str).[00;38;05;75mreplace[m(INVALID_BASE64_RE, [00;38;05;196m''[m)
  [00;38;05;242m// Node converts strings with length < 2 to ''[m
  [00;38;05;171mif[m (str.length < 2) [00;38;05;171mreturn[m [00;38;05;196m''[m
  [00;38;05;242m// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not[m
  [00;38;05;171mwhile[m (str.length % 4 !== 0) {
    str = str + [00;38;05;196m'='[m
  }
  [00;38;05;171mreturn[m str
}

[00;38;05;171mfunction[m [00;38;05;75mstringtrim[m (str) {
  [00;38;05;171mif[m (str.trim) [00;38;05;171mreturn[m str.[00;38;05;75mtrim[m()
  [00;38;05;171mreturn[m str.[00;38;05;75mreplace[m([00;38;05;208m/^\s+|\s+$/g[m, [00;38;05;196m''[m)
}

[00;38;05;171mfunction[m [00;38;05;75mtoHex[m (n) {
  [00;38;05;171mif[m (n < 16) [00;38;05;171mreturn[m [00;38;05;196m'0'[m + n.[00;38;05;75mtoString[m(16)
  [00;38;05;171mreturn[m n.[00;38;05;75mtoString[m(16)
}

[00;38;05;171mfunction[m [00;38;05;75mutf8ToBytes[m (string, units) {
  units = units || Infinity
  [00;38;05;171mvar[m codePoint
  [00;38;05;171mvar[m length = string.length
  [00;38;05;171mvar[m leadSurrogate = [00;38;05;171mnull[m
  [00;38;05;171mvar[m bytes = []

  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < length; ++i) {
    codePoint = string.[00;38;05;75mcharCodeAt[m(i)

    [00;38;05;242m// is surrogate component[m
    [00;38;05;171mif[m (codePoint > 0xD7FF && codePoint < 0xE000) {
      [00;38;05;242m// last char was a lead[m
      [00;38;05;171mif[m (!leadSurrogate) {
        [00;38;05;242m// no lead yet[m
        [00;38;05;171mif[m (codePoint > 0xDBFF) {
          [00;38;05;242m// unexpected trail[m
          [00;38;05;171mif[m ((units -= 3) > -1) bytes.[00;38;05;75mpush[m(0xEF, 0xBF, 0xBD)
          [00;38;05;171mcontinue[m
        } [00;38;05;171melse[m [00;38;05;171mif[m (i + 1 === length) {
          [00;38;05;242m// unpaired lead[m
          [00;38;05;171mif[m ((units -= 3) > -1) bytes.[00;38;05;75mpush[m(0xEF, 0xBF, 0xBD)
          [00;38;05;171mcontinue[m
        }

        [00;38;05;242m// valid lead[m
        leadSurrogate = codePoint

        [00;38;05;171mcontinue[m
      }

      [00;38;05;242m// 2 leads in a row[m
      [00;38;05;171mif[m (codePoint < 0xDC00) {
        [00;38;05;171mif[m ((units -= 3) > -1) bytes.[00;38;05;75mpush[m(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        [00;38;05;171mcontinue[m
      }

      [00;38;05;242m// valid surrogate pair[m
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } [00;38;05;171melse[m [00;38;05;171mif[m (leadSurrogate) {
      [00;38;05;242m// valid bmp char, but last char was a lead[m
      [00;38;05;171mif[m ((units -= 3) > -1) bytes.[00;38;05;75mpush[m(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = [00;38;05;171mnull[m

    [00;38;05;242m// encode utf8[m
    [00;38;05;171mif[m (codePoint < 0x80) {
      [00;38;05;171mif[m ((units -= 1) < 0) [00;38;05;171mbreak[m
      bytes.[00;38;05;75mpush[m(codePoint)
    } [00;38;05;171melse[m [00;38;05;171mif[m (codePoint < 0x800) {
      [00;38;05;171mif[m ((units -= 2) < 0) [00;38;05;171mbreak[m
      bytes.[00;38;05;75mpush[m(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } [00;38;05;171melse[m [00;38;05;171mif[m (codePoint < 0x10000) {
      [00;38;05;171mif[m ((units -= 3) < 0) [00;38;05;171mbreak[m
      bytes.[00;38;05;75mpush[m(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } [00;38;05;171melse[m [00;38;05;171mif[m (codePoint < 0x110000) {
      [00;38;05;171mif[m ((units -= 4) < 0) [00;38;05;171mbreak[m
      bytes.[00;38;05;75mpush[m(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } [00;38;05;171melse[m {
      [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'Invalid code point'[m)
    }
  }

  [00;38;05;171mreturn[m bytes
}

[00;38;05;171mfunction[m [00;38;05;75masciiToBytes[m (str) {
  [00;38;05;171mvar[m byteArray = []
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < str.length; ++i) {
    [00;38;05;242m// Node's code seems to be doing this and not & 0x7F..[m
    byteArray.[00;38;05;75mpush[m(str.[00;38;05;75mcharCodeAt[m(i) & 0xFF)
  }
  [00;38;05;171mreturn[m byteArray
}

[00;38;05;171mfunction[m [00;38;05;75mutf16leToBytes[m (str, units) {
  [00;38;05;171mvar[m c, hi, lo
  [00;38;05;171mvar[m byteArray = []
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < str.length; ++i) {
    [00;38;05;171mif[m ((units -= 2) < 0) [00;38;05;171mbreak[m

    c = str.[00;38;05;75mcharCodeAt[m(i)
    hi = c >> 8
    lo = c % 256
    byteArray.[00;38;05;75mpush[m(lo)
    byteArray.[00;38;05;75mpush[m(hi)
  }

  [00;38;05;171mreturn[m byteArray
}

[00;38;05;171mfunction[m [00;38;05;75mbase64ToBytes[m (str) {
  [00;38;05;171mreturn[m base64.[00;38;05;75mtoByteArray[m([00;38;05;75mbase64clean[m(str))
}

[00;38;05;171mfunction[m [00;38;05;75mblitBuffer[m (src, dst, offset, length) {
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < length; ++i) {
    [00;38;05;171mif[m ((i + offset >= dst.length) || (i >= src.length)) [00;38;05;171mbreak[m
    dst[i + offset] = src[i]
  }
  [00;38;05;171mreturn[m i
}

[00;38;05;171mfunction[m [00;38;05;75misnan[m (val) {
  [00;38;05;171mreturn[m val !== val [00;38;05;242m// eslint-disable-line no-self-compare[m
}

[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(0)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 2 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports) {

[00;38;05;242m// shim for using process in browser[m
[00;38;05;171mvar[m process = module.exports = {};

[00;38;05;242m// cached from whatever global is present so that test runners that stub it[m
[00;38;05;242m// don't break things.  But we need to wrap it in a try catch in case it is[m
[00;38;05;242m// wrapped in strict mode code which doesn't define any globals.  It's inside a[m
[00;38;05;242m// function because try/catches deoptimize in certain engines.[m

[00;38;05;171mvar[m cachedSetTimeout;
[00;38;05;171mvar[m cachedClearTimeout;

[00;38;05;171mfunction[m [00;38;05;75mdefaultSetTimout[m() {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'setTimeout has not been defined'[m);
}
[00;38;05;171mfunction[m [00;38;05;75mdefaultClearTimeout[m () {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'clearTimeout has not been defined'[m);
}
([00;38;05;171mfunction[m () {
    [00;38;05;171mtry[m {
        [00;38;05;171mif[m ([00;38;05;171mtypeof[m setTimeout === [00;38;05;196m'function'[m) {
            cachedSetTimeout = setTimeout;
        } [00;38;05;171melse[m {
            cachedSetTimeout = defaultSetTimout;
        }
    } [00;38;05;171mcatch[m (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    [00;38;05;171mtry[m {
        [00;38;05;171mif[m ([00;38;05;171mtypeof[m clearTimeout === [00;38;05;196m'function'[m) {
            cachedClearTimeout = clearTimeout;
        } [00;38;05;171melse[m {
            cachedClearTimeout = defaultClearTimeout;
        }
    } [00;38;05;171mcatch[m (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
[00;38;05;171mfunction[m [00;38;05;75mrunTimeout[m(fun) {
    [00;38;05;171mif[m (cachedSetTimeout === setTimeout) {
        [00;38;05;242m//normal enviroments in sane situations[m
        [00;38;05;171mreturn[m [00;38;05;75msetTimeout[m(fun, 0);
    }
    [00;38;05;242m// if setTimeout wasn't available but was latter defined[m
    [00;38;05;171mif[m ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        [00;38;05;171mreturn[m [00;38;05;75msetTimeout[m(fun, 0);
    }
    [00;38;05;171mtry[m {
        [00;38;05;242m// when when somebody has screwed with setTimeout but no I.E. maddness[m
        [00;38;05;171mreturn[m [00;38;05;75mcachedSetTimeout[m(fun, 0);
    } [00;38;05;171mcatch[m(e){
        [00;38;05;171mtry[m {
            [00;38;05;242m// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally[m
            [00;38;05;171mreturn[m cachedSetTimeout.[00;38;05;75mcall[m([00;38;05;171mnull[m, fun, 0);
        } [00;38;05;171mcatch[m(e){
            [00;38;05;242m// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error[m
            [00;38;05;171mreturn[m cachedSetTimeout.[00;38;05;75mcall[m([00;38;05;171mthis[m, fun, 0);
        }
    }


}
[00;38;05;171mfunction[m [00;38;05;75mrunClearTimeout[m(marker) {
    [00;38;05;171mif[m (cachedClearTimeout === clearTimeout) {
        [00;38;05;242m//normal enviroments in sane situations[m
        [00;38;05;171mreturn[m [00;38;05;75mclearTimeout[m(marker);
    }
    [00;38;05;242m// if clearTimeout wasn't available but was latter defined[m
    [00;38;05;171mif[m ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        [00;38;05;171mreturn[m [00;38;05;75mclearTimeout[m(marker);
    }
    [00;38;05;171mtry[m {
        [00;38;05;242m// when when somebody has screwed with setTimeout but no I.E. maddness[m
        [00;38;05;171mreturn[m [00;38;05;75mcachedClearTimeout[m(marker);
    } [00;38;05;171mcatch[m (e){
        [00;38;05;171mtry[m {
            [00;38;05;242m// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally[m
            [00;38;05;171mreturn[m cachedClearTimeout.[00;38;05;75mcall[m([00;38;05;171mnull[m, marker);
        } [00;38;05;171mcatch[m (e){
            [00;38;05;242m// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.[m
            [00;38;05;242m// Some versions of I.E. have different rules for clearTimeout vs setTimeout[m
            [00;38;05;171mreturn[m cachedClearTimeout.[00;38;05;75mcall[m([00;38;05;171mthis[m, marker);
        }
    }



}
[00;38;05;171mvar[m queue = [];
[00;38;05;171mvar[m draining = [00;38;05;171mfalse[m;
[00;38;05;171mvar[m currentQueue;
[00;38;05;171mvar[m queueIndex = -1;

[00;38;05;171mfunction[m [00;38;05;75mcleanUpNextTick[m() {
    [00;38;05;171mif[m (!draining || !currentQueue) {
        [00;38;05;171mreturn[m;
    }
    draining = [00;38;05;171mfalse[m;
    [00;38;05;171mif[m (currentQueue.length) {
        queue = currentQueue.[00;38;05;75mconcat[m(queue);
    } [00;38;05;171melse[m {
        queueIndex = -1;
    }
    [00;38;05;171mif[m (queue.length) {
        [00;38;05;75mdrainQueue[m();
    }
}

[00;38;05;171mfunction[m [00;38;05;75mdrainQueue[m() {
    [00;38;05;171mif[m (draining) {
        [00;38;05;171mreturn[m;
    }
    [00;38;05;171mvar[m timeout = [00;38;05;75mrunTimeout[m(cleanUpNextTick);
    draining = [00;38;05;171mtrue[m;

    [00;38;05;171mvar[m len = queue.length;
    [00;38;05;171mwhile[m(len) {
        currentQueue = queue;
        queue = [];
        [00;38;05;171mwhile[m (++queueIndex < len) {
            [00;38;05;171mif[m (currentQueue) {
                currentQueue[queueIndex].[00;38;05;75mrun[m();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = [00;38;05;171mnull[m;
    draining = [00;38;05;171mfalse[m;
    [00;38;05;75mrunClearTimeout[m(timeout);
}

process.nextTick = [00;38;05;171mfunction[m (fun) {
    [00;38;05;171mvar[m args = [00;38;05;171mnew[m [00;38;05;75mArray[m(arguments.length - 1);
    [00;38;05;171mif[m (arguments.length > 1) {
        [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.[00;38;05;75mpush[m([00;38;05;171mnew[m [00;38;05;75mItem[m(fun, args));
    [00;38;05;171mif[m (queue.length === 1 && !draining) {
        [00;38;05;75mrunTimeout[m(drainQueue);
    }
};

[00;38;05;242m// v8 likes predictible objects[m
[00;38;05;171mfunction[m [00;38;05;75mItem[m(fun, array) {
    [00;38;05;171mthis[m.fun = fun;
    [00;38;05;171mthis[m.array = array;
}
Item.[00;38;05;171mprototype[m.run = [00;38;05;171mfunction[m () {
    [00;38;05;171mthis[m.fun.[00;38;05;75mapply[m([00;38;05;171mnull[m, [00;38;05;171mthis[m.array);
};
process.title = [00;38;05;196m'browser'[m;
process.browser = [00;38;05;171mtrue[m;
process.env = {};
process.argv = [];
process.version = [00;38;05;196m''[m; [00;38;05;242m// empty string to avoid regexp issues[m
process.versions = {};

[00;38;05;171mfunction[m [00;38;05;75mnoop[m() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = [00;38;05;171mfunction[m (name) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'process.binding is not supported'[m);
};

process.cwd = [00;38;05;171mfunction[m () { [00;38;05;171mreturn[m [00;38;05;196m'/'[m };
process.chdir = [00;38;05;171mfunction[m (dir) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'process.chdir is not supported'[m);
};
process.umask = [00;38;05;171mfunction[m() { [00;38;05;171mreturn[m 0; };


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 3 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports) {

[00;38;05;171mif[m ([00;38;05;171mtypeof[m Object.create === [00;38;05;196m'function'[m) {
  [00;38;05;242m// implementation from standard node.js 'util' module[m
  module.exports = [00;38;05;171mfunction[m [00;38;05;75minherits[m(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.[00;38;05;171mprototype[m = Object.[00;38;05;75mcreate[m(superCtor.[00;38;05;171mprototype[m, {
      constructor: {
        value: ctor,
        enumerable: [00;38;05;171mfalse[m,
        writable: [00;38;05;171mtrue[m,
        configurable: [00;38;05;171mtrue[m
      }
    });
  };
} [00;38;05;171melse[m {
  [00;38;05;242m// old school shim for old browsers[m
  module.exports = [00;38;05;171mfunction[m [00;38;05;75minherits[m(ctor, superCtor) {
    ctor.super_ = superCtor
    [00;38;05;171mvar[m TempCtor = [00;38;05;171mfunction[m () {}
    TempCtor.[00;38;05;171mprototype[m = superCtor.[00;38;05;171mprototype[m
    ctor.[00;38;05;171mprototype[m = [00;38;05;171mnew[m [00;38;05;75mTempCtor[m()
    ctor.[00;38;05;171mprototype[m.constructor = ctor
  }
}


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 4 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;
[00;38;05;242m// a duplex stream is just a stream that is both readable and writable.[m
[00;38;05;242m// Since JS doesn't have multiple prototypal inheritance, this class[m
[00;38;05;242m// prototypally inherits from Readable, and then parasitically from[m
[00;38;05;242m// Writable.[m



[00;38;05;242m/*<replacement>*/[m

[00;38;05;171mvar[m objectKeys = Object.keys || [00;38;05;171mfunction[m (obj) {
  [00;38;05;171mvar[m keys = [];
  [00;38;05;171mfor[m ([00;38;05;171mvar[m key [00;38;05;171min[m obj) {
    keys.[00;38;05;75mpush[m(key);
  }[00;38;05;171mreturn[m keys;
};
[00;38;05;242m/*</replacement>*/[m

module.exports = Duplex;

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m processNextTick = [00;38;05;75m__webpack_require__[m(8);
[00;38;05;242m/*</replacement>*/[m

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m util = [00;38;05;75m__webpack_require__[m(5);
util.inherits = [00;38;05;75m__webpack_require__[m(3);
[00;38;05;242m/*</replacement>*/[m

[00;38;05;171mvar[m Readable = [00;38;05;75m__webpack_require__[m(10);
[00;38;05;171mvar[m Writable = [00;38;05;75m__webpack_require__[m(12);

util.[00;38;05;75minherits[m(Duplex, Readable);

[00;38;05;171mvar[m keys = [00;38;05;75mobjectKeys[m(Writable.[00;38;05;171mprototype[m);
[00;38;05;171mfor[m ([00;38;05;171mvar[m v = 0; v < keys.length; v++) {
  [00;38;05;171mvar[m method = keys[v];
  [00;38;05;171mif[m (!Duplex.[00;38;05;171mprototype[m[method]) Duplex.[00;38;05;171mprototype[m[method] = Writable.[00;38;05;171mprototype[m[method];
}

[00;38;05;171mfunction[m [00;38;05;75mDuplex[m(options) {
  [00;38;05;171mif[m (!([00;38;05;171mthis[m [00;38;05;171minstanceof[m Duplex)) [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mDuplex[m(options);

  Readable.[00;38;05;75mcall[m([00;38;05;171mthis[m, options);
  Writable.[00;38;05;75mcall[m([00;38;05;171mthis[m, options);

  [00;38;05;171mif[m (options && options.readable === [00;38;05;171mfalse[m) [00;38;05;171mthis[m.readable = [00;38;05;171mfalse[m;

  [00;38;05;171mif[m (options && options.writable === [00;38;05;171mfalse[m) [00;38;05;171mthis[m.writable = [00;38;05;171mfalse[m;

  [00;38;05;171mthis[m.allowHalfOpen = [00;38;05;171mtrue[m;
  [00;38;05;171mif[m (options && options.allowHalfOpen === [00;38;05;171mfalse[m) [00;38;05;171mthis[m.allowHalfOpen = [00;38;05;171mfalse[m;

  [00;38;05;171mthis[m.[00;38;05;75monce[m([00;38;05;196m'end'[m, onend);
}

[00;38;05;242m// the no-half-open enforcer[m
[00;38;05;171mfunction[m [00;38;05;75monend[m() {
  [00;38;05;242m// if we allow half-open state, or if the writable side ended,[m
  [00;38;05;242m// then we're ok.[m
  [00;38;05;171mif[m ([00;38;05;171mthis[m.allowHalfOpen || [00;38;05;171mthis[m._writableState.ended) [00;38;05;171mreturn[m;

  [00;38;05;242m// no more data can be written.[m
  [00;38;05;242m// But allow more writes to happen in this tick.[m
  [00;38;05;75mprocessNextTick[m(onEndNT, [00;38;05;171mthis[m);
}

[00;38;05;171mfunction[m [00;38;05;75monEndNT[m(self) {
  self.[00;38;05;75mend[m();
}

[00;38;05;171mfunction[m [00;38;05;75mforEach[m(xs, f) {
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0, l = xs.length; i < l; i++) {
    [00;38;05;75mf[m(xs[i], i);
  }
}

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 5 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(Buffer) {[00;38;05;242m// Copyright Joyent, Inc. and other Node contributors.[m
[00;38;05;242m//[m
[00;38;05;242m// Permission is hereby granted, free of charge, to any person obtaining a[m
[00;38;05;242m// copy of this software and associated documentation files (the[m
[00;38;05;242m// "Software"), to deal in the Software without restriction, including[m
[00;38;05;242m// without limitation the rights to use, copy, modify, merge, publish,[m
[00;38;05;242m// distribute, sublicense, and/or sell copies of the Software, and to permit[m
[00;38;05;242m// persons to whom the Software is furnished to do so, subject to the[m
[00;38;05;242m// following conditions:[m
[00;38;05;242m//[m
[00;38;05;242m// The above copyright notice and this permission notice shall be included[m
[00;38;05;242m// in all copies or substantial portions of the Software.[m
[00;38;05;242m//[m
[00;38;05;242m// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS[m
[00;38;05;242m// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF[m
[00;38;05;242m// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN[m
[00;38;05;242m// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,[m
[00;38;05;242m// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR[m
[00;38;05;242m// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE[m
[00;38;05;242m// USE OR OTHER DEALINGS IN THE SOFTWARE.[m

[00;38;05;242m// NOTE: These type checking functions intentionally don't use `instanceof`[m
[00;38;05;242m// because it is fragile and can be easily faked with `Object.create()`.[m

[00;38;05;171mfunction[m [00;38;05;75misArray[m(arg) {
  [00;38;05;171mif[m (Array.isArray) {
    [00;38;05;171mreturn[m Array.[00;38;05;75misArray[m(arg);
  }
  [00;38;05;171mreturn[m [00;38;05;75mobjectToString[m(arg) === [00;38;05;196m'[object Array]'[m;
}
exports.isArray = isArray;

[00;38;05;171mfunction[m [00;38;05;75misBoolean[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'boolean'[m;
}
exports.isBoolean = isBoolean;

[00;38;05;171mfunction[m [00;38;05;75misNull[m(arg) {
  [00;38;05;171mreturn[m arg === [00;38;05;171mnull[m;
}
exports.isNull = isNull;

[00;38;05;171mfunction[m [00;38;05;75misNullOrUndefined[m(arg) {
  [00;38;05;171mreturn[m arg == [00;38;05;171mnull[m;
}
exports.isNullOrUndefined = isNullOrUndefined;

[00;38;05;171mfunction[m [00;38;05;75misNumber[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'number'[m;
}
exports.isNumber = isNumber;

[00;38;05;171mfunction[m [00;38;05;75misString[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'string'[m;
}
exports.isString = isString;

[00;38;05;171mfunction[m [00;38;05;75misSymbol[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'symbol'[m;
}
exports.isSymbol = isSymbol;

[00;38;05;171mfunction[m [00;38;05;75misUndefined[m(arg) {
  [00;38;05;171mreturn[m arg === void 0;
}
exports.isUndefined = isUndefined;

[00;38;05;171mfunction[m [00;38;05;75misRegExp[m(re) {
  [00;38;05;171mreturn[m [00;38;05;75mobjectToString[m(re) === [00;38;05;196m'[object RegExp]'[m;
}
exports.isRegExp = isRegExp;

[00;38;05;171mfunction[m [00;38;05;75misObject[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'object'[m && arg !== [00;38;05;171mnull[m;
}
exports.isObject = isObject;

[00;38;05;171mfunction[m [00;38;05;75misDate[m(d) {
  [00;38;05;171mreturn[m [00;38;05;75mobjectToString[m(d) === [00;38;05;196m'[object Date]'[m;
}
exports.isDate = isDate;

[00;38;05;171mfunction[m [00;38;05;75misError[m(e) {
  [00;38;05;171mreturn[m ([00;38;05;75mobjectToString[m(e) === [00;38;05;196m'[object Error]'[m || e [00;38;05;171minstanceof[m Error);
}
exports.isError = isError;

[00;38;05;171mfunction[m [00;38;05;75misFunction[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'function'[m;
}
exports.isFunction = isFunction;

[00;38;05;171mfunction[m [00;38;05;75misPrimitive[m(arg) {
  [00;38;05;171mreturn[m arg === [00;38;05;171mnull[m ||
         [00;38;05;171mtypeof[m arg === [00;38;05;196m'boolean'[m ||
         [00;38;05;171mtypeof[m arg === [00;38;05;196m'number'[m ||
         [00;38;05;171mtypeof[m arg === [00;38;05;196m'string'[m ||
         [00;38;05;171mtypeof[m arg === [00;38;05;196m'symbol'[m ||  [00;38;05;242m// ES6 symbol[m
         [00;38;05;171mtypeof[m arg === [00;38;05;196m'undefined'[m;
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

[00;38;05;171mfunction[m [00;38;05;75mobjectToString[m(o) {
  [00;38;05;171mreturn[m Object.[00;38;05;171mprototype[m.toString.[00;38;05;75mcall[m(o);
}

[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(1).Buffer))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 6 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;
[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(global) {

[00;38;05;171mvar[m buffer = [00;38;05;75m__webpack_require__[m(1);
[00;38;05;171mvar[m Buffer = buffer.Buffer;
[00;38;05;171mvar[m SlowBuffer = buffer.SlowBuffer;
[00;38;05;171mvar[m MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = [00;38;05;171mfunction[m [00;38;05;75malloc[m(size, fill, encoding) {
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m Buffer.alloc === [00;38;05;196m'function'[m) {
    [00;38;05;171mreturn[m Buffer.[00;38;05;75malloc[m(size, fill, encoding);
  }
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m encoding === [00;38;05;196m'number'[m) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'encoding must not be number'[m);
  }
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m size !== [00;38;05;196m'number'[m) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'size must be a number'[m);
  }
  [00;38;05;171mif[m (size > MAX_LEN) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'size is too large'[m);
  }
  [00;38;05;171mvar[m enc = encoding;
  [00;38;05;171mvar[m _fill = fill;
  [00;38;05;171mif[m (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  [00;38;05;171mvar[m buf = [00;38;05;171mnew[m [00;38;05;75mBuffer[m(size);
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m _fill === [00;38;05;196m'string'[m) {
    [00;38;05;171mvar[m fillBuf = [00;38;05;171mnew[m [00;38;05;75mBuffer[m(_fill, enc);
    [00;38;05;171mvar[m flen = fillBuf.length;
    [00;38;05;171mvar[m i = -1;
    [00;38;05;171mwhile[m (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } [00;38;05;171melse[m {
    buf.[00;38;05;75mfill[m(_fill);
  }
  [00;38;05;171mreturn[m buf;
}
exports.allocUnsafe = [00;38;05;171mfunction[m [00;38;05;75mallocUnsafe[m(size) {
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m Buffer.allocUnsafe === [00;38;05;196m'function'[m) {
    [00;38;05;171mreturn[m Buffer.[00;38;05;75mallocUnsafe[m(size);
  }
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m size !== [00;38;05;196m'number'[m) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'size must be a number'[m);
  }
  [00;38;05;171mif[m (size > MAX_LEN) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'size is too large'[m);
  }
  [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mBuffer[m(size);
}
exports.from = [00;38;05;171mfunction[m [00;38;05;75mfrom[m(value, encodingOrOffset, length) {
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m Buffer.from === [00;38;05;196m'function'[m && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    [00;38;05;171mreturn[m Buffer.[00;38;05;75mfrom[m(value, encodingOrOffset, length);
  }
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m value === [00;38;05;196m'number'[m) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'"value" argument must not be a number'[m);
  }
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m value === [00;38;05;196m'string'[m) {
    [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mBuffer[m(value, encodingOrOffset);
  }
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m ArrayBuffer !== [00;38;05;196m'undefined'[m && value [00;38;05;171minstanceof[m ArrayBuffer) {
    [00;38;05;171mvar[m offset = encodingOrOffset;
    [00;38;05;171mif[m (arguments.length === 1) {
      [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mBuffer[m(value);
    }
    [00;38;05;171mif[m ([00;38;05;171mtypeof[m offset === [00;38;05;196m'undefined'[m) {
      offset = 0;
    }
    [00;38;05;171mvar[m len = length;
    [00;38;05;171mif[m ([00;38;05;171mtypeof[m len === [00;38;05;196m'undefined'[m) {
      len = value.byteLength - offset;
    }
    [00;38;05;171mif[m (offset >= value.byteLength) {
      [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'[m\'[00;38;05;196moffset[m\'[00;38;05;196m is out of bounds'[m);
    }
    [00;38;05;171mif[m (len > value.byteLength - offset) {
      [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'[m\'[00;38;05;196mlength[m\'[00;38;05;196m is out of bounds'[m);
    }
    [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mBuffer[m(value.[00;38;05;75mslice[m(offset, offset + len));
  }
  [00;38;05;171mif[m (Buffer.[00;38;05;75misBuffer[m(value)) {
    [00;38;05;171mvar[m out = [00;38;05;171mnew[m [00;38;05;75mBuffer[m(value.length);
    value.[00;38;05;75mcopy[m(out, 0, 0, value.length);
    [00;38;05;171mreturn[m out;
  }
  [00;38;05;171mif[m (value) {
    [00;38;05;171mif[m (Array.[00;38;05;75misArray[m(value) || ([00;38;05;171mtypeof[m ArrayBuffer !== [00;38;05;196m'undefined'[m && value.buffer [00;38;05;171minstanceof[m ArrayBuffer) || [00;38;05;196m'length'[m [00;38;05;171min[m value) {
      [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mBuffer[m(value);
    }
    [00;38;05;171mif[m (value.type === [00;38;05;196m'Buffer'[m && Array.[00;38;05;75misArray[m(value.data)) {
      [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mBuffer[m(value.data);
    }
  }

  [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'First argument must be a string, Buffer, '[m + [00;38;05;196m'ArrayBuffer, Array, or array-like object.'[m);
}
exports.allocUnsafeSlow = [00;38;05;171mfunction[m [00;38;05;75mallocUnsafeSlow[m(size) {
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m Buffer.allocUnsafeSlow === [00;38;05;196m'function'[m) {
    [00;38;05;171mreturn[m Buffer.[00;38;05;75mallocUnsafeSlow[m(size);
  }
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m size !== [00;38;05;196m'number'[m) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'size must be a number'[m);
  }
  [00;38;05;171mif[m (size >= MAX_LEN) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m([00;38;05;196m'size is too large'[m);
  }
  [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mSlowBuffer[m(size);
}

[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(0)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 7 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports) {

[00;38;05;242m// Copyright Joyent, Inc. and other Node contributors.[m
[00;38;05;242m//[m
[00;38;05;242m// Permission is hereby granted, free of charge, to any person obtaining a[m
[00;38;05;242m// copy of this software and associated documentation files (the[m
[00;38;05;242m// "Software"), to deal in the Software without restriction, including[m
[00;38;05;242m// without limitation the rights to use, copy, modify, merge, publish,[m
[00;38;05;242m// distribute, sublicense, and/or sell copies of the Software, and to permit[m
[00;38;05;242m// persons to whom the Software is furnished to do so, subject to the[m
[00;38;05;242m// following conditions:[m
[00;38;05;242m//[m
[00;38;05;242m// The above copyright notice and this permission notice shall be included[m
[00;38;05;242m// in all copies or substantial portions of the Software.[m
[00;38;05;242m//[m
[00;38;05;242m// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS[m
[00;38;05;242m// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF[m
[00;38;05;242m// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN[m
[00;38;05;242m// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,[m
[00;38;05;242m// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR[m
[00;38;05;242m// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE[m
[00;38;05;242m// USE OR OTHER DEALINGS IN THE SOFTWARE.[m

[00;38;05;171mfunction[m [00;38;05;75mEventEmitter[m() {
  [00;38;05;171mthis[m._events = [00;38;05;171mthis[m._events || {};
  [00;38;05;171mthis[m._maxListeners = [00;38;05;171mthis[m._maxListeners || undefined;
}
module.exports = EventEmitter;

[00;38;05;242m// Backwards-compat with node 0.10.x[m
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.[00;38;05;171mprototype[m._events = undefined;
EventEmitter.[00;38;05;171mprototype[m._maxListeners = undefined;

[00;38;05;242m// By default EventEmitters will print a warning if more than 10 listeners are[m
[00;38;05;242m// added to it. This is a useful default which helps finding memory leaks.[m
EventEmitter.defaultMaxListeners = 10;

[00;38;05;242m// Obviously not all Emitters should be limited to 10. This function allows[m
[00;38;05;242m// that to be increased. Set to zero for unlimited.[m
EventEmitter.[00;38;05;171mprototype[m.setMaxListeners = [00;38;05;171mfunction[m(n) {
  [00;38;05;171mif[m (![00;38;05;75misNumber[m(n) || n < 0 || [00;38;05;75misNaN[m(n))
    [00;38;05;171mthrow[m [00;38;05;75mTypeError[m([00;38;05;196m'n must be a positive number'[m);
  [00;38;05;171mthis[m._maxListeners = n;
  [00;38;05;171mreturn[m [00;38;05;171mthis[m;
};

EventEmitter.[00;38;05;171mprototype[m.emit = [00;38;05;171mfunction[m(type) {
  [00;38;05;171mvar[m er, handler, len, args, i, listeners;

  [00;38;05;171mif[m (![00;38;05;171mthis[m._events)
    [00;38;05;171mthis[m._events = {};

  [00;38;05;242m// If there is no 'error' event listener then throw.[m
  [00;38;05;171mif[m (type === [00;38;05;196m'error'[m) {
    [00;38;05;171mif[m (![00;38;05;171mthis[m._events.error ||
        ([00;38;05;75misObject[m([00;38;05;171mthis[m._events.error) && ![00;38;05;171mthis[m._events.error.length)) {
      er = arguments[1];
      [00;38;05;171mif[m (er [00;38;05;171minstanceof[m Error) {
        [00;38;05;171mthrow[m er; [00;38;05;242m// Unhandled 'error' event[m
      } [00;38;05;171melse[m {
        [00;38;05;242m// At least give some kind of context to the user[m
        [00;38;05;171mvar[m err = [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'Uncaught, unspecified "error" event. ('[m + er + [00;38;05;196m')'[m);
        err.context = er;
        [00;38;05;171mthrow[m err;
      }
    }
  }

  handler = [00;38;05;171mthis[m._events[type];

  [00;38;05;171mif[m ([00;38;05;75misUndefined[m(handler))
    [00;38;05;171mreturn[m [00;38;05;171mfalse[m;

  [00;38;05;171mif[m ([00;38;05;75misFunction[m(handler)) {
    [00;38;05;171mswitch[m (arguments.length) {
      [00;38;05;242m// fast cases[m
      [00;38;05;171mcase[m 1:
        handler.[00;38;05;75mcall[m([00;38;05;171mthis[m);
        [00;38;05;171mbreak[m;
      [00;38;05;171mcase[m 2:
        handler.[00;38;05;75mcall[m([00;38;05;171mthis[m, arguments[1]);
        [00;38;05;171mbreak[m;
      [00;38;05;171mcase[m 3:
        handler.[00;38;05;75mcall[m([00;38;05;171mthis[m, arguments[1], arguments[2]);
        [00;38;05;171mbreak[m;
      [00;38;05;242m// slower[m
      [00;38;05;171mdefault[m:
        args = Array.[00;38;05;171mprototype[m.slice.[00;38;05;75mcall[m(arguments, 1);
        handler.[00;38;05;75mapply[m([00;38;05;171mthis[m, args);
    }
  } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;75misObject[m(handler)) {
    args = Array.[00;38;05;171mprototype[m.slice.[00;38;05;75mcall[m(arguments, 1);
    listeners = handler.[00;38;05;75mslice[m();
    len = listeners.length;
    [00;38;05;171mfor[m (i = 0; i < len; i++)
      listeners[i].[00;38;05;75mapply[m([00;38;05;171mthis[m, args);
  }

  [00;38;05;171mreturn[m [00;38;05;171mtrue[m;
};

EventEmitter.[00;38;05;171mprototype[m.addListener = [00;38;05;171mfunction[m(type, listener) {
  [00;38;05;171mvar[m m;

  [00;38;05;171mif[m (![00;38;05;75misFunction[m(listener))
    [00;38;05;171mthrow[m [00;38;05;75mTypeError[m([00;38;05;196m'listener must be a function'[m);

  [00;38;05;171mif[m (![00;38;05;171mthis[m._events)
    [00;38;05;171mthis[m._events = {};

  [00;38;05;242m// To avoid recursion in the case that type === "newListener"! Before[m
  [00;38;05;242m// adding it to the listeners, first emit "newListener".[m
  [00;38;05;171mif[m ([00;38;05;171mthis[m._events.newListener)
    [00;38;05;171mthis[m.[00;38;05;75memit[m([00;38;05;196m'newListener'[m, type,
              [00;38;05;75misFunction[m(listener.listener) ?
              listener.listener : listener);

  [00;38;05;171mif[m (![00;38;05;171mthis[m._events[type])
    [00;38;05;242m// Optimize the case of one listener. Don't need the extra array object.[m
    [00;38;05;171mthis[m._events[type] = listener;
  [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;75misObject[m([00;38;05;171mthis[m._events[type]))
    [00;38;05;242m// If we've already got an array, just append.[m
    [00;38;05;171mthis[m._events[type].[00;38;05;75mpush[m(listener);
  [00;38;05;171melse[m
    [00;38;05;242m// Adding the second element, need to change to array.[m
    [00;38;05;171mthis[m._events[type] = [[00;38;05;171mthis[m._events[type], listener];

  [00;38;05;242m// Check for listener leak[m
  [00;38;05;171mif[m ([00;38;05;75misObject[m([00;38;05;171mthis[m._events[type]) && ![00;38;05;171mthis[m._events[type].warned) {
    [00;38;05;171mif[m (![00;38;05;75misUndefined[m([00;38;05;171mthis[m._maxListeners)) {
      m = [00;38;05;171mthis[m._maxListeners;
    } [00;38;05;171melse[m {
      m = EventEmitter.defaultMaxListeners;
    }

    [00;38;05;171mif[m (m && m > 0 && [00;38;05;171mthis[m._events[type].length > m) {
      [00;38;05;171mthis[m._events[type].warned = [00;38;05;171mtrue[m;
      console.[00;38;05;75merror[m([00;38;05;196m'(node) warning: possible EventEmitter memory '[m +
                    [00;38;05;196m'leak detected. %d listeners added. '[m +
                    [00;38;05;196m'Use emitter.setMaxListeners() to increase limit.'[m,
                    [00;38;05;171mthis[m._events[type].length);
      [00;38;05;171mif[m ([00;38;05;171mtypeof[m console.trace === [00;38;05;196m'function'[m) {
        [00;38;05;242m// not supported in IE 10[m
        console.[00;38;05;75mtrace[m();
      }
    }
  }

  [00;38;05;171mreturn[m [00;38;05;171mthis[m;
};

EventEmitter.[00;38;05;171mprototype[m.on = EventEmitter.[00;38;05;171mprototype[m.addListener;

EventEmitter.[00;38;05;171mprototype[m.once = [00;38;05;171mfunction[m(type, listener) {
  [00;38;05;171mif[m (![00;38;05;75misFunction[m(listener))
    [00;38;05;171mthrow[m [00;38;05;75mTypeError[m([00;38;05;196m'listener must be a function'[m);

  [00;38;05;171mvar[m fired = [00;38;05;171mfalse[m;

  [00;38;05;171mfunction[m [00;38;05;75mg[m() {
    [00;38;05;171mthis[m.[00;38;05;75mremoveListener[m(type, g);

    [00;38;05;171mif[m (!fired) {
      fired = [00;38;05;171mtrue[m;
      listener.[00;38;05;75mapply[m([00;38;05;171mthis[m, arguments);
    }
  }

  g.listener = listener;
  [00;38;05;171mthis[m.[00;38;05;75mon[m(type, g);

  [00;38;05;171mreturn[m [00;38;05;171mthis[m;
};

[00;38;05;242m// emits a 'removeListener' event iff the listener was removed[m
EventEmitter.[00;38;05;171mprototype[m.removeListener = [00;38;05;171mfunction[m(type, listener) {
  [00;38;05;171mvar[m list, position, length, i;

  [00;38;05;171mif[m (![00;38;05;75misFunction[m(listener))
    [00;38;05;171mthrow[m [00;38;05;75mTypeError[m([00;38;05;196m'listener must be a function'[m);

  [00;38;05;171mif[m (![00;38;05;171mthis[m._events || ![00;38;05;171mthis[m._events[type])
    [00;38;05;171mreturn[m [00;38;05;171mthis[m;

  list = [00;38;05;171mthis[m._events[type];
  length = list.length;
  position = -1;

  [00;38;05;171mif[m (list === listener ||
      ([00;38;05;75misFunction[m(list.listener) && list.listener === listener)) {
    [00;38;05;171mdelete[m [00;38;05;171mthis[m._events[type];
    [00;38;05;171mif[m ([00;38;05;171mthis[m._events.removeListener)
      [00;38;05;171mthis[m.[00;38;05;75memit[m([00;38;05;196m'removeListener'[m, type, listener);

  } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;75misObject[m(list)) {
    [00;38;05;171mfor[m (i = length; i-- > 0;) {
      [00;38;05;171mif[m (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        [00;38;05;171mbreak[m;
      }
    }

    [00;38;05;171mif[m (position < 0)
      [00;38;05;171mreturn[m [00;38;05;171mthis[m;

    [00;38;05;171mif[m (list.length === 1) {
      list.length = 0;
      [00;38;05;171mdelete[m [00;38;05;171mthis[m._events[type];
    } [00;38;05;171melse[m {
      list.[00;38;05;75msplice[m(position, 1);
    }

    [00;38;05;171mif[m ([00;38;05;171mthis[m._events.removeListener)
      [00;38;05;171mthis[m.[00;38;05;75memit[m([00;38;05;196m'removeListener'[m, type, listener);
  }

  [00;38;05;171mreturn[m [00;38;05;171mthis[m;
};

EventEmitter.[00;38;05;171mprototype[m.removeAllListeners = [00;38;05;171mfunction[m(type) {
  [00;38;05;171mvar[m key, listeners;

  [00;38;05;171mif[m (![00;38;05;171mthis[m._events)
    [00;38;05;171mreturn[m [00;38;05;171mthis[m;

  [00;38;05;242m// not listening for removeListener, no need to emit[m
  [00;38;05;171mif[m (![00;38;05;171mthis[m._events.removeListener) {
    [00;38;05;171mif[m (arguments.length === 0)
      [00;38;05;171mthis[m._events = {};
    [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;171mthis[m._events[type])
      [00;38;05;171mdelete[m [00;38;05;171mthis[m._events[type];
    [00;38;05;171mreturn[m [00;38;05;171mthis[m;
  }

  [00;38;05;242m// emit removeListener for all listeners on all events[m
  [00;38;05;171mif[m (arguments.length === 0) {
    [00;38;05;171mfor[m (key [00;38;05;171min[m [00;38;05;171mthis[m._events) {
      [00;38;05;171mif[m (key === [00;38;05;196m'removeListener'[m) [00;38;05;171mcontinue[m;
      [00;38;05;171mthis[m.[00;38;05;75mremoveAllListeners[m(key);
    }
    [00;38;05;171mthis[m.[00;38;05;75mremoveAllListeners[m([00;38;05;196m'removeListener'[m);
    [00;38;05;171mthis[m._events = {};
    [00;38;05;171mreturn[m [00;38;05;171mthis[m;
  }

  listeners = [00;38;05;171mthis[m._events[type];

  [00;38;05;171mif[m ([00;38;05;75misFunction[m(listeners)) {
    [00;38;05;171mthis[m.[00;38;05;75mremoveListener[m(type, listeners);
  } [00;38;05;171melse[m [00;38;05;171mif[m (listeners) {
    [00;38;05;242m// LIFO order[m
    [00;38;05;171mwhile[m (listeners.length)
      [00;38;05;171mthis[m.[00;38;05;75mremoveListener[m(type, listeners[listeners.length - 1]);
  }
  [00;38;05;171mdelete[m [00;38;05;171mthis[m._events[type];

  [00;38;05;171mreturn[m [00;38;05;171mthis[m;
};

EventEmitter.[00;38;05;171mprototype[m.listeners = [00;38;05;171mfunction[m(type) {
  [00;38;05;171mvar[m ret;
  [00;38;05;171mif[m (![00;38;05;171mthis[m._events || ![00;38;05;171mthis[m._events[type])
    ret = [];
  [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;75misFunction[m([00;38;05;171mthis[m._events[type]))
    ret = [[00;38;05;171mthis[m._events[type]];
  [00;38;05;171melse[m
    ret = [00;38;05;171mthis[m._events[type].[00;38;05;75mslice[m();
  [00;38;05;171mreturn[m ret;
};

EventEmitter.[00;38;05;171mprototype[m.listenerCount = [00;38;05;171mfunction[m(type) {
  [00;38;05;171mif[m ([00;38;05;171mthis[m._events) {
    [00;38;05;171mvar[m evlistener = [00;38;05;171mthis[m._events[type];

    [00;38;05;171mif[m ([00;38;05;75misFunction[m(evlistener))
      [00;38;05;171mreturn[m 1;
    [00;38;05;171melse[m [00;38;05;171mif[m (evlistener)
      [00;38;05;171mreturn[m evlistener.length;
  }
  [00;38;05;171mreturn[m 0;
};

EventEmitter.listenerCount = [00;38;05;171mfunction[m(emitter, type) {
  [00;38;05;171mreturn[m emitter.[00;38;05;75mlistenerCount[m(type);
};

[00;38;05;171mfunction[m [00;38;05;75misFunction[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'function'[m;
}

[00;38;05;171mfunction[m [00;38;05;75misNumber[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'number'[m;
}

[00;38;05;171mfunction[m [00;38;05;75misObject[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'object'[m && arg !== [00;38;05;171mnull[m;
}

[00;38;05;171mfunction[m [00;38;05;75misUndefined[m(arg) {
  [00;38;05;171mreturn[m arg === void 0;
}


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 8 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;
[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(process) {

[00;38;05;171mif[m (!process.version ||
    process.version.[00;38;05;75mindexOf[m([00;38;05;196m'v0.'[m) === 0 ||
    process.version.[00;38;05;75mindexOf[m([00;38;05;196m'v1.'[m) === 0 && process.version.[00;38;05;75mindexOf[m([00;38;05;196m'v1.8.'[m) !== 0) {
  module.exports = nextTick;
} [00;38;05;171melse[m {
  module.exports = process.nextTick;
}

[00;38;05;171mfunction[m [00;38;05;75mnextTick[m(fn, arg1, arg2, arg3) {
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m fn !== [00;38;05;196m'function'[m) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'"callback" argument must be a function'[m);
  }
  [00;38;05;171mvar[m len = arguments.length;
  [00;38;05;171mvar[m args, i;
  [00;38;05;171mswitch[m (len) {
  [00;38;05;171mcase[m 0:
  [00;38;05;171mcase[m 1:
    [00;38;05;171mreturn[m process.[00;38;05;75mnextTick[m(fn);
  [00;38;05;171mcase[m 2:
    [00;38;05;171mreturn[m process.[00;38;05;75mnextTick[m([00;38;05;171mfunction[m [00;38;05;75mafterTickOne[m() {
      fn.[00;38;05;75mcall[m([00;38;05;171mnull[m, arg1);
    });
  [00;38;05;171mcase[m 3:
    [00;38;05;171mreturn[m process.[00;38;05;75mnextTick[m([00;38;05;171mfunction[m [00;38;05;75mafterTickTwo[m() {
      fn.[00;38;05;75mcall[m([00;38;05;171mnull[m, arg1, arg2);
    });
  [00;38;05;171mcase[m 4:
    [00;38;05;171mreturn[m process.[00;38;05;75mnextTick[m([00;38;05;171mfunction[m [00;38;05;75mafterTickThree[m() {
      fn.[00;38;05;75mcall[m([00;38;05;171mnull[m, arg1, arg2, arg3);
    });
  [00;38;05;171mdefault[m:
    args = [00;38;05;171mnew[m [00;38;05;75mArray[m(len - 1);
    i = 0;
    [00;38;05;171mwhile[m (i < args.length) {
      args[i++] = arguments[i];
    }
    [00;38;05;171mreturn[m process.[00;38;05;75mnextTick[m([00;38;05;171mfunction[m [00;38;05;75mafterTick[m() {
      fn.[00;38;05;75mapply[m([00;38;05;171mnull[m, args);
    });
  }
}

[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(2)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 9 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports) {

[00;38;05;171mvar[m toString = {}.toString;

module.exports = Array.isArray || [00;38;05;171mfunction[m (arr) {
  [00;38;05;171mreturn[m toString.[00;38;05;75mcall[m(arr) == [00;38;05;196m'[object Array]'[m;
};


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 10 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;
[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(process) {

module.exports = Readable;

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m processNextTick = [00;38;05;75m__webpack_require__[m(8);
[00;38;05;242m/*</replacement>*/[m

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m isArray = [00;38;05;75m__webpack_require__[m(9);
[00;38;05;242m/*</replacement>*/[m

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m Duplex;
[00;38;05;242m/*</replacement>*/[m

Readable.ReadableState = ReadableState;

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m EE = [00;38;05;75m__webpack_require__[m(7).EventEmitter;

[00;38;05;171mvar[m EElistenerCount = [00;38;05;171mfunction[m (emitter, type) {
  [00;38;05;171mreturn[m emitter.[00;38;05;75mlisteners[m(type).length;
};
[00;38;05;242m/*</replacement>*/[m

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m Stream = [00;38;05;75m__webpack_require__[m(13);
[00;38;05;242m/*</replacement>*/[m

[00;38;05;171mvar[m Buffer = [00;38;05;75m__webpack_require__[m(1).Buffer;
[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m bufferShim = [00;38;05;75m__webpack_require__[m(6);
[00;38;05;242m/*</replacement>*/[m

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m util = [00;38;05;75m__webpack_require__[m(5);
util.inherits = [00;38;05;75m__webpack_require__[m(3);
[00;38;05;242m/*</replacement>*/[m

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m debugUtil = [00;38;05;75m__webpack_require__[m(48);
[00;38;05;171mvar[m debug = void 0;
[00;38;05;171mif[m (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.[00;38;05;75mdebuglog[m([00;38;05;196m'stream'[m);
} [00;38;05;171melse[m {
  debug = [00;38;05;171mfunction[m () {};
}
[00;38;05;242m/*</replacement>*/[m

[00;38;05;171mvar[m BufferList = [00;38;05;75m__webpack_require__[m(33);
[00;38;05;171mvar[m StringDecoder;

util.[00;38;05;75minherits[m(Readable, Stream);

[00;38;05;171mvar[m kProxyEvents = [[00;38;05;196m'error'[m, [00;38;05;196m'close'[m, [00;38;05;196m'destroy'[m, [00;38;05;196m'pause'[m, [00;38;05;196m'resume'[m];

[00;38;05;171mfunction[m [00;38;05;75mprependListener[m(emitter, event, fn) {
  [00;38;05;242m// Sadly this is not cacheable as some libraries bundle their own[m
  [00;38;05;242m// event emitter implementation with them.[m
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m emitter.prependListener === [00;38;05;196m'function'[m) {
    [00;38;05;171mreturn[m emitter.[00;38;05;75mprependListener[m(event, fn);
  } [00;38;05;171melse[m {
    [00;38;05;242m// This is a hack to make sure that our error handler is attached before any[m
    [00;38;05;242m// userland ones.  NEVER DO THIS. This is here only because this code needs[m
    [00;38;05;242m// to continue to work with older versions of Node.js that do not include[m
    [00;38;05;242m// the prependListener() method. The goal is to eventually remove this hack.[m
    [00;38;05;171mif[m (!emitter._events || !emitter._events[event]) emitter.[00;38;05;75mon[m(event, fn);[00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;75misArray[m(emitter._events[event])) emitter._events[event].[00;38;05;75munshift[m(fn);[00;38;05;171melse[m emitter._events[event] = [fn, emitter._events[event]];
  }
}

[00;38;05;171mfunction[m [00;38;05;75mReadableState[m(options, stream) {
  Duplex = Duplex || [00;38;05;75m__webpack_require__[m(4);

  options = options || {};

  [00;38;05;242m// object stream flag. Used to make read(n) ignore n and to[m
  [00;38;05;242m// make all the buffer merging and length checks go away[m
  [00;38;05;171mthis[m.objectMode = !!options.objectMode;

  [00;38;05;171mif[m (stream [00;38;05;171minstanceof[m Duplex) [00;38;05;171mthis[m.objectMode = [00;38;05;171mthis[m.objectMode || !!options.readableObjectMode;

  [00;38;05;242m// the point at which it stops calling _read() to fill the buffer[m
  [00;38;05;242m// Note: 0 is a valid value, means "don't call _read preemptively ever"[m
  [00;38;05;171mvar[m hwm = options.highWaterMark;
  [00;38;05;171mvar[m defaultHwm = [00;38;05;171mthis[m.objectMode ? 16 : 16 * 1024;
  [00;38;05;171mthis[m.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  [00;38;05;242m// cast to ints.[m
  [00;38;05;171mthis[m.highWaterMark = ~~[00;38;05;171mthis[m.highWaterMark;

  [00;38;05;242m// A linked list is used to store data chunks instead of an array because the[m
  [00;38;05;242m// linked list can remove elements from the beginning faster than[m
  [00;38;05;242m// array.shift()[m
  [00;38;05;171mthis[m.buffer = [00;38;05;171mnew[m [00;38;05;75mBufferList[m();
  [00;38;05;171mthis[m.length = 0;
  [00;38;05;171mthis[m.pipes = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.pipesCount = 0;
  [00;38;05;171mthis[m.flowing = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.ended = [00;38;05;171mfalse[m;
  [00;38;05;171mthis[m.endEmitted = [00;38;05;171mfalse[m;
  [00;38;05;171mthis[m.reading = [00;38;05;171mfalse[m;

  [00;38;05;242m// a flag to be able to tell if the onwrite cb is called immediately,[m
  [00;38;05;242m// or on a later tick.  We set this to true at first, because any[m
  [00;38;05;242m// actions that shouldn't happen until "later" should generally also[m
  [00;38;05;242m// not happen before the first write call.[m
  [00;38;05;171mthis[m.sync = [00;38;05;171mtrue[m;

  [00;38;05;242m// whenever we return null, then we set a flag to say[m
  [00;38;05;242m// that we're awaiting a 'readable' event emission.[m
  [00;38;05;171mthis[m.needReadable = [00;38;05;171mfalse[m;
  [00;38;05;171mthis[m.emittedReadable = [00;38;05;171mfalse[m;
  [00;38;05;171mthis[m.readableListening = [00;38;05;171mfalse[m;
  [00;38;05;171mthis[m.resumeScheduled = [00;38;05;171mfalse[m;

  [00;38;05;242m// Crypto is kind of old and crusty.  Historically, its default string[m
  [00;38;05;242m// encoding is 'binary' so we have to make this configurable.[m
  [00;38;05;242m// Everything else in the universe uses 'utf8', though.[m
  [00;38;05;171mthis[m.defaultEncoding = options.defaultEncoding || [00;38;05;196m'utf8'[m;

  [00;38;05;242m// when piping, we only care about 'readable' events that happen[m
  [00;38;05;242m// after read()ing all the bytes and not getting any pushback.[m
  [00;38;05;171mthis[m.ranOut = [00;38;05;171mfalse[m;

  [00;38;05;242m// the number of writers that are awaiting a drain event in .pipe()s[m
  [00;38;05;171mthis[m.awaitDrain = 0;

  [00;38;05;242m// if true, a maybeReadMore has been scheduled[m
  [00;38;05;171mthis[m.readingMore = [00;38;05;171mfalse[m;

  [00;38;05;171mthis[m.decoder = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.encoding = [00;38;05;171mnull[m;
  [00;38;05;171mif[m (options.encoding) {
    [00;38;05;171mif[m (!StringDecoder) StringDecoder = [00;38;05;75m__webpack_require__[m(17).StringDecoder;
    [00;38;05;171mthis[m.decoder = [00;38;05;171mnew[m [00;38;05;75mStringDecoder[m(options.encoding);
    [00;38;05;171mthis[m.encoding = options.encoding;
  }
}

[00;38;05;171mfunction[m [00;38;05;75mReadable[m(options) {
  Duplex = Duplex || [00;38;05;75m__webpack_require__[m(4);

  [00;38;05;171mif[m (!([00;38;05;171mthis[m [00;38;05;171minstanceof[m Readable)) [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mReadable[m(options);

  [00;38;05;171mthis[m._readableState = [00;38;05;171mnew[m [00;38;05;75mReadableState[m(options, [00;38;05;171mthis[m);

  [00;38;05;242m// legacy[m
  [00;38;05;171mthis[m.readable = [00;38;05;171mtrue[m;

  [00;38;05;171mif[m (options && [00;38;05;171mtypeof[m options.read === [00;38;05;196m'function'[m) [00;38;05;171mthis[m._read = options.read;

  Stream.[00;38;05;75mcall[m([00;38;05;171mthis[m);
}

[00;38;05;242m// Manually shove something into the read() buffer.[m
[00;38;05;242m// This returns true if the highWaterMark has not been hit yet,[m
[00;38;05;242m// similar to how Writable.write() returns true if you should[m
[00;38;05;242m// write() some more.[m
Readable.[00;38;05;171mprototype[m.push = [00;38;05;171mfunction[m (chunk, encoding) {
  [00;38;05;171mvar[m state = [00;38;05;171mthis[m._readableState;

  [00;38;05;171mif[m (!state.objectMode && [00;38;05;171mtypeof[m chunk === [00;38;05;196m'string'[m) {
    encoding = encoding || state.defaultEncoding;
    [00;38;05;171mif[m (encoding !== state.encoding) {
      chunk = bufferShim.[00;38;05;75mfrom[m(chunk, encoding);
      encoding = [00;38;05;196m''[m;
    }
  }

  [00;38;05;171mreturn[m [00;38;05;75mreadableAddChunk[m([00;38;05;171mthis[m, state, chunk, encoding, [00;38;05;171mfalse[m);
};

[00;38;05;242m// Unshift should *always* be something directly out of read()[m
Readable.[00;38;05;171mprototype[m.unshift = [00;38;05;171mfunction[m (chunk) {
  [00;38;05;171mvar[m state = [00;38;05;171mthis[m._readableState;
  [00;38;05;171mreturn[m [00;38;05;75mreadableAddChunk[m([00;38;05;171mthis[m, state, chunk, [00;38;05;196m''[m, [00;38;05;171mtrue[m);
};

Readable.[00;38;05;171mprototype[m.isPaused = [00;38;05;171mfunction[m () {
  [00;38;05;171mreturn[m [00;38;05;171mthis[m._readableState.flowing === [00;38;05;171mfalse[m;
};

[00;38;05;171mfunction[m [00;38;05;75mreadableAddChunk[m(stream, state, chunk, encoding, addToFront) {
  [00;38;05;171mvar[m er = [00;38;05;75mchunkInvalid[m(state, chunk);
  [00;38;05;171mif[m (er) {
    stream.[00;38;05;75memit[m([00;38;05;196m'error'[m, er);
  } [00;38;05;171melse[m [00;38;05;171mif[m (chunk === [00;38;05;171mnull[m) {
    state.reading = [00;38;05;171mfalse[m;
    [00;38;05;75monEofChunk[m(stream, state);
  } [00;38;05;171melse[m [00;38;05;171mif[m (state.objectMode || chunk && chunk.length > 0) {
    [00;38;05;171mif[m (state.ended && !addToFront) {
      [00;38;05;171mvar[m e = [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'stream.push() after EOF'[m);
      stream.[00;38;05;75memit[m([00;38;05;196m'error'[m, e);
    } [00;38;05;171melse[m [00;38;05;171mif[m (state.endEmitted && addToFront) {
      [00;38;05;171mvar[m _e = [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'stream.unshift() after end event'[m);
      stream.[00;38;05;75memit[m([00;38;05;196m'error'[m, _e);
    } [00;38;05;171melse[m {
      [00;38;05;171mvar[m skipAdd;
      [00;38;05;171mif[m (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.[00;38;05;75mwrite[m(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      [00;38;05;171mif[m (!addToFront) state.reading = [00;38;05;171mfalse[m;

      [00;38;05;242m// Don't add to the buffer if we've decoded to an empty string chunk and[m
      [00;38;05;242m// we're not in object mode[m
      [00;38;05;171mif[m (!skipAdd) {
        [00;38;05;242m// if we want the data now, just emit it.[m
        [00;38;05;171mif[m (state.flowing && state.length === 0 && !state.sync) {
          stream.[00;38;05;75memit[m([00;38;05;196m'data'[m, chunk);
          stream.[00;38;05;75mread[m(0);
        } [00;38;05;171melse[m {
          [00;38;05;242m// update the buffer info.[m
          state.length += state.objectMode ? 1 : chunk.length;
          [00;38;05;171mif[m (addToFront) state.buffer.[00;38;05;75munshift[m(chunk);[00;38;05;171melse[m state.buffer.[00;38;05;75mpush[m(chunk);

          [00;38;05;171mif[m (state.needReadable) [00;38;05;75memitReadable[m(stream);
        }
      }

      [00;38;05;75mmaybeReadMore[m(stream, state);
    }
  } [00;38;05;171melse[m [00;38;05;171mif[m (!addToFront) {
    state.reading = [00;38;05;171mfalse[m;
  }

  [00;38;05;171mreturn[m [00;38;05;75mneedMoreData[m(state);
}

[00;38;05;242m// if it's past the high water mark, we can push in some more.[m
[00;38;05;242m// Also, if we have no data yet, we can stand some[m
[00;38;05;242m// more bytes.  This is to work around cases where hwm=0,[m
[00;38;05;242m// such as the repl.  Also, if the push() triggered a[m
[00;38;05;242m// readable event, and the user called read(largeNumber) such that[m
[00;38;05;242m// needReadable was set, then we ought to push more, so that another[m
[00;38;05;242m// 'readable' event will be triggered.[m
[00;38;05;171mfunction[m [00;38;05;75mneedMoreData[m(state) {
  [00;38;05;171mreturn[m !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

[00;38;05;242m// backwards compatibility.[m
Readable.[00;38;05;171mprototype[m.setEncoding = [00;38;05;171mfunction[m (enc) {
  [00;38;05;171mif[m (!StringDecoder) StringDecoder = [00;38;05;75m__webpack_require__[m(17).StringDecoder;
  [00;38;05;171mthis[m._readableState.decoder = [00;38;05;171mnew[m [00;38;05;75mStringDecoder[m(enc);
  [00;38;05;171mthis[m._readableState.encoding = enc;
  [00;38;05;171mreturn[m [00;38;05;171mthis[m;
};

[00;38;05;242m// Don't raise the hwm > 8MB[m
[00;38;05;171mvar[m MAX_HWM = 0x800000;
[00;38;05;171mfunction[m [00;38;05;75mcomputeNewHighWaterMark[m(n) {
  [00;38;05;171mif[m (n >= MAX_HWM) {
    n = MAX_HWM;
  } [00;38;05;171melse[m {
    [00;38;05;242m// Get the next highest power of 2 to prevent increasing hwm excessively in[m
    [00;38;05;242m// tiny amounts[m
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  [00;38;05;171mreturn[m n;
}

[00;38;05;242m// This function is designed to be inlinable, so please take care when making[m
[00;38;05;242m// changes to the function body.[m
[00;38;05;171mfunction[m [00;38;05;75mhowMuchToRead[m(n, state) {
  [00;38;05;171mif[m (n <= 0 || state.length === 0 && state.ended) [00;38;05;171mreturn[m 0;
  [00;38;05;171mif[m (state.objectMode) [00;38;05;171mreturn[m 1;
  [00;38;05;171mif[m (n !== n) {
    [00;38;05;242m// Only flow one buffer at a time[m
    [00;38;05;171mif[m (state.flowing && state.length) [00;38;05;171mreturn[m state.buffer.head.data.length;[00;38;05;171melse[m [00;38;05;171mreturn[m state.length;
  }
  [00;38;05;242m// If we're asking for more than the current hwm, then raise the hwm.[m
  [00;38;05;171mif[m (n > state.highWaterMark) state.highWaterMark = [00;38;05;75mcomputeNewHighWaterMark[m(n);
  [00;38;05;171mif[m (n <= state.length) [00;38;05;171mreturn[m n;
  [00;38;05;242m// Don't have enough[m
  [00;38;05;171mif[m (!state.ended) {
    state.needReadable = [00;38;05;171mtrue[m;
    [00;38;05;171mreturn[m 0;
  }
  [00;38;05;171mreturn[m state.length;
}

[00;38;05;242m// you can override either this method, or the async _read(n) below.[m
Readable.[00;38;05;171mprototype[m.read = [00;38;05;171mfunction[m (n) {
  [00;38;05;75mdebug[m([00;38;05;196m'read'[m, n);
  n = [00;38;05;75mparseInt[m(n, 10);
  [00;38;05;171mvar[m state = [00;38;05;171mthis[m._readableState;
  [00;38;05;171mvar[m nOrig = n;

  [00;38;05;171mif[m (n !== 0) state.emittedReadable = [00;38;05;171mfalse[m;

  [00;38;05;242m// if we're doing read(0) to trigger a readable event, but we[m
  [00;38;05;242m// already have a bunch of data in the buffer, then just trigger[m
  [00;38;05;242m// the 'readable' event and move on.[m
  [00;38;05;171mif[m (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    [00;38;05;75mdebug[m([00;38;05;196m'read: emitReadable'[m, state.length, state.ended);
    [00;38;05;171mif[m (state.length === 0 && state.ended) [00;38;05;75mendReadable[m([00;38;05;171mthis[m);[00;38;05;171melse[m [00;38;05;75memitReadable[m([00;38;05;171mthis[m);
    [00;38;05;171mreturn[m [00;38;05;171mnull[m;
  }

  n = [00;38;05;75mhowMuchToRead[m(n, state);

  [00;38;05;242m// if we've ended, and we're now clear, then finish it up.[m
  [00;38;05;171mif[m (n === 0 && state.ended) {
    [00;38;05;171mif[m (state.length === 0) [00;38;05;75mendReadable[m([00;38;05;171mthis[m);
    [00;38;05;171mreturn[m [00;38;05;171mnull[m;
  }

  [00;38;05;242m// All the actual chunk generation logic needs to be[m
  [00;38;05;242m// *below* the call to _read.  The reason is that in certain[m
  [00;38;05;242m// synthetic stream cases, such as passthrough streams, _read[m
  [00;38;05;242m// may be a completely synchronous operation which may change[m
  [00;38;05;242m// the state of the read buffer, providing enough data when[m
  [00;38;05;242m// before there was *not* enough.[m
  [00;38;05;242m//[m
  [00;38;05;242m// So, the steps are:[m
  [00;38;05;242m// 1. Figure out what the state of things will be after we do[m
  [00;38;05;242m// a read from the buffer.[m
  [00;38;05;242m//[m
  [00;38;05;242m// 2. If that resulting state will trigger a _read, then call _read.[m
  [00;38;05;242m// Note that this may be asynchronous, or synchronous.  Yes, it is[m
  [00;38;05;242m// deeply ugly to write APIs this way, but that still doesn't mean[m
  [00;38;05;242m// that the Readable class should behave improperly, as streams are[m
  [00;38;05;242m// designed to be sync/async agnostic.[m
  [00;38;05;242m// Take note if the _read call is sync or async (ie, if the read call[m
  [00;38;05;242m// has returned yet), so that we know whether or not it's safe to emit[m
  [00;38;05;242m// 'readable' etc.[m
  [00;38;05;242m//[m
  [00;38;05;242m// 3. Actually pull the requested chunks out of the buffer and return.[m

  [00;38;05;242m// if we need a readable event, then we need to do some reading.[m
  [00;38;05;171mvar[m doRead = state.needReadable;
  [00;38;05;75mdebug[m([00;38;05;196m'need readable'[m, doRead);

  [00;38;05;242m// if we currently have less than the highWaterMark, then also read some[m
  [00;38;05;171mif[m (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = [00;38;05;171mtrue[m;
    [00;38;05;75mdebug[m([00;38;05;196m'length less than watermark'[m, doRead);
  }

  [00;38;05;242m// however, if we've ended, then there's no point, and if we're already[m
  [00;38;05;242m// reading, then it's unnecessary.[m
  [00;38;05;171mif[m (state.ended || state.reading) {
    doRead = [00;38;05;171mfalse[m;
    [00;38;05;75mdebug[m([00;38;05;196m'reading or ended'[m, doRead);
  } [00;38;05;171melse[m [00;38;05;171mif[m (doRead) {
    [00;38;05;75mdebug[m([00;38;05;196m'do read'[m);
    state.reading = [00;38;05;171mtrue[m;
    state.sync = [00;38;05;171mtrue[m;
    [00;38;05;242m// if the length is currently zero, then we *need* a readable event.[m
    [00;38;05;171mif[m (state.length === 0) state.needReadable = [00;38;05;171mtrue[m;
    [00;38;05;242m// call internal read method[m
    [00;38;05;171mthis[m.[00;38;05;75m_read[m(state.highWaterMark);
    state.sync = [00;38;05;171mfalse[m;
    [00;38;05;242m// If _read pushed data synchronously, then `reading` will be false,[m
    [00;38;05;242m// and we need to re-evaluate how much data we can return to the user.[m
    [00;38;05;171mif[m (!state.reading) n = [00;38;05;75mhowMuchToRead[m(nOrig, state);
  }

  [00;38;05;171mvar[m ret;
  [00;38;05;171mif[m (n > 0) ret = [00;38;05;75mfromList[m(n, state);[00;38;05;171melse[m ret = [00;38;05;171mnull[m;

  [00;38;05;171mif[m (ret === [00;38;05;171mnull[m) {
    state.needReadable = [00;38;05;171mtrue[m;
    n = 0;
  } [00;38;05;171melse[m {
    state.length -= n;
  }

  [00;38;05;171mif[m (state.length === 0) {
    [00;38;05;242m// If we have nothing in the buffer, then we want to know[m
    [00;38;05;242m// as soon as we *do* get something into the buffer.[m
    [00;38;05;171mif[m (!state.ended) state.needReadable = [00;38;05;171mtrue[m;

    [00;38;05;242m// If we tried to read() past the EOF, then emit end on the next tick.[m
    [00;38;05;171mif[m (nOrig !== n && state.ended) [00;38;05;75mendReadable[m([00;38;05;171mthis[m);
  }

  [00;38;05;171mif[m (ret !== [00;38;05;171mnull[m) [00;38;05;171mthis[m.[00;38;05;75memit[m([00;38;05;196m'data'[m, ret);

  [00;38;05;171mreturn[m ret;
};

[00;38;05;171mfunction[m [00;38;05;75mchunkInvalid[m(state, chunk) {
  [00;38;05;171mvar[m er = [00;38;05;171mnull[m;
  [00;38;05;171mif[m (!Buffer.[00;38;05;75misBuffer[m(chunk) && [00;38;05;171mtypeof[m chunk !== [00;38;05;196m'string'[m && chunk !== [00;38;05;171mnull[m && chunk !== undefined && !state.objectMode) {
    er = [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'Invalid non-string/buffer chunk'[m);
  }
  [00;38;05;171mreturn[m er;
}

[00;38;05;171mfunction[m [00;38;05;75monEofChunk[m(stream, state) {
  [00;38;05;171mif[m (state.ended) [00;38;05;171mreturn[m;
  [00;38;05;171mif[m (state.decoder) {
    [00;38;05;171mvar[m chunk = state.decoder.[00;38;05;75mend[m();
    [00;38;05;171mif[m (chunk && chunk.length) {
      state.buffer.[00;38;05;75mpush[m(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = [00;38;05;171mtrue[m;

  [00;38;05;242m// emit 'readable' now to make sure it gets picked up.[m
  [00;38;05;75memitReadable[m(stream);
}

[00;38;05;242m// Don't emit readable right away in sync mode, because this can trigger[m
[00;38;05;242m// another read() call => stack overflow.  This way, it might trigger[m
[00;38;05;242m// a nextTick recursion warning, but that's not so bad.[m
[00;38;05;171mfunction[m [00;38;05;75memitReadable[m(stream) {
  [00;38;05;171mvar[m state = stream._readableState;
  state.needReadable = [00;38;05;171mfalse[m;
  [00;38;05;171mif[m (!state.emittedReadable) {
    [00;38;05;75mdebug[m([00;38;05;196m'emitReadable'[m, state.flowing);
    state.emittedReadable = [00;38;05;171mtrue[m;
    [00;38;05;171mif[m (state.sync) [00;38;05;75mprocessNextTick[m(emitReadable_, stream);[00;38;05;171melse[m [00;38;05;75memitReadable_[m(stream);
  }
}

[00;38;05;171mfunction[m [00;38;05;75memitReadable_[m(stream) {
  [00;38;05;75mdebug[m([00;38;05;196m'emit readable'[m);
  stream.[00;38;05;75memit[m([00;38;05;196m'readable'[m);
  [00;38;05;75mflow[m(stream);
}

[00;38;05;242m// at this point, the user has presumably seen the 'readable' event,[m
[00;38;05;242m// and called read() to consume some data.  that may have triggered[m
[00;38;05;242m// in turn another _read(n) call, in which case reading = true if[m
[00;38;05;242m// it's in progress.[m
[00;38;05;242m// However, if we're not ended, or reading, and the length < hwm,[m
[00;38;05;242m// then go ahead and try to read some more preemptively.[m
[00;38;05;171mfunction[m [00;38;05;75mmaybeReadMore[m(stream, state) {
  [00;38;05;171mif[m (!state.readingMore) {
    state.readingMore = [00;38;05;171mtrue[m;
    [00;38;05;75mprocessNextTick[m(maybeReadMore_, stream, state);
  }
}

[00;38;05;171mfunction[m [00;38;05;75mmaybeReadMore_[m(stream, state) {
  [00;38;05;171mvar[m len = state.length;
  [00;38;05;171mwhile[m (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    [00;38;05;75mdebug[m([00;38;05;196m'maybeReadMore read 0'[m);
    stream.[00;38;05;75mread[m(0);
    [00;38;05;171mif[m (len === state.length)
      [00;38;05;242m// didn't get any data, stop spinning.[m
      [00;38;05;171mbreak[m;[00;38;05;171melse[m len = state.length;
  }
  state.readingMore = [00;38;05;171mfalse[m;
}

[00;38;05;242m// abstract method.  to be overridden in specific implementation classes.[m
[00;38;05;242m// call cb(er, data) where data is <= n in length.[m
[00;38;05;242m// for virtual (non-string, non-buffer) streams, "length" is somewhat[m
[00;38;05;242m// arbitrary, and perhaps not very meaningful.[m
Readable.[00;38;05;171mprototype[m._read = [00;38;05;171mfunction[m (n) {
  [00;38;05;171mthis[m.[00;38;05;75memit[m([00;38;05;196m'error'[m, [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'_read() is not implemented'[m));
};

Readable.[00;38;05;171mprototype[m.pipe = [00;38;05;171mfunction[m (dest, pipeOpts) {
  [00;38;05;171mvar[m src = [00;38;05;171mthis[m;
  [00;38;05;171mvar[m state = [00;38;05;171mthis[m._readableState;

  [00;38;05;171mswitch[m (state.pipesCount) {
    [00;38;05;171mcase[m 0:
      state.pipes = dest;
      [00;38;05;171mbreak[m;
    [00;38;05;171mcase[m 1:
      state.pipes = [state.pipes, dest];
      [00;38;05;171mbreak[m;
    [00;38;05;171mdefault[m:
      state.pipes.[00;38;05;75mpush[m(dest);
      [00;38;05;171mbreak[m;
  }
  state.pipesCount += 1;
  [00;38;05;75mdebug[m([00;38;05;196m'pipe count=%d opts=%j'[m, state.pipesCount, pipeOpts);

  [00;38;05;171mvar[m doEnd = (!pipeOpts || pipeOpts.end !== [00;38;05;171mfalse[m) && dest !== process.stdout && dest !== process.stderr;

  [00;38;05;171mvar[m endFn = doEnd ? onend : cleanup;
  [00;38;05;171mif[m (state.endEmitted) [00;38;05;75mprocessNextTick[m(endFn);[00;38;05;171melse[m src.[00;38;05;75monce[m([00;38;05;196m'end'[m, endFn);

  dest.[00;38;05;75mon[m([00;38;05;196m'unpipe'[m, onunpipe);
  [00;38;05;171mfunction[m [00;38;05;75monunpipe[m(readable) {
    [00;38;05;75mdebug[m([00;38;05;196m'onunpipe'[m);
    [00;38;05;171mif[m (readable === src) {
      [00;38;05;75mcleanup[m();
    }
  }

  [00;38;05;171mfunction[m [00;38;05;75monend[m() {
    [00;38;05;75mdebug[m([00;38;05;196m'onend'[m);
    dest.[00;38;05;75mend[m();
  }

  [00;38;05;242m// when the dest drains, it reduces the awaitDrain counter[m
  [00;38;05;242m// on the source.  This would be more elegant with a .once()[m
  [00;38;05;242m// handler in flow(), but adding and removing repeatedly is[m
  [00;38;05;242m// too slow.[m
  [00;38;05;171mvar[m ondrain = [00;38;05;75mpipeOnDrain[m(src);
  dest.[00;38;05;75mon[m([00;38;05;196m'drain'[m, ondrain);

  [00;38;05;171mvar[m cleanedUp = [00;38;05;171mfalse[m;
  [00;38;05;171mfunction[m [00;38;05;75mcleanup[m() {
    [00;38;05;75mdebug[m([00;38;05;196m'cleanup'[m);
    [00;38;05;242m// cleanup event handlers once the pipe is broken[m
    dest.[00;38;05;75mremoveListener[m([00;38;05;196m'close'[m, onclose);
    dest.[00;38;05;75mremoveListener[m([00;38;05;196m'finish'[m, onfinish);
    dest.[00;38;05;75mremoveListener[m([00;38;05;196m'drain'[m, ondrain);
    dest.[00;38;05;75mremoveListener[m([00;38;05;196m'error'[m, onerror);
    dest.[00;38;05;75mremoveListener[m([00;38;05;196m'unpipe'[m, onunpipe);
    src.[00;38;05;75mremoveListener[m([00;38;05;196m'end'[m, onend);
    src.[00;38;05;75mremoveListener[m([00;38;05;196m'end'[m, cleanup);
    src.[00;38;05;75mremoveListener[m([00;38;05;196m'data'[m, ondata);

    cleanedUp = [00;38;05;171mtrue[m;

    [00;38;05;242m// if the reader is waiting for a drain event from this[m
    [00;38;05;242m// specific writer, then it would cause it to never start[m
    [00;38;05;242m// flowing again.[m
    [00;38;05;242m// So, if this is awaiting a drain, then we just call it now.[m
    [00;38;05;242m// If we don't know, then assume that we are waiting for one.[m
    [00;38;05;171mif[m (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) [00;38;05;75mondrain[m();
  }

  [00;38;05;242m// If the user pushes more data while we're writing to dest then we'll end up[m
  [00;38;05;242m// in ondata again. However, we only want to increase awaitDrain once because[m
  [00;38;05;242m// dest will only emit one 'drain' event for the multiple writes.[m
  [00;38;05;242m// => Introduce a guard on increasing awaitDrain.[m
  [00;38;05;171mvar[m increasedAwaitDrain = [00;38;05;171mfalse[m;
  src.[00;38;05;75mon[m([00;38;05;196m'data'[m, ondata);
  [00;38;05;171mfunction[m [00;38;05;75mondata[m(chunk) {
    [00;38;05;75mdebug[m([00;38;05;196m'ondata'[m);
    increasedAwaitDrain = [00;38;05;171mfalse[m;
    [00;38;05;171mvar[m ret = dest.[00;38;05;75mwrite[m(chunk);
    [00;38;05;171mif[m ([00;38;05;171mfalse[m === ret && !increasedAwaitDrain) {
      [00;38;05;242m// If the user unpiped during `dest.write()`, it is possible[m
      [00;38;05;242m// to get stuck in a permanently paused state if that write[m
      [00;38;05;242m// also returned false.[m
      [00;38;05;242m// => Check whether `dest` is still a piping destination.[m
      [00;38;05;171mif[m ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && [00;38;05;75mindexOf[m(state.pipes, dest) !== -1) && !cleanedUp) {
        [00;38;05;75mdebug[m([00;38;05;196m'false write response, pause'[m, src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = [00;38;05;171mtrue[m;
      }
      src.[00;38;05;75mpause[m();
    }
  }

  [00;38;05;242m// if the dest has an error, then stop piping into it.[m
  [00;38;05;242m// however, don't suppress the throwing behavior for this.[m
  [00;38;05;171mfunction[m [00;38;05;75monerror[m(er) {
    [00;38;05;75mdebug[m([00;38;05;196m'onerror'[m, er);
    [00;38;05;75munpipe[m();
    dest.[00;38;05;75mremoveListener[m([00;38;05;196m'error'[m, onerror);
    [00;38;05;171mif[m ([00;38;05;75mEElistenerCount[m(dest, [00;38;05;196m'error'[m) === 0) dest.[00;38;05;75memit[m([00;38;05;196m'error'[m, er);
  }

  [00;38;05;242m// Make sure our error handler is attached before userland ones.[m
  [00;38;05;75mprependListener[m(dest, [00;38;05;196m'error'[m, onerror);

  [00;38;05;242m// Both close and finish should trigger unpipe, but only once.[m
  [00;38;05;171mfunction[m [00;38;05;75monclose[m() {
    dest.[00;38;05;75mremoveListener[m([00;38;05;196m'finish'[m, onfinish);
    [00;38;05;75munpipe[m();
  }
  dest.[00;38;05;75monce[m([00;38;05;196m'close'[m, onclose);
  [00;38;05;171mfunction[m [00;38;05;75monfinish[m() {
    [00;38;05;75mdebug[m([00;38;05;196m'onfinish'[m);
    dest.[00;38;05;75mremoveListener[m([00;38;05;196m'close'[m, onclose);
    [00;38;05;75munpipe[m();
  }
  dest.[00;38;05;75monce[m([00;38;05;196m'finish'[m, onfinish);

  [00;38;05;171mfunction[m [00;38;05;75munpipe[m() {
    [00;38;05;75mdebug[m([00;38;05;196m'unpipe'[m);
    src.[00;38;05;75munpipe[m(dest);
  }

  [00;38;05;242m// tell the dest that it's being piped to[m
  dest.[00;38;05;75memit[m([00;38;05;196m'pipe'[m, src);

  [00;38;05;242m// start the flow if it hasn't been started already.[m
  [00;38;05;171mif[m (!state.flowing) {
    [00;38;05;75mdebug[m([00;38;05;196m'pipe resume'[m);
    src.[00;38;05;75mresume[m();
  }

  [00;38;05;171mreturn[m dest;
};

[00;38;05;171mfunction[m [00;38;05;75mpipeOnDrain[m(src) {
  [00;38;05;171mreturn[m [00;38;05;171mfunction[m () {
    [00;38;05;171mvar[m state = src._readableState;
    [00;38;05;75mdebug[m([00;38;05;196m'pipeOnDrain'[m, state.awaitDrain);
    [00;38;05;171mif[m (state.awaitDrain) state.awaitDrain--;
    [00;38;05;171mif[m (state.awaitDrain === 0 && [00;38;05;75mEElistenerCount[m(src, [00;38;05;196m'data'[m)) {
      state.flowing = [00;38;05;171mtrue[m;
      [00;38;05;75mflow[m(src);
    }
  };
}

Readable.[00;38;05;171mprototype[m.unpipe = [00;38;05;171mfunction[m (dest) {
  [00;38;05;171mvar[m state = [00;38;05;171mthis[m._readableState;

  [00;38;05;242m// if we're not piping anywhere, then do nothing.[m
  [00;38;05;171mif[m (state.pipesCount === 0) [00;38;05;171mreturn[m [00;38;05;171mthis[m;

  [00;38;05;242m// just one destination.  most common case.[m
  [00;38;05;171mif[m (state.pipesCount === 1) {
    [00;38;05;242m// passed in one, but it's not the right one.[m
    [00;38;05;171mif[m (dest && dest !== state.pipes) [00;38;05;171mreturn[m [00;38;05;171mthis[m;

    [00;38;05;171mif[m (!dest) dest = state.pipes;

    [00;38;05;242m// got a match.[m
    state.pipes = [00;38;05;171mnull[m;
    state.pipesCount = 0;
    state.flowing = [00;38;05;171mfalse[m;
    [00;38;05;171mif[m (dest) dest.[00;38;05;75memit[m([00;38;05;196m'unpipe'[m, [00;38;05;171mthis[m);
    [00;38;05;171mreturn[m [00;38;05;171mthis[m;
  }

  [00;38;05;242m// slow case. multiple pipe destinations.[m

  [00;38;05;171mif[m (!dest) {
    [00;38;05;242m// remove all.[m
    [00;38;05;171mvar[m dests = state.pipes;
    [00;38;05;171mvar[m len = state.pipesCount;
    state.pipes = [00;38;05;171mnull[m;
    state.pipesCount = 0;
    state.flowing = [00;38;05;171mfalse[m;

    [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < len; i++) {
      dests[i].[00;38;05;75memit[m([00;38;05;196m'unpipe'[m, [00;38;05;171mthis[m);
    }[00;38;05;171mreturn[m [00;38;05;171mthis[m;
  }

  [00;38;05;242m// try to find the right one.[m
  [00;38;05;171mvar[m index = [00;38;05;75mindexOf[m(state.pipes, dest);
  [00;38;05;171mif[m (index === -1) [00;38;05;171mreturn[m [00;38;05;171mthis[m;

  state.pipes.[00;38;05;75msplice[m(index, 1);
  state.pipesCount -= 1;
  [00;38;05;171mif[m (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.[00;38;05;75memit[m([00;38;05;196m'unpipe'[m, [00;38;05;171mthis[m);

  [00;38;05;171mreturn[m [00;38;05;171mthis[m;
};

[00;38;05;242m// set up data events if they are asked for[m
[00;38;05;242m// Ensure readable listeners eventually get something[m
Readable.[00;38;05;171mprototype[m.on = [00;38;05;171mfunction[m (ev, fn) {
  [00;38;05;171mvar[m res = Stream.[00;38;05;171mprototype[m.on.[00;38;05;75mcall[m([00;38;05;171mthis[m, ev, fn);

  [00;38;05;171mif[m (ev === [00;38;05;196m'data'[m) {
    [00;38;05;242m// Start flowing on next tick if stream isn't explicitly paused[m
    [00;38;05;171mif[m ([00;38;05;171mthis[m._readableState.flowing !== [00;38;05;171mfalse[m) [00;38;05;171mthis[m.[00;38;05;75mresume[m();
  } [00;38;05;171melse[m [00;38;05;171mif[m (ev === [00;38;05;196m'readable'[m) {
    [00;38;05;171mvar[m state = [00;38;05;171mthis[m._readableState;
    [00;38;05;171mif[m (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = [00;38;05;171mtrue[m;
      state.emittedReadable = [00;38;05;171mfalse[m;
      [00;38;05;171mif[m (!state.reading) {
        [00;38;05;75mprocessNextTick[m(nReadingNextTick, [00;38;05;171mthis[m);
      } [00;38;05;171melse[m [00;38;05;171mif[m (state.length) {
        [00;38;05;75memitReadable[m([00;38;05;171mthis[m, state);
      }
    }
  }

  [00;38;05;171mreturn[m res;
};
Readable.[00;38;05;171mprototype[m.addListener = Readable.[00;38;05;171mprototype[m.on;

[00;38;05;171mfunction[m [00;38;05;75mnReadingNextTick[m(self) {
  [00;38;05;75mdebug[m([00;38;05;196m'readable nexttick read 0'[m);
  self.[00;38;05;75mread[m(0);
}

[00;38;05;242m// pause() and resume() are remnants of the legacy readable stream API[m
[00;38;05;242m// If the user uses them, then switch into old mode.[m
Readable.[00;38;05;171mprototype[m.resume = [00;38;05;171mfunction[m () {
  [00;38;05;171mvar[m state = [00;38;05;171mthis[m._readableState;
  [00;38;05;171mif[m (!state.flowing) {
    [00;38;05;75mdebug[m([00;38;05;196m'resume'[m);
    state.flowing = [00;38;05;171mtrue[m;
    [00;38;05;75mresume[m([00;38;05;171mthis[m, state);
  }
  [00;38;05;171mreturn[m [00;38;05;171mthis[m;
};

[00;38;05;171mfunction[m [00;38;05;75mresume[m(stream, state) {
  [00;38;05;171mif[m (!state.resumeScheduled) {
    state.resumeScheduled = [00;38;05;171mtrue[m;
    [00;38;05;75mprocessNextTick[m(resume_, stream, state);
  }
}

[00;38;05;171mfunction[m [00;38;05;75mresume_[m(stream, state) {
  [00;38;05;171mif[m (!state.reading) {
    [00;38;05;75mdebug[m([00;38;05;196m'resume read 0'[m);
    stream.[00;38;05;75mread[m(0);
  }

  state.resumeScheduled = [00;38;05;171mfalse[m;
  state.awaitDrain = 0;
  stream.[00;38;05;75memit[m([00;38;05;196m'resume'[m);
  [00;38;05;75mflow[m(stream);
  [00;38;05;171mif[m (state.flowing && !state.reading) stream.[00;38;05;75mread[m(0);
}

Readable.[00;38;05;171mprototype[m.pause = [00;38;05;171mfunction[m () {
  [00;38;05;75mdebug[m([00;38;05;196m'call pause flowing=%j'[m, [00;38;05;171mthis[m._readableState.flowing);
  [00;38;05;171mif[m ([00;38;05;171mfalse[m !== [00;38;05;171mthis[m._readableState.flowing) {
    [00;38;05;75mdebug[m([00;38;05;196m'pause'[m);
    [00;38;05;171mthis[m._readableState.flowing = [00;38;05;171mfalse[m;
    [00;38;05;171mthis[m.[00;38;05;75memit[m([00;38;05;196m'pause'[m);
  }
  [00;38;05;171mreturn[m [00;38;05;171mthis[m;
};

[00;38;05;171mfunction[m [00;38;05;75mflow[m(stream) {
  [00;38;05;171mvar[m state = stream._readableState;
  [00;38;05;75mdebug[m([00;38;05;196m'flow'[m, state.flowing);
  [00;38;05;171mwhile[m (state.flowing && stream.[00;38;05;75mread[m() !== [00;38;05;171mnull[m) {}
}

[00;38;05;242m// wrap an old-style stream as the async data source.[m
[00;38;05;242m// This is *not* part of the readable stream interface.[m
[00;38;05;242m// It is an ugly unfortunate mess of history.[m
Readable.[00;38;05;171mprototype[m.wrap = [00;38;05;171mfunction[m (stream) {
  [00;38;05;171mvar[m state = [00;38;05;171mthis[m._readableState;
  [00;38;05;171mvar[m paused = [00;38;05;171mfalse[m;

  [00;38;05;171mvar[m self = [00;38;05;171mthis[m;
  stream.[00;38;05;75mon[m([00;38;05;196m'end'[m, [00;38;05;171mfunction[m () {
    [00;38;05;75mdebug[m([00;38;05;196m'wrapped end'[m);
    [00;38;05;171mif[m (state.decoder && !state.ended) {
      [00;38;05;171mvar[m chunk = state.decoder.[00;38;05;75mend[m();
      [00;38;05;171mif[m (chunk && chunk.length) self.[00;38;05;75mpush[m(chunk);
    }

    self.[00;38;05;75mpush[m([00;38;05;171mnull[m);
  });

  stream.[00;38;05;75mon[m([00;38;05;196m'data'[m, [00;38;05;171mfunction[m (chunk) {
    [00;38;05;75mdebug[m([00;38;05;196m'wrapped data'[m);
    [00;38;05;171mif[m (state.decoder) chunk = state.decoder.[00;38;05;75mwrite[m(chunk);

    [00;38;05;242m// don't skip over falsy values in objectMode[m
    [00;38;05;171mif[m (state.objectMode && (chunk === [00;38;05;171mnull[m || chunk === undefined)) [00;38;05;171mreturn[m;[00;38;05;171melse[m [00;38;05;171mif[m (!state.objectMode && (!chunk || !chunk.length)) [00;38;05;171mreturn[m;

    [00;38;05;171mvar[m ret = self.[00;38;05;75mpush[m(chunk);
    [00;38;05;171mif[m (!ret) {
      paused = [00;38;05;171mtrue[m;
      stream.[00;38;05;75mpause[m();
    }
  });

  [00;38;05;242m// proxy all the other methods.[m
  [00;38;05;242m// important when wrapping filters and duplexes.[m
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i [00;38;05;171min[m stream) {
    [00;38;05;171mif[m ([00;38;05;171mthis[m[i] === undefined && [00;38;05;171mtypeof[m stream[i] === [00;38;05;196m'function'[m) {
      [00;38;05;171mthis[m[i] = [00;38;05;171mfunction[m (method) {
        [00;38;05;171mreturn[m [00;38;05;171mfunction[m () {
          [00;38;05;171mreturn[m stream[method].[00;38;05;75mapply[m(stream, arguments);
        };
      }(i);
    }
  }

  [00;38;05;242m// proxy certain important events.[m
  [00;38;05;171mfor[m ([00;38;05;171mvar[m n = 0; n < kProxyEvents.length; n++) {
    stream.[00;38;05;75mon[m(kProxyEvents[n], self.emit.[00;38;05;75mbind[m(self, kProxyEvents[n]));
  }

  [00;38;05;242m// when we try to consume some more bytes, simply unpause the[m
  [00;38;05;242m// underlying stream.[m
  self._read = [00;38;05;171mfunction[m (n) {
    [00;38;05;75mdebug[m([00;38;05;196m'wrapped _read'[m, n);
    [00;38;05;171mif[m (paused) {
      paused = [00;38;05;171mfalse[m;
      stream.[00;38;05;75mresume[m();
    }
  };

  [00;38;05;171mreturn[m self;
};

[00;38;05;242m// exposed for testing purposes only.[m
Readable._fromList = fromList;

[00;38;05;242m// Pluck off n bytes from an array of buffers.[m
[00;38;05;242m// Length is the combined lengths of all the buffers in the list.[m
[00;38;05;242m// This function is designed to be inlinable, so please take care when making[m
[00;38;05;242m// changes to the function body.[m
[00;38;05;171mfunction[m [00;38;05;75mfromList[m(n, state) {
  [00;38;05;242m// nothing buffered[m
  [00;38;05;171mif[m (state.length === 0) [00;38;05;171mreturn[m [00;38;05;171mnull[m;

  [00;38;05;171mvar[m ret;
  [00;38;05;171mif[m (state.objectMode) ret = state.buffer.[00;38;05;75mshift[m();[00;38;05;171melse[m [00;38;05;171mif[m (!n || n >= state.length) {
    [00;38;05;242m// read it all, truncate the list[m
    [00;38;05;171mif[m (state.decoder) ret = state.buffer.[00;38;05;75mjoin[m([00;38;05;196m''[m);[00;38;05;171melse[m [00;38;05;171mif[m (state.buffer.length === 1) ret = state.buffer.head.data;[00;38;05;171melse[m ret = state.buffer.[00;38;05;75mconcat[m(state.length);
    state.buffer.[00;38;05;75mclear[m();
  } [00;38;05;171melse[m {
    [00;38;05;242m// read part of list[m
    ret = [00;38;05;75mfromListPartial[m(n, state.buffer, state.decoder);
  }

  [00;38;05;171mreturn[m ret;
}

[00;38;05;242m// Extracts only enough buffered data to satisfy the amount requested.[m
[00;38;05;242m// This function is designed to be inlinable, so please take care when making[m
[00;38;05;242m// changes to the function body.[m
[00;38;05;171mfunction[m [00;38;05;75mfromListPartial[m(n, list, hasStrings) {
  [00;38;05;171mvar[m ret;
  [00;38;05;171mif[m (n < list.head.data.length) {
    [00;38;05;242m// slice is the same for buffers and strings[m
    ret = list.head.data.[00;38;05;75mslice[m(0, n);
    list.head.data = list.head.data.[00;38;05;75mslice[m(n);
  } [00;38;05;171melse[m [00;38;05;171mif[m (n === list.head.data.length) {
    [00;38;05;242m// first chunk is a perfect match[m
    ret = list.[00;38;05;75mshift[m();
  } [00;38;05;171melse[m {
    [00;38;05;242m// result spans more than one buffer[m
    ret = hasStrings ? [00;38;05;75mcopyFromBufferString[m(n, list) : [00;38;05;75mcopyFromBuffer[m(n, list);
  }
  [00;38;05;171mreturn[m ret;
}

[00;38;05;242m// Copies a specified amount of characters from the list of buffered data[m
[00;38;05;242m// chunks.[m
[00;38;05;242m// This function is designed to be inlinable, so please take care when making[m
[00;38;05;242m// changes to the function body.[m
[00;38;05;171mfunction[m [00;38;05;75mcopyFromBufferString[m(n, list) {
  [00;38;05;171mvar[m p = list.head;
  [00;38;05;171mvar[m c = 1;
  [00;38;05;171mvar[m ret = p.data;
  n -= ret.length;
  [00;38;05;171mwhile[m (p = p.next) {
    [00;38;05;171mvar[m str = p.data;
    [00;38;05;171mvar[m nb = n > str.length ? str.length : n;
    [00;38;05;171mif[m (nb === str.length) ret += str;[00;38;05;171melse[m ret += str.[00;38;05;75mslice[m(0, n);
    n -= nb;
    [00;38;05;171mif[m (n === 0) {
      [00;38;05;171mif[m (nb === str.length) {
        ++c;
        [00;38;05;171mif[m (p.next) list.head = p.next;[00;38;05;171melse[m list.head = list.tail = [00;38;05;171mnull[m;
      } [00;38;05;171melse[m {
        list.head = p;
        p.data = str.[00;38;05;75mslice[m(nb);
      }
      [00;38;05;171mbreak[m;
    }
    ++c;
  }
  list.length -= c;
  [00;38;05;171mreturn[m ret;
}

[00;38;05;242m// Copies a specified amount of bytes from the list of buffered data chunks.[m
[00;38;05;242m// This function is designed to be inlinable, so please take care when making[m
[00;38;05;242m// changes to the function body.[m
[00;38;05;171mfunction[m [00;38;05;75mcopyFromBuffer[m(n, list) {
  [00;38;05;171mvar[m ret = bufferShim.[00;38;05;75mallocUnsafe[m(n);
  [00;38;05;171mvar[m p = list.head;
  [00;38;05;171mvar[m c = 1;
  p.data.[00;38;05;75mcopy[m(ret);
  n -= p.data.length;
  [00;38;05;171mwhile[m (p = p.next) {
    [00;38;05;171mvar[m buf = p.data;
    [00;38;05;171mvar[m nb = n > buf.length ? buf.length : n;
    buf.[00;38;05;75mcopy[m(ret, ret.length - n, 0, nb);
    n -= nb;
    [00;38;05;171mif[m (n === 0) {
      [00;38;05;171mif[m (nb === buf.length) {
        ++c;
        [00;38;05;171mif[m (p.next) list.head = p.next;[00;38;05;171melse[m list.head = list.tail = [00;38;05;171mnull[m;
      } [00;38;05;171melse[m {
        list.head = p;
        p.data = buf.[00;38;05;75mslice[m(nb);
      }
      [00;38;05;171mbreak[m;
    }
    ++c;
  }
  list.length -= c;
  [00;38;05;171mreturn[m ret;
}

[00;38;05;171mfunction[m [00;38;05;75mendReadable[m(stream) {
  [00;38;05;171mvar[m state = stream._readableState;

  [00;38;05;242m// If we get here before consuming all the bytes, then that is a[m
  [00;38;05;242m// bug in node.  Should never happen.[m
  [00;38;05;171mif[m (state.length > 0) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'"endReadable()" called on non-empty stream'[m);

  [00;38;05;171mif[m (!state.endEmitted) {
    state.ended = [00;38;05;171mtrue[m;
    [00;38;05;75mprocessNextTick[m(endReadableNT, state, stream);
  }
}

[00;38;05;171mfunction[m [00;38;05;75mendReadableNT[m(state, stream) {
  [00;38;05;242m// Check that we didn't get one last unshift.[m
  [00;38;05;171mif[m (!state.endEmitted && state.length === 0) {
    state.endEmitted = [00;38;05;171mtrue[m;
    stream.readable = [00;38;05;171mfalse[m;
    stream.[00;38;05;75memit[m([00;38;05;196m'end'[m);
  }
}

[00;38;05;171mfunction[m [00;38;05;75mforEach[m(xs, f) {
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0, l = xs.length; i < l; i++) {
    [00;38;05;75mf[m(xs[i], i);
  }
}

[00;38;05;171mfunction[m [00;38;05;75mindexOf[m(xs, x) {
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0, l = xs.length; i < l; i++) {
    [00;38;05;171mif[m (xs[i] === x) [00;38;05;171mreturn[m i;
  }
  [00;38;05;171mreturn[m -1;
}
[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(2)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 11 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;
[00;38;05;242m// a transform stream is a readable/writable stream where you do[m
[00;38;05;242m// something with the data.  Sometimes it's called a "filter",[m
[00;38;05;242m// but that's not a great name for it, since that implies a thing where[m
[00;38;05;242m// some bits pass through, and others are simply ignored.  (That would[m
[00;38;05;242m// be a valid example of a transform, of course.)[m
[00;38;05;242m//[m
[00;38;05;242m// While the output is causally related to the input, it's not a[m
[00;38;05;242m// necessarily symmetric or synchronous transformation.  For example,[m
[00;38;05;242m// a zlib stream might take multiple plain-text writes(), and then[m
[00;38;05;242m// emit a single compressed chunk some time in the future.[m
[00;38;05;242m//[m
[00;38;05;242m// Here's how this works:[m
[00;38;05;242m//[m
[00;38;05;242m// The Transform stream has all the aspects of the readable and writable[m
[00;38;05;242m// stream classes.  When you write(chunk), that calls _write(chunk,cb)[m
[00;38;05;242m// internally, and returns false if there's a lot of pending writes[m
[00;38;05;242m// buffered up.  When you call read(), that calls _read(n) until[m
[00;38;05;242m// there's enough pending readable data buffered up.[m
[00;38;05;242m//[m
[00;38;05;242m// In a transform stream, the written data is placed in a buffer.  When[m
[00;38;05;242m// _read(n) is called, it transforms the queued up data, calling the[m
[00;38;05;242m// buffered _write cb's as it consumes chunks.  If consuming a single[m
[00;38;05;242m// written chunk would result in multiple output chunks, then the first[m
[00;38;05;242m// outputted bit calls the readcb, and subsequent chunks just go into[m
[00;38;05;242m// the read buffer, and will cause it to emit 'readable' if necessary.[m
[00;38;05;242m//[m
[00;38;05;242m// This way, back-pressure is actually determined by the reading side,[m
[00;38;05;242m// since _read has to be called to start processing a new chunk.  However,[m
[00;38;05;242m// a pathological inflate type of transform can cause excessive buffering[m
[00;38;05;242m// here.  For example, imagine a stream where every byte of input is[m
[00;38;05;242m// interpreted as an integer from 0-255, and then results in that many[m
[00;38;05;242m// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in[m
[00;38;05;242m// 1kb of data being output.  In this case, you could write a very small[m
[00;38;05;242m// amount of input, and end up with a very large amount of output.  In[m
[00;38;05;242m// such a pathological inflating mechanism, there'd be no way to tell[m
[00;38;05;242m// the system to stop doing the transform.  A single 4MB write could[m
[00;38;05;242m// cause the system to run out of memory.[m
[00;38;05;242m//[m
[00;38;05;242m// However, even in such a pathological case, only a single written chunk[m
[00;38;05;242m// would be consumed, and then the rest would wait (un-transformed) until[m
[00;38;05;242m// the results of the previous transformed chunk were consumed.[m



module.exports = Transform;

[00;38;05;171mvar[m Duplex = [00;38;05;75m__webpack_require__[m(4);

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m util = [00;38;05;75m__webpack_require__[m(5);
util.inherits = [00;38;05;75m__webpack_require__[m(3);
[00;38;05;242m/*</replacement>*/[m

util.[00;38;05;75minherits[m(Transform, Duplex);

[00;38;05;171mfunction[m [00;38;05;75mTransformState[m(stream) {
  [00;38;05;171mthis[m.afterTransform = [00;38;05;171mfunction[m (er, data) {
    [00;38;05;171mreturn[m [00;38;05;75mafterTransform[m(stream, er, data);
  };

  [00;38;05;171mthis[m.needTransform = [00;38;05;171mfalse[m;
  [00;38;05;171mthis[m.transforming = [00;38;05;171mfalse[m;
  [00;38;05;171mthis[m.writecb = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.writechunk = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.writeencoding = [00;38;05;171mnull[m;
}

[00;38;05;171mfunction[m [00;38;05;75mafterTransform[m(stream, er, data) {
  [00;38;05;171mvar[m ts = stream._transformState;
  ts.transforming = [00;38;05;171mfalse[m;

  [00;38;05;171mvar[m cb = ts.writecb;

  [00;38;05;171mif[m (!cb) [00;38;05;171mreturn[m stream.[00;38;05;75memit[m([00;38;05;196m'error'[m, [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'no writecb in Transform class'[m));

  ts.writechunk = [00;38;05;171mnull[m;
  ts.writecb = [00;38;05;171mnull[m;

  [00;38;05;171mif[m (data !== [00;38;05;171mnull[m && data !== undefined) stream.[00;38;05;75mpush[m(data);

  [00;38;05;75mcb[m(er);

  [00;38;05;171mvar[m rs = stream._readableState;
  rs.reading = [00;38;05;171mfalse[m;
  [00;38;05;171mif[m (rs.needReadable || rs.length < rs.highWaterMark) {
    stream.[00;38;05;75m_read[m(rs.highWaterMark);
  }
}

[00;38;05;171mfunction[m [00;38;05;75mTransform[m(options) {
  [00;38;05;171mif[m (!([00;38;05;171mthis[m [00;38;05;171minstanceof[m Transform)) [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mTransform[m(options);

  Duplex.[00;38;05;75mcall[m([00;38;05;171mthis[m, options);

  [00;38;05;171mthis[m._transformState = [00;38;05;171mnew[m [00;38;05;75mTransformState[m([00;38;05;171mthis[m);

  [00;38;05;171mvar[m stream = [00;38;05;171mthis[m;

  [00;38;05;242m// start out asking for a readable event once data is transformed.[m
  [00;38;05;171mthis[m._readableState.needReadable = [00;38;05;171mtrue[m;

  [00;38;05;242m// we have implemented the _read method, and done the other things[m
  [00;38;05;242m// that Readable wants before the first _read call, so unset the[m
  [00;38;05;242m// sync guard flag.[m
  [00;38;05;171mthis[m._readableState.sync = [00;38;05;171mfalse[m;

  [00;38;05;171mif[m (options) {
    [00;38;05;171mif[m ([00;38;05;171mtypeof[m options.transform === [00;38;05;196m'function'[m) [00;38;05;171mthis[m._transform = options.transform;

    [00;38;05;171mif[m ([00;38;05;171mtypeof[m options.flush === [00;38;05;196m'function'[m) [00;38;05;171mthis[m._flush = options.flush;
  }

  [00;38;05;242m// When the writable side finishes, then flush out anything remaining.[m
  [00;38;05;171mthis[m.[00;38;05;75monce[m([00;38;05;196m'prefinish'[m, [00;38;05;171mfunction[m () {
    [00;38;05;171mif[m ([00;38;05;171mtypeof[m [00;38;05;171mthis[m._flush === [00;38;05;196m'function'[m) [00;38;05;171mthis[m.[00;38;05;75m_flush[m([00;38;05;171mfunction[m (er, data) {
      [00;38;05;75mdone[m(stream, er, data);
    });[00;38;05;171melse[m [00;38;05;75mdone[m(stream);
  });
}

Transform.[00;38;05;171mprototype[m.push = [00;38;05;171mfunction[m (chunk, encoding) {
  [00;38;05;171mthis[m._transformState.needTransform = [00;38;05;171mfalse[m;
  [00;38;05;171mreturn[m Duplex.[00;38;05;171mprototype[m.push.[00;38;05;75mcall[m([00;38;05;171mthis[m, chunk, encoding);
};

[00;38;05;242m// This is the part where you do stuff![m
[00;38;05;242m// override this function in implementation classes.[m
[00;38;05;242m// 'chunk' is an input chunk.[m
[00;38;05;242m//[m
[00;38;05;242m// Call `push(newChunk)` to pass along transformed output[m
[00;38;05;242m// to the readable side.  You may call 'push' zero or more times.[m
[00;38;05;242m//[m
[00;38;05;242m// Call `cb(err)` when you are done with this chunk.  If you pass[m
[00;38;05;242m// an error, then that'll put the hurt on the whole operation.  If you[m
[00;38;05;242m// never call cb(), then you'll never get another chunk.[m
Transform.[00;38;05;171mprototype[m._transform = [00;38;05;171mfunction[m (chunk, encoding, cb) {
  [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'_transform() is not implemented'[m);
};

Transform.[00;38;05;171mprototype[m._write = [00;38;05;171mfunction[m (chunk, encoding, cb) {
  [00;38;05;171mvar[m ts = [00;38;05;171mthis[m._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  [00;38;05;171mif[m (!ts.transforming) {
    [00;38;05;171mvar[m rs = [00;38;05;171mthis[m._readableState;
    [00;38;05;171mif[m (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) [00;38;05;171mthis[m.[00;38;05;75m_read[m(rs.highWaterMark);
  }
};

[00;38;05;242m// Doesn't matter what the args are here.[m
[00;38;05;242m// _transform does all the work.[m
[00;38;05;242m// That we got here means that the readable side wants more data.[m
Transform.[00;38;05;171mprototype[m._read = [00;38;05;171mfunction[m (n) {
  [00;38;05;171mvar[m ts = [00;38;05;171mthis[m._transformState;

  [00;38;05;171mif[m (ts.writechunk !== [00;38;05;171mnull[m && ts.writecb && !ts.transforming) {
    ts.transforming = [00;38;05;171mtrue[m;
    [00;38;05;171mthis[m.[00;38;05;75m_transform[m(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } [00;38;05;171melse[m {
    [00;38;05;242m// mark that we need a transform, so that any data that comes in[m
    [00;38;05;242m// will get processed, now that we've asked for it.[m
    ts.needTransform = [00;38;05;171mtrue[m;
  }
};

[00;38;05;171mfunction[m [00;38;05;75mdone[m(stream, er, data) {
  [00;38;05;171mif[m (er) [00;38;05;171mreturn[m stream.[00;38;05;75memit[m([00;38;05;196m'error'[m, er);

  [00;38;05;171mif[m (data !== [00;38;05;171mnull[m && data !== undefined) stream.[00;38;05;75mpush[m(data);

  [00;38;05;242m// if there's nothing in the write buffer, then that means[m
  [00;38;05;242m// that nothing more will ever be provided[m
  [00;38;05;171mvar[m ws = stream._writableState;
  [00;38;05;171mvar[m ts = stream._transformState;

  [00;38;05;171mif[m (ws.length) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'Calling transform done when ws.length != 0'[m);

  [00;38;05;171mif[m (ts.transforming) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'Calling transform done when still transforming'[m);

  [00;38;05;171mreturn[m stream.[00;38;05;75mpush[m([00;38;05;171mnull[m);
}

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 12 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;
[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(process, setImmediate) {[00;38;05;242m// A bit simpler than readable streams.[m
[00;38;05;242m// Implement an async ._write(chunk, encoding, cb), and it'll handle all[m
[00;38;05;242m// the drain event emission and buffering.[m



module.exports = Writable;

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m processNextTick = [00;38;05;75m__webpack_require__[m(8);
[00;38;05;242m/*</replacement>*/[m

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m asyncWrite = !process.browser && [[00;38;05;196m'v0.10'[m, [00;38;05;196m'v0.9.'[m].[00;38;05;75mindexOf[m(process.version.[00;38;05;75mslice[m(0, 5)) > -1 ? setImmediate : processNextTick;
[00;38;05;242m/*</replacement>*/[m

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m Duplex;
[00;38;05;242m/*</replacement>*/[m

Writable.WritableState = WritableState;

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m util = [00;38;05;75m__webpack_require__[m(5);
util.inherits = [00;38;05;75m__webpack_require__[m(3);
[00;38;05;242m/*</replacement>*/[m

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m internalUtil = {
  deprecate: [00;38;05;75m__webpack_require__[m(42)
};
[00;38;05;242m/*</replacement>*/[m

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m Stream = [00;38;05;75m__webpack_require__[m(13);
[00;38;05;242m/*</replacement>*/[m

[00;38;05;171mvar[m Buffer = [00;38;05;75m__webpack_require__[m(1).Buffer;
[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m bufferShim = [00;38;05;75m__webpack_require__[m(6);
[00;38;05;242m/*</replacement>*/[m

util.[00;38;05;75minherits[m(Writable, Stream);

[00;38;05;171mfunction[m [00;38;05;75mnop[m() {}

[00;38;05;171mfunction[m [00;38;05;75mWriteReq[m(chunk, encoding, cb) {
  [00;38;05;171mthis[m.chunk = chunk;
  [00;38;05;171mthis[m.encoding = encoding;
  [00;38;05;171mthis[m.callback = cb;
  [00;38;05;171mthis[m.next = [00;38;05;171mnull[m;
}

[00;38;05;171mfunction[m [00;38;05;75mWritableState[m(options, stream) {
  Duplex = Duplex || [00;38;05;75m__webpack_require__[m(4);

  options = options || {};

  [00;38;05;242m// object stream flag to indicate whether or not this stream[m
  [00;38;05;242m// contains buffers or objects.[m
  [00;38;05;171mthis[m.objectMode = !!options.objectMode;

  [00;38;05;171mif[m (stream [00;38;05;171minstanceof[m Duplex) [00;38;05;171mthis[m.objectMode = [00;38;05;171mthis[m.objectMode || !!options.writableObjectMode;

  [00;38;05;242m// the point at which write() starts returning false[m
  [00;38;05;242m// Note: 0 is a valid value, means that we always return false if[m
  [00;38;05;242m// the entire buffer is not flushed immediately on write()[m
  [00;38;05;171mvar[m hwm = options.highWaterMark;
  [00;38;05;171mvar[m defaultHwm = [00;38;05;171mthis[m.objectMode ? 16 : 16 * 1024;
  [00;38;05;171mthis[m.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  [00;38;05;242m// cast to ints.[m
  [00;38;05;171mthis[m.highWaterMark = ~~[00;38;05;171mthis[m.highWaterMark;

  [00;38;05;242m// drain event flag.[m
  [00;38;05;171mthis[m.needDrain = [00;38;05;171mfalse[m;
  [00;38;05;242m// at the start of calling end()[m
  [00;38;05;171mthis[m.ending = [00;38;05;171mfalse[m;
  [00;38;05;242m// when end() has been called, and returned[m
  [00;38;05;171mthis[m.ended = [00;38;05;171mfalse[m;
  [00;38;05;242m// when 'finish' is emitted[m
  [00;38;05;171mthis[m.finished = [00;38;05;171mfalse[m;

  [00;38;05;242m// should we decode strings into buffers before passing to _write?[m
  [00;38;05;242m// this is here so that some node-core streams can optimize string[m
  [00;38;05;242m// handling at a lower level.[m
  [00;38;05;171mvar[m noDecode = options.decodeStrings === [00;38;05;171mfalse[m;
  [00;38;05;171mthis[m.decodeStrings = !noDecode;

  [00;38;05;242m// Crypto is kind of old and crusty.  Historically, its default string[m
  [00;38;05;242m// encoding is 'binary' so we have to make this configurable.[m
  [00;38;05;242m// Everything else in the universe uses 'utf8', though.[m
  [00;38;05;171mthis[m.defaultEncoding = options.defaultEncoding || [00;38;05;196m'utf8'[m;

  [00;38;05;242m// not an actual buffer we keep track of, but a measurement[m
  [00;38;05;242m// of how much we're waiting to get pushed to some underlying[m
  [00;38;05;242m// socket or file.[m
  [00;38;05;171mthis[m.length = 0;

  [00;38;05;242m// a flag to see when we're in the middle of a write.[m
  [00;38;05;171mthis[m.writing = [00;38;05;171mfalse[m;

  [00;38;05;242m// when true all writes will be buffered until .uncork() call[m
  [00;38;05;171mthis[m.corked = 0;

  [00;38;05;242m// a flag to be able to tell if the onwrite cb is called immediately,[m
  [00;38;05;242m// or on a later tick.  We set this to true at first, because any[m
  [00;38;05;242m// actions that shouldn't happen until "later" should generally also[m
  [00;38;05;242m// not happen before the first write call.[m
  [00;38;05;171mthis[m.sync = [00;38;05;171mtrue[m;

  [00;38;05;242m// a flag to know if we're processing previously buffered items, which[m
  [00;38;05;242m// may call the _write() callback in the same tick, so that we don't[m
  [00;38;05;242m// end up in an overlapped onwrite situation.[m
  [00;38;05;171mthis[m.bufferProcessing = [00;38;05;171mfalse[m;

  [00;38;05;242m// the callback that's passed to _write(chunk,cb)[m
  [00;38;05;171mthis[m.onwrite = [00;38;05;171mfunction[m (er) {
    [00;38;05;75monwrite[m(stream, er);
  };

  [00;38;05;242m// the callback that the user supplies to write(chunk,encoding,cb)[m
  [00;38;05;171mthis[m.writecb = [00;38;05;171mnull[m;

  [00;38;05;242m// the amount that is being written when _write is called.[m
  [00;38;05;171mthis[m.writelen = 0;

  [00;38;05;171mthis[m.bufferedRequest = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.lastBufferedRequest = [00;38;05;171mnull[m;

  [00;38;05;242m// number of pending user-supplied write callbacks[m
  [00;38;05;242m// this must be 0 before 'finish' can be emitted[m
  [00;38;05;171mthis[m.pendingcb = 0;

  [00;38;05;242m// emit prefinish if the only thing we're waiting for is _write cbs[m
  [00;38;05;242m// This is relevant for synchronous Transform streams[m
  [00;38;05;171mthis[m.prefinished = [00;38;05;171mfalse[m;

  [00;38;05;242m// True if the error was already emitted and should not be thrown again[m
  [00;38;05;171mthis[m.errorEmitted = [00;38;05;171mfalse[m;

  [00;38;05;242m// count buffered requests[m
  [00;38;05;171mthis[m.bufferedRequestCount = 0;

  [00;38;05;242m// allocate the first CorkedRequest, there is always[m
  [00;38;05;242m// one allocated and free to use, and we maintain at most two[m
  [00;38;05;171mthis[m.corkedRequestsFree = [00;38;05;171mnew[m [00;38;05;75mCorkedRequest[m([00;38;05;171mthis[m);
}

WritableState.[00;38;05;171mprototype[m.getBuffer = [00;38;05;171mfunction[m [00;38;05;75mgetBuffer[m() {
  [00;38;05;171mvar[m current = [00;38;05;171mthis[m.bufferedRequest;
  [00;38;05;171mvar[m out = [];
  [00;38;05;171mwhile[m (current) {
    out.[00;38;05;75mpush[m(current);
    current = current.next;
  }
  [00;38;05;171mreturn[m out;
};

([00;38;05;171mfunction[m () {
  [00;38;05;171mtry[m {
    Object.[00;38;05;75mdefineProperty[m(WritableState.[00;38;05;171mprototype[m, [00;38;05;196m'buffer'[m, {
      get: internalUtil.[00;38;05;75mdeprecate[m([00;38;05;171mfunction[m () {
        [00;38;05;171mreturn[m [00;38;05;171mthis[m.[00;38;05;75mgetBuffer[m();
      }, [00;38;05;196m'_writableState.buffer is deprecated. Use _writableState.getBuffer '[m + [00;38;05;196m'instead.'[m)
    });
  } [00;38;05;171mcatch[m (_) {}
})();

[00;38;05;242m// Test _writableState for inheritance to account for Duplex streams,[m
[00;38;05;242m// whose prototype chain only points to Readable.[m
[00;38;05;171mvar[m realHasInstance;
[00;38;05;171mif[m ([00;38;05;171mtypeof[m Symbol === [00;38;05;196m'function'[m && Symbol.hasInstance && [00;38;05;171mtypeof[m Function.[00;38;05;171mprototype[m[Symbol.hasInstance] === [00;38;05;196m'function'[m) {
  realHasInstance = Function.[00;38;05;171mprototype[m[Symbol.hasInstance];
  Object.[00;38;05;75mdefineProperty[m(Writable, Symbol.hasInstance, {
    value: [00;38;05;171mfunction[m (object) {
      [00;38;05;171mif[m (realHasInstance.[00;38;05;75mcall[m([00;38;05;171mthis[m, object)) [00;38;05;171mreturn[m [00;38;05;171mtrue[m;

      [00;38;05;171mreturn[m object && object._writableState [00;38;05;171minstanceof[m WritableState;
    }
  });
} [00;38;05;171melse[m {
  realHasInstance = [00;38;05;171mfunction[m (object) {
    [00;38;05;171mreturn[m object [00;38;05;171minstanceof[m [00;38;05;171mthis[m;
  };
}

[00;38;05;171mfunction[m [00;38;05;75mWritable[m(options) {
  Duplex = Duplex || [00;38;05;75m__webpack_require__[m(4);

  [00;38;05;242m// Writable ctor is applied to Duplexes, too.[m
  [00;38;05;242m// `realHasInstance` is necessary because using plain `instanceof`[m
  [00;38;05;242m// would return false, as no `_writableState` property is attached.[m

  [00;38;05;242m// Trying to use the custom `instanceof` for Writable here will also break the[m
  [00;38;05;242m// Node.js LazyTransform implementation, which has a non-trivial getter for[m
  [00;38;05;242m// `_writableState` that would lead to infinite recursion.[m
  [00;38;05;171mif[m (!realHasInstance.[00;38;05;75mcall[m(Writable, [00;38;05;171mthis[m) && !([00;38;05;171mthis[m [00;38;05;171minstanceof[m Duplex)) {
    [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mWritable[m(options);
  }

  [00;38;05;171mthis[m._writableState = [00;38;05;171mnew[m [00;38;05;75mWritableState[m(options, [00;38;05;171mthis[m);

  [00;38;05;242m// legacy.[m
  [00;38;05;171mthis[m.writable = [00;38;05;171mtrue[m;

  [00;38;05;171mif[m (options) {
    [00;38;05;171mif[m ([00;38;05;171mtypeof[m options.write === [00;38;05;196m'function'[m) [00;38;05;171mthis[m._write = options.write;

    [00;38;05;171mif[m ([00;38;05;171mtypeof[m options.writev === [00;38;05;196m'function'[m) [00;38;05;171mthis[m._writev = options.writev;
  }

  Stream.[00;38;05;75mcall[m([00;38;05;171mthis[m);
}

[00;38;05;242m// Otherwise people can pipe Writable streams, which is just wrong.[m
Writable.[00;38;05;171mprototype[m.pipe = [00;38;05;171mfunction[m () {
  [00;38;05;171mthis[m.[00;38;05;75memit[m([00;38;05;196m'error'[m, [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'Cannot pipe, not readable'[m));
};

[00;38;05;171mfunction[m [00;38;05;75mwriteAfterEnd[m(stream, cb) {
  [00;38;05;171mvar[m er = [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'write after end'[m);
  [00;38;05;242m// TODO: defer error events consistently everywhere, not just the cb[m
  stream.[00;38;05;75memit[m([00;38;05;196m'error'[m, er);
  [00;38;05;75mprocessNextTick[m(cb, er);
}

[00;38;05;242m// Checks that a user-supplied chunk is valid, especially for the particular[m
[00;38;05;242m// mode the stream is in. Currently this means that `null` is never accepted[m
[00;38;05;242m// and undefined/non-string values are only allowed in object mode.[m
[00;38;05;171mfunction[m [00;38;05;75mvalidChunk[m(stream, state, chunk, cb) {
  [00;38;05;171mvar[m valid = [00;38;05;171mtrue[m;
  [00;38;05;171mvar[m er = [00;38;05;171mfalse[m;

  [00;38;05;171mif[m (chunk === [00;38;05;171mnull[m) {
    er = [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'May not write null values to stream'[m);
  } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;171mtypeof[m chunk !== [00;38;05;196m'string'[m && chunk !== undefined && !state.objectMode) {
    er = [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'Invalid non-string/buffer chunk'[m);
  }
  [00;38;05;171mif[m (er) {
    stream.[00;38;05;75memit[m([00;38;05;196m'error'[m, er);
    [00;38;05;75mprocessNextTick[m(cb, er);
    valid = [00;38;05;171mfalse[m;
  }
  [00;38;05;171mreturn[m valid;
}

Writable.[00;38;05;171mprototype[m.write = [00;38;05;171mfunction[m (chunk, encoding, cb) {
  [00;38;05;171mvar[m state = [00;38;05;171mthis[m._writableState;
  [00;38;05;171mvar[m ret = [00;38;05;171mfalse[m;
  [00;38;05;171mvar[m isBuf = Buffer.[00;38;05;75misBuffer[m(chunk);

  [00;38;05;171mif[m ([00;38;05;171mtypeof[m encoding === [00;38;05;196m'function'[m) {
    cb = encoding;
    encoding = [00;38;05;171mnull[m;
  }

  [00;38;05;171mif[m (isBuf) encoding = [00;38;05;196m'buffer'[m;[00;38;05;171melse[m [00;38;05;171mif[m (!encoding) encoding = state.defaultEncoding;

  [00;38;05;171mif[m ([00;38;05;171mtypeof[m cb !== [00;38;05;196m'function'[m) cb = nop;

  [00;38;05;171mif[m (state.ended) [00;38;05;75mwriteAfterEnd[m([00;38;05;171mthis[m, cb);[00;38;05;171melse[m [00;38;05;171mif[m (isBuf || [00;38;05;75mvalidChunk[m([00;38;05;171mthis[m, state, chunk, cb)) {
    state.pendingcb++;
    ret = [00;38;05;75mwriteOrBuffer[m([00;38;05;171mthis[m, state, isBuf, chunk, encoding, cb);
  }

  [00;38;05;171mreturn[m ret;
};

Writable.[00;38;05;171mprototype[m.cork = [00;38;05;171mfunction[m () {
  [00;38;05;171mvar[m state = [00;38;05;171mthis[m._writableState;

  state.corked++;
};

Writable.[00;38;05;171mprototype[m.uncork = [00;38;05;171mfunction[m () {
  [00;38;05;171mvar[m state = [00;38;05;171mthis[m._writableState;

  [00;38;05;171mif[m (state.corked) {
    state.corked--;

    [00;38;05;171mif[m (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) [00;38;05;75mclearBuffer[m([00;38;05;171mthis[m, state);
  }
};

Writable.[00;38;05;171mprototype[m.setDefaultEncoding = [00;38;05;171mfunction[m [00;38;05;75msetDefaultEncoding[m(encoding) {
  [00;38;05;242m// node::ParseEncoding() requires lower case.[m
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m encoding === [00;38;05;196m'string'[m) encoding = encoding.[00;38;05;75mtoLowerCase[m();
  [00;38;05;171mif[m (!([[00;38;05;196m'hex'[m, [00;38;05;196m'utf8'[m, [00;38;05;196m'utf-8'[m, [00;38;05;196m'ascii'[m, [00;38;05;196m'binary'[m, [00;38;05;196m'base64'[m, [00;38;05;196m'ucs2'[m, [00;38;05;196m'ucs-2'[m, [00;38;05;196m'utf16le'[m, [00;38;05;196m'utf-16le'[m, [00;38;05;196m'raw'[m].[00;38;05;75mindexOf[m((encoding + [00;38;05;196m''[m).[00;38;05;75mtoLowerCase[m()) > -1)) [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m'Unknown encoding: '[m + encoding);
  [00;38;05;171mthis[m._writableState.defaultEncoding = encoding;
  [00;38;05;171mreturn[m [00;38;05;171mthis[m;
};

[00;38;05;171mfunction[m [00;38;05;75mdecodeChunk[m(state, chunk, encoding) {
  [00;38;05;171mif[m (!state.objectMode && state.decodeStrings !== [00;38;05;171mfalse[m && [00;38;05;171mtypeof[m chunk === [00;38;05;196m'string'[m) {
    chunk = bufferShim.[00;38;05;75mfrom[m(chunk, encoding);
  }
  [00;38;05;171mreturn[m chunk;
}

[00;38;05;242m// if we're already writing something, then just put this[m
[00;38;05;242m// in the queue, and wait our turn.  Otherwise, call _write[m
[00;38;05;242m// If we return false, then we need a drain event, so set that flag.[m
[00;38;05;171mfunction[m [00;38;05;75mwriteOrBuffer[m(stream, state, isBuf, chunk, encoding, cb) {
  [00;38;05;171mif[m (!isBuf) {
    chunk = [00;38;05;75mdecodeChunk[m(state, chunk, encoding);
    [00;38;05;171mif[m (Buffer.[00;38;05;75misBuffer[m(chunk)) encoding = [00;38;05;196m'buffer'[m;
  }
  [00;38;05;171mvar[m len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  [00;38;05;171mvar[m ret = state.length < state.highWaterMark;
  [00;38;05;242m// we must ensure that previous needDrain will not be reset to false.[m
  [00;38;05;171mif[m (!ret) state.needDrain = [00;38;05;171mtrue[m;

  [00;38;05;171mif[m (state.writing || state.corked) {
    [00;38;05;171mvar[m last = state.lastBufferedRequest;
    state.lastBufferedRequest = [00;38;05;171mnew[m [00;38;05;75mWriteReq[m(chunk, encoding, cb);
    [00;38;05;171mif[m (last) {
      last.next = state.lastBufferedRequest;
    } [00;38;05;171melse[m {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } [00;38;05;171melse[m {
    [00;38;05;75mdoWrite[m(stream, state, [00;38;05;171mfalse[m, len, chunk, encoding, cb);
  }

  [00;38;05;171mreturn[m ret;
}

[00;38;05;171mfunction[m [00;38;05;75mdoWrite[m(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = [00;38;05;171mtrue[m;
  state.sync = [00;38;05;171mtrue[m;
  [00;38;05;171mif[m (writev) stream.[00;38;05;75m_writev[m(chunk, state.onwrite);[00;38;05;171melse[m stream.[00;38;05;75m_write[m(chunk, encoding, state.onwrite);
  state.sync = [00;38;05;171mfalse[m;
}

[00;38;05;171mfunction[m [00;38;05;75monwriteError[m(stream, state, sync, er, cb) {
  --state.pendingcb;
  [00;38;05;171mif[m (sync) [00;38;05;75mprocessNextTick[m(cb, er);[00;38;05;171melse[m [00;38;05;75mcb[m(er);

  stream._writableState.errorEmitted = [00;38;05;171mtrue[m;
  stream.[00;38;05;75memit[m([00;38;05;196m'error'[m, er);
}

[00;38;05;171mfunction[m [00;38;05;75monwriteStateUpdate[m(state) {
  state.writing = [00;38;05;171mfalse[m;
  state.writecb = [00;38;05;171mnull[m;
  state.length -= state.writelen;
  state.writelen = 0;
}

[00;38;05;171mfunction[m [00;38;05;75monwrite[m(stream, er) {
  [00;38;05;171mvar[m state = stream._writableState;
  [00;38;05;171mvar[m sync = state.sync;
  [00;38;05;171mvar[m cb = state.writecb;

  [00;38;05;75monwriteStateUpdate[m(state);

  [00;38;05;171mif[m (er) [00;38;05;75monwriteError[m(stream, state, sync, er, cb);[00;38;05;171melse[m {
    [00;38;05;242m// Check if we're actually ready to finish, but don't emit yet[m
    [00;38;05;171mvar[m finished = [00;38;05;75mneedFinish[m(state);

    [00;38;05;171mif[m (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      [00;38;05;75mclearBuffer[m(stream, state);
    }

    [00;38;05;171mif[m (sync) {
      [00;38;05;242m/*<replacement>*/[m
      [00;38;05;75masyncWrite[m(afterWrite, stream, state, finished, cb);
      [00;38;05;242m/*</replacement>*/[m
    } [00;38;05;171melse[m {
      [00;38;05;75mafterWrite[m(stream, state, finished, cb);
    }
  }
}

[00;38;05;171mfunction[m [00;38;05;75mafterWrite[m(stream, state, finished, cb) {
  [00;38;05;171mif[m (!finished) [00;38;05;75monwriteDrain[m(stream, state);
  state.pendingcb--;
  [00;38;05;75mcb[m();
  [00;38;05;75mfinishMaybe[m(stream, state);
}

[00;38;05;242m// Must force callback to be called on nextTick, so that we don't[m
[00;38;05;242m// emit 'drain' before the write() consumer gets the 'false' return[m
[00;38;05;242m// value, and has a chance to attach a 'drain' listener.[m
[00;38;05;171mfunction[m [00;38;05;75monwriteDrain[m(stream, state) {
  [00;38;05;171mif[m (state.length === 0 && state.needDrain) {
    state.needDrain = [00;38;05;171mfalse[m;
    stream.[00;38;05;75memit[m([00;38;05;196m'drain'[m);
  }
}

[00;38;05;242m// if there's something in the buffer waiting, then process it[m
[00;38;05;171mfunction[m [00;38;05;75mclearBuffer[m(stream, state) {
  state.bufferProcessing = [00;38;05;171mtrue[m;
  [00;38;05;171mvar[m entry = state.bufferedRequest;

  [00;38;05;171mif[m (stream._writev && entry && entry.next) {
    [00;38;05;242m// Fast case, write everything using _writev()[m
    [00;38;05;171mvar[m l = state.bufferedRequestCount;
    [00;38;05;171mvar[m buffer = [00;38;05;171mnew[m [00;38;05;75mArray[m(l);
    [00;38;05;171mvar[m holder = state.corkedRequestsFree;
    holder.entry = entry;

    [00;38;05;171mvar[m count = 0;
    [00;38;05;171mwhile[m (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    [00;38;05;75mdoWrite[m(stream, state, [00;38;05;171mtrue[m, state.length, buffer, [00;38;05;196m''[m, holder.finish);

    [00;38;05;242m// doWrite is almost always async, defer these to save a bit of time[m
    [00;38;05;242m// as the hot path ends with doWrite[m
    state.pendingcb++;
    state.lastBufferedRequest = [00;38;05;171mnull[m;
    [00;38;05;171mif[m (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = [00;38;05;171mnull[m;
    } [00;38;05;171melse[m {
      state.corkedRequestsFree = [00;38;05;171mnew[m [00;38;05;75mCorkedRequest[m(state);
    }
  } [00;38;05;171melse[m {
    [00;38;05;242m// Slow case, write chunks one-by-one[m
    [00;38;05;171mwhile[m (entry) {
      [00;38;05;171mvar[m chunk = entry.chunk;
      [00;38;05;171mvar[m encoding = entry.encoding;
      [00;38;05;171mvar[m cb = entry.callback;
      [00;38;05;171mvar[m len = state.objectMode ? 1 : chunk.length;

      [00;38;05;75mdoWrite[m(stream, state, [00;38;05;171mfalse[m, len, chunk, encoding, cb);
      entry = entry.next;
      [00;38;05;242m// if we didn't call the onwrite immediately, then[m
      [00;38;05;242m// it means that we need to wait until it does.[m
      [00;38;05;242m// also, that means that the chunk and cb are currently[m
      [00;38;05;242m// being processed, so move the buffer counter past them.[m
      [00;38;05;171mif[m (state.writing) {
        [00;38;05;171mbreak[m;
      }
    }

    [00;38;05;171mif[m (entry === [00;38;05;171mnull[m) state.lastBufferedRequest = [00;38;05;171mnull[m;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = [00;38;05;171mfalse[m;
}

Writable.[00;38;05;171mprototype[m._write = [00;38;05;171mfunction[m (chunk, encoding, cb) {
  [00;38;05;75mcb[m([00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'_write() is not implemented'[m));
};

Writable.[00;38;05;171mprototype[m._writev = [00;38;05;171mnull[m;

Writable.[00;38;05;171mprototype[m.end = [00;38;05;171mfunction[m (chunk, encoding, cb) {
  [00;38;05;171mvar[m state = [00;38;05;171mthis[m._writableState;

  [00;38;05;171mif[m ([00;38;05;171mtypeof[m chunk === [00;38;05;196m'function'[m) {
    cb = chunk;
    chunk = [00;38;05;171mnull[m;
    encoding = [00;38;05;171mnull[m;
  } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;171mtypeof[m encoding === [00;38;05;196m'function'[m) {
    cb = encoding;
    encoding = [00;38;05;171mnull[m;
  }

  [00;38;05;171mif[m (chunk !== [00;38;05;171mnull[m && chunk !== undefined) [00;38;05;171mthis[m.[00;38;05;75mwrite[m(chunk, encoding);

  [00;38;05;242m// .end() fully uncorks[m
  [00;38;05;171mif[m (state.corked) {
    state.corked = 1;
    [00;38;05;171mthis[m.[00;38;05;75muncork[m();
  }

  [00;38;05;242m// ignore unnecessary end() calls.[m
  [00;38;05;171mif[m (!state.ending && !state.finished) [00;38;05;75mendWritable[m([00;38;05;171mthis[m, state, cb);
};

[00;38;05;171mfunction[m [00;38;05;75mneedFinish[m(state) {
  [00;38;05;171mreturn[m state.ending && state.length === 0 && state.bufferedRequest === [00;38;05;171mnull[m && !state.finished && !state.writing;
}

[00;38;05;171mfunction[m [00;38;05;75mprefinish[m(stream, state) {
  [00;38;05;171mif[m (!state.prefinished) {
    state.prefinished = [00;38;05;171mtrue[m;
    stream.[00;38;05;75memit[m([00;38;05;196m'prefinish'[m);
  }
}

[00;38;05;171mfunction[m [00;38;05;75mfinishMaybe[m(stream, state) {
  [00;38;05;171mvar[m need = [00;38;05;75mneedFinish[m(state);
  [00;38;05;171mif[m (need) {
    [00;38;05;171mif[m (state.pendingcb === 0) {
      [00;38;05;75mprefinish[m(stream, state);
      state.finished = [00;38;05;171mtrue[m;
      stream.[00;38;05;75memit[m([00;38;05;196m'finish'[m);
    } [00;38;05;171melse[m {
      [00;38;05;75mprefinish[m(stream, state);
    }
  }
  [00;38;05;171mreturn[m need;
}

[00;38;05;171mfunction[m [00;38;05;75mendWritable[m(stream, state, cb) {
  state.ending = [00;38;05;171mtrue[m;
  [00;38;05;75mfinishMaybe[m(stream, state);
  [00;38;05;171mif[m (cb) {
    [00;38;05;171mif[m (state.finished) [00;38;05;75mprocessNextTick[m(cb);[00;38;05;171melse[m stream.[00;38;05;75monce[m([00;38;05;196m'finish'[m, cb);
  }
  state.ended = [00;38;05;171mtrue[m;
  stream.writable = [00;38;05;171mfalse[m;
}

[00;38;05;242m// It seems a linked list but it is not[m
[00;38;05;242m// there will be only 2 of these for each stream[m
[00;38;05;171mfunction[m [00;38;05;75mCorkedRequest[m(state) {
  [00;38;05;171mvar[m _this = [00;38;05;171mthis[m;

  [00;38;05;171mthis[m.next = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.entry = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.finish = [00;38;05;171mfunction[m (err) {
    [00;38;05;171mvar[m entry = _this.entry;
    _this.entry = [00;38;05;171mnull[m;
    [00;38;05;171mwhile[m (entry) {
      [00;38;05;171mvar[m cb = entry.callback;
      state.pendingcb--;
      [00;38;05;75mcb[m(err);
      entry = entry.next;
    }
    [00;38;05;171mif[m (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } [00;38;05;171melse[m {
      state.corkedRequestsFree = _this;
    }
  };
}
[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(2), [00;38;05;75m__webpack_require__[m(38).setImmediate))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 13 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

module.exports = [00;38;05;75m__webpack_require__[m(7).EventEmitter;


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 14 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

exports = module.exports = [00;38;05;75m__webpack_require__[m(10);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = [00;38;05;75m__webpack_require__[m(12);
exports.Duplex = [00;38;05;75m__webpack_require__[m(4);
exports.Transform = [00;38;05;75m__webpack_require__[m(11);
exports.PassThrough = [00;38;05;75m__webpack_require__[m(32);


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 15 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(global) {[00;38;05;171mvar[m ClientRequest = [00;38;05;75m__webpack_require__[m(36)
[00;38;05;171mvar[m extend = [00;38;05;75m__webpack_require__[m(47)
[00;38;05;171mvar[m statusCodes = [00;38;05;75m__webpack_require__[m(23)
[00;38;05;171mvar[m url = [00;38;05;75m__webpack_require__[m(19)

[00;38;05;171mvar[m http = exports

http.request = [00;38;05;171mfunction[m (opts, cb) {
	[00;38;05;171mif[m ([00;38;05;171mtypeof[m opts === [00;38;05;196m'string'[m)
		opts = url.[00;38;05;75mparse[m(opts)
	[00;38;05;171melse[m
		opts = [00;38;05;75mextend[m(opts)

	[00;38;05;242m// Normally, the page is loaded from http or https, so not specifying a protocol[m
	[00;38;05;242m// will result in a (valid) protocol-relative url. However, this won't work if[m
	[00;38;05;242m// the protocol is something else, like 'file:'[m
	[00;38;05;171mvar[m defaultProtocol = global.location.protocol.[00;38;05;75msearch[m([00;38;05;208m/^https?:$/[m) === -1 ? [00;38;05;196m'http:'[m : [00;38;05;196m''[m

	[00;38;05;171mvar[m protocol = opts.protocol || defaultProtocol
	[00;38;05;171mvar[m host = opts.hostname || opts.host
	[00;38;05;171mvar[m port = opts.port
	[00;38;05;171mvar[m path = opts.path || [00;38;05;196m'/'[m

	[00;38;05;242m// Necessary for IPv6 addresses[m
	[00;38;05;171mif[m (host && host.[00;38;05;75mindexOf[m([00;38;05;196m':'[m) !== -1)
		host = [00;38;05;196m'['[m + host + [00;38;05;196m']'[m

	[00;38;05;242m// This may be a relative url. The browser should always be able to interpret it correctly.[m
	opts.url = (host ? (protocol + [00;38;05;196m'//'[m + host) : [00;38;05;196m''[m) + (port ? [00;38;05;196m':'[m + port : [00;38;05;196m''[m) + path
	opts.method = (opts.method || [00;38;05;196m'GET'[m).[00;38;05;75mtoUpperCase[m()
	opts.headers = opts.headers || {}

	[00;38;05;242m// Also valid opts.auth, opts.mode[m

	[00;38;05;171mvar[m req = [00;38;05;171mnew[m [00;38;05;75mClientRequest[m(opts)
	[00;38;05;171mif[m (cb)
		req.[00;38;05;75mon[m([00;38;05;196m'response'[m, cb)
	[00;38;05;171mreturn[m req
}

http.get = [00;38;05;171mfunction[m [00;38;05;75mget[m (opts, cb) {
	[00;38;05;171mvar[m req = http.[00;38;05;75mrequest[m(opts, cb)
	req.[00;38;05;75mend[m()
	[00;38;05;171mreturn[m req
}

http.Agent = [00;38;05;171mfunction[m () {}
http.Agent.defaultMaxSockets = 4

http.STATUS_CODES = statusCodes

http.METHODS = [
	[00;38;05;196m'CHECKOUT'[m,
	[00;38;05;196m'CONNECT'[m,
	[00;38;05;196m'COPY'[m,
	[00;38;05;196m'DELETE'[m,
	[00;38;05;196m'GET'[m,
	[00;38;05;196m'HEAD'[m,
	[00;38;05;196m'LOCK'[m,
	[00;38;05;196m'M-SEARCH'[m,
	[00;38;05;196m'MERGE'[m,
	[00;38;05;196m'MKACTIVITY'[m,
	[00;38;05;196m'MKCOL'[m,
	[00;38;05;196m'MOVE'[m,
	[00;38;05;196m'NOTIFY'[m,
	[00;38;05;196m'OPTIONS'[m,
	[00;38;05;196m'PATCH'[m,
	[00;38;05;196m'POST'[m,
	[00;38;05;196m'PROPFIND'[m,
	[00;38;05;196m'PROPPATCH'[m,
	[00;38;05;196m'PURGE'[m,
	[00;38;05;196m'PUT'[m,
	[00;38;05;196m'REPORT'[m,
	[00;38;05;196m'SEARCH'[m,
	[00;38;05;196m'SUBSCRIBE'[m,
	[00;38;05;196m'TRACE'[m,
	[00;38;05;196m'UNLOCK'[m,
	[00;38;05;196m'UNSUBSCRIBE'[m
]
[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(0)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 16 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(global) {exports.fetch = [00;38;05;75misFunction[m(global.fetch) && [00;38;05;75misFunction[m(global.ReadableStream)

exports.blobConstructor = [00;38;05;171mfalse[m
[00;38;05;171mtry[m {
	[00;38;05;171mnew[m [00;38;05;75mBlob[m([[00;38;05;171mnew[m [00;38;05;75mArrayBuffer[m(1)])
	exports.blobConstructor = [00;38;05;171mtrue[m
} [00;38;05;171mcatch[m (e) {}

[00;38;05;242m// The xhr request to example.com may violate some restrictive CSP configurations,[m
[00;38;05;242m// so if we're running in a browser that supports `fetch`, avoid calling getXHR()[m
[00;38;05;242m// and assume support for certain features below.[m
[00;38;05;171mvar[m xhr
[00;38;05;171mfunction[m [00;38;05;75mgetXHR[m () {
	[00;38;05;242m// Cache the xhr value[m
	[00;38;05;171mif[m (xhr !== undefined) [00;38;05;171mreturn[m xhr

	[00;38;05;171mif[m (global.XMLHttpRequest) {
		xhr = [00;38;05;171mnew[m global.[00;38;05;75mXMLHttpRequest[m()
		[00;38;05;242m// If XDomainRequest is available (ie only, where xhr might not work[m
		[00;38;05;242m// cross domain), use the page location. Otherwise use example.com[m
		[00;38;05;242m// Note: this doesn't actually make an http request.[m
		[00;38;05;171mtry[m {
			xhr.[00;38;05;75mopen[m([00;38;05;196m'GET'[m, global.XDomainRequest ? [00;38;05;196m'/'[m : [00;38;05;196m'https://example.com'[m)
		} [00;38;05;171mcatch[m(e) {
			xhr = [00;38;05;171mnull[m
		}
	} [00;38;05;171melse[m {
		[00;38;05;242m// Service workers don't have XHR[m
		xhr = [00;38;05;171mnull[m
	}
	[00;38;05;171mreturn[m xhr
}

[00;38;05;171mfunction[m [00;38;05;75mcheckTypeSupport[m (type) {
	[00;38;05;171mvar[m xhr = [00;38;05;75mgetXHR[m()
	[00;38;05;171mif[m (!xhr) [00;38;05;171mreturn[m [00;38;05;171mfalse[m
	[00;38;05;171mtry[m {
		xhr.responseType = type
		[00;38;05;171mreturn[m xhr.responseType === type
	} [00;38;05;171mcatch[m (e) {}
	[00;38;05;171mreturn[m [00;38;05;171mfalse[m
}

[00;38;05;242m// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.[m
[00;38;05;242m// Safari 7.1 appears to have fixed this bug.[m
[00;38;05;171mvar[m haveArrayBuffer = [00;38;05;171mtypeof[m global.ArrayBuffer !== [00;38;05;196m'undefined'[m
[00;38;05;171mvar[m haveSlice = haveArrayBuffer && [00;38;05;75misFunction[m(global.ArrayBuffer.[00;38;05;171mprototype[m.slice)

[00;38;05;242m// If fetch is supported, then arraybuffer will be supported too. Skip calling[m
[00;38;05;242m// checkTypeSupport(), since that calls getXHR().[m
exports.arraybuffer = exports.fetch || (haveArrayBuffer && [00;38;05;75mcheckTypeSupport[m([00;38;05;196m'arraybuffer'[m))

[00;38;05;242m// These next two tests unavoidably show warnings in Chrome. Since fetch will always[m
[00;38;05;242m// be used if it's available, just return false for these to avoid the warnings.[m
exports.msstream = !exports.fetch && haveSlice && [00;38;05;75mcheckTypeSupport[m([00;38;05;196m'ms-stream'[m)
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	[00;38;05;75mcheckTypeSupport[m([00;38;05;196m'moz-chunked-arraybuffer'[m)

[00;38;05;242m// If fetch is supported, then overrideMimeType will be supported too. Skip calling[m
[00;38;05;242m// getXHR().[m
exports.overrideMimeType = exports.fetch || ([00;38;05;75mgetXHR[m() ? [00;38;05;75misFunction[m([00;38;05;75mgetXHR[m().overrideMimeType) : [00;38;05;171mfalse[m)

exports.vbArray = [00;38;05;75misFunction[m(global.VBArray)

[00;38;05;171mfunction[m [00;38;05;75misFunction[m (value) {
	[00;38;05;171mreturn[m [00;38;05;171mtypeof[m value === [00;38;05;196m'function'[m
}

xhr = [00;38;05;171mnull[m [00;38;05;242m// Help gc[m

[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(0)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 17 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;242m// Copyright Joyent, Inc. and other Node contributors.[m
[00;38;05;242m//[m
[00;38;05;242m// Permission is hereby granted, free of charge, to any person obtaining a[m
[00;38;05;242m// copy of this software and associated documentation files (the[m
[00;38;05;242m// "Software"), to deal in the Software without restriction, including[m
[00;38;05;242m// without limitation the rights to use, copy, modify, merge, publish,[m
[00;38;05;242m// distribute, sublicense, and/or sell copies of the Software, and to permit[m
[00;38;05;242m// persons to whom the Software is furnished to do so, subject to the[m
[00;38;05;242m// following conditions:[m
[00;38;05;242m//[m
[00;38;05;242m// The above copyright notice and this permission notice shall be included[m
[00;38;05;242m// in all copies or substantial portions of the Software.[m
[00;38;05;242m//[m
[00;38;05;242m// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS[m
[00;38;05;242m// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF[m
[00;38;05;242m// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN[m
[00;38;05;242m// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,[m
[00;38;05;242m// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR[m
[00;38;05;242m// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE[m
[00;38;05;242m// USE OR OTHER DEALINGS IN THE SOFTWARE.[m

[00;38;05;171mvar[m Buffer = [00;38;05;75m__webpack_require__[m(1).Buffer;

[00;38;05;171mvar[m isBufferEncoding = Buffer.isEncoding
  || [00;38;05;171mfunction[m(encoding) {
       [00;38;05;171mswitch[m (encoding && encoding.[00;38;05;75mtoLowerCase[m()) {
         [00;38;05;171mcase[m [00;38;05;196m'hex'[m: [00;38;05;171mcase[m [00;38;05;196m'utf8'[m: [00;38;05;171mcase[m [00;38;05;196m'utf-8'[m: [00;38;05;171mcase[m [00;38;05;196m'ascii'[m: [00;38;05;171mcase[m [00;38;05;196m'binary'[m: [00;38;05;171mcase[m [00;38;05;196m'base64'[m: [00;38;05;171mcase[m [00;38;05;196m'ucs2'[m: [00;38;05;171mcase[m [00;38;05;196m'ucs-2'[m: [00;38;05;171mcase[m [00;38;05;196m'utf16le'[m: [00;38;05;171mcase[m [00;38;05;196m'utf-16le'[m: [00;38;05;171mcase[m [00;38;05;196m'raw'[m: [00;38;05;171mreturn[m [00;38;05;171mtrue[m;
         [00;38;05;171mdefault[m: [00;38;05;171mreturn[m [00;38;05;171mfalse[m;
       }
     }


[00;38;05;171mfunction[m [00;38;05;75massertEncoding[m(encoding) {
  [00;38;05;171mif[m (encoding && ![00;38;05;75misBufferEncoding[m(encoding)) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'Unknown encoding: '[m + encoding);
  }
}

[00;38;05;242m// StringDecoder provides an interface for efficiently splitting a series of[m
[00;38;05;242m// buffers into a series of JS strings without breaking apart multi-byte[m
[00;38;05;242m// characters. CESU-8 is handled as part of the UTF-8 encoding.[m
[00;38;05;242m//[m
[00;38;05;242m// @TODO Handling all encodings inside a single object makes it very difficult[m
[00;38;05;242m// to reason about this code, so it should be split up in the future.[m
[00;38;05;242m// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code[m
[00;38;05;242m// points as used by CESU-8.[m
[00;38;05;171mvar[m StringDecoder = exports.StringDecoder = [00;38;05;171mfunction[m(encoding) {
  [00;38;05;171mthis[m.encoding = (encoding || [00;38;05;196m'utf8'[m).[00;38;05;75mtoLowerCase[m().[00;38;05;75mreplace[m([00;38;05;208m/[-_]/[m, [00;38;05;196m''[m);
  [00;38;05;75massertEncoding[m(encoding);
  [00;38;05;171mswitch[m ([00;38;05;171mthis[m.encoding) {
    [00;38;05;171mcase[m [00;38;05;196m'utf8'[m:
      [00;38;05;242m// CESU-8 represents each of Surrogate Pair by 3-bytes[m
      [00;38;05;171mthis[m.surrogateSize = 3;
      [00;38;05;171mbreak[m;
    [00;38;05;171mcase[m [00;38;05;196m'ucs2'[m:
    [00;38;05;171mcase[m [00;38;05;196m'utf16le'[m:
      [00;38;05;242m// UTF-16 represents each of Surrogate Pair by 2-bytes[m
      [00;38;05;171mthis[m.surrogateSize = 2;
      [00;38;05;171mthis[m.detectIncompleteChar = utf16DetectIncompleteChar;
      [00;38;05;171mbreak[m;
    [00;38;05;171mcase[m [00;38;05;196m'base64'[m:
      [00;38;05;242m// Base-64 stores 3 bytes in 4 chars, and pads the remainder.[m
      [00;38;05;171mthis[m.surrogateSize = 3;
      [00;38;05;171mthis[m.detectIncompleteChar = base64DetectIncompleteChar;
      [00;38;05;171mbreak[m;
    [00;38;05;171mdefault[m:
      [00;38;05;171mthis[m.write = passThroughWrite;
      [00;38;05;171mreturn[m;
  }

  [00;38;05;242m// Enough space to store all bytes of a single character. UTF-8 needs 4[m
  [00;38;05;242m// bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).[m
  [00;38;05;171mthis[m.charBuffer = [00;38;05;171mnew[m [00;38;05;75mBuffer[m(6);
  [00;38;05;242m// Number of bytes received for the current incomplete multi-byte character.[m
  [00;38;05;171mthis[m.charReceived = 0;
  [00;38;05;242m// Number of bytes expected for the current incomplete multi-byte character.[m
  [00;38;05;171mthis[m.charLength = 0;
};


[00;38;05;242m// write decodes the given buffer and returns it as JS string that is[m
[00;38;05;242m// guaranteed to not contain any partial multi-byte characters. Any partial[m
[00;38;05;242m// character found at the end of the buffer is buffered up, and will be[m
[00;38;05;242m// returned when calling write again with the remaining bytes.[m
[00;38;05;242m//[m
[00;38;05;242m// Note: Converting a Buffer containing an orphan surrogate to a String[m
[00;38;05;242m// currently works, but converting a String to a Buffer (via `new Buffer`, or[m
[00;38;05;242m// Buffer#write) will replace incomplete surrogates with the unicode[m
[00;38;05;242m// replacement character. See https://codereview.chromium.org/121173009/ .[m
StringDecoder.[00;38;05;171mprototype[m.write = [00;38;05;171mfunction[m(buffer) {
  [00;38;05;171mvar[m charStr = [00;38;05;196m''[m;
  [00;38;05;242m// if our last write ended with an incomplete multibyte character[m
  [00;38;05;171mwhile[m ([00;38;05;171mthis[m.charLength) {
    [00;38;05;242m// determine how many remaining bytes this buffer has to offer for this char[m
    [00;38;05;171mvar[m available = (buffer.length >= [00;38;05;171mthis[m.charLength - [00;38;05;171mthis[m.charReceived) ?
        [00;38;05;171mthis[m.charLength - [00;38;05;171mthis[m.charReceived :
        buffer.length;

    [00;38;05;242m// add the new bytes to the char buffer[m
    buffer.[00;38;05;75mcopy[m([00;38;05;171mthis[m.charBuffer, [00;38;05;171mthis[m.charReceived, 0, available);
    [00;38;05;171mthis[m.charReceived += available;

    [00;38;05;171mif[m ([00;38;05;171mthis[m.charReceived < [00;38;05;171mthis[m.charLength) {
      [00;38;05;242m// still not enough chars in this buffer? wait for more ...[m
      [00;38;05;171mreturn[m [00;38;05;196m''[m;
    }

    [00;38;05;242m// remove bytes belonging to the current character from the buffer[m
    buffer = buffer.[00;38;05;75mslice[m(available, buffer.length);

    [00;38;05;242m// get the character that was split[m
    charStr = [00;38;05;171mthis[m.charBuffer.[00;38;05;75mslice[m(0, [00;38;05;171mthis[m.charLength).[00;38;05;75mtoString[m([00;38;05;171mthis[m.encoding);

    [00;38;05;242m// CESU-8: lead surrogate (D800-DBFF) is also the incomplete character[m
    [00;38;05;171mvar[m charCode = charStr.[00;38;05;75mcharCodeAt[m(charStr.length - 1);
    [00;38;05;171mif[m (charCode >= 0xD800 && charCode <= 0xDBFF) {
      [00;38;05;171mthis[m.charLength += [00;38;05;171mthis[m.surrogateSize;
      charStr = [00;38;05;196m''[m;
      [00;38;05;171mcontinue[m;
    }
    [00;38;05;171mthis[m.charReceived = [00;38;05;171mthis[m.charLength = 0;

    [00;38;05;242m// if there are no more bytes in this buffer, just emit our char[m
    [00;38;05;171mif[m (buffer.length === 0) {
      [00;38;05;171mreturn[m charStr;
    }
    [00;38;05;171mbreak[m;
  }

  [00;38;05;242m// determine and set charLength / charReceived[m
  [00;38;05;171mthis[m.[00;38;05;75mdetectIncompleteChar[m(buffer);

  [00;38;05;171mvar[m end = buffer.length;
  [00;38;05;171mif[m ([00;38;05;171mthis[m.charLength) {
    [00;38;05;242m// buffer the incomplete character bytes we got[m
    buffer.[00;38;05;75mcopy[m([00;38;05;171mthis[m.charBuffer, 0, buffer.length - [00;38;05;171mthis[m.charReceived, end);
    end -= [00;38;05;171mthis[m.charReceived;
  }

  charStr += buffer.[00;38;05;75mtoString[m([00;38;05;171mthis[m.encoding, 0, end);

  [00;38;05;171mvar[m end = charStr.length - 1;
  [00;38;05;171mvar[m charCode = charStr.[00;38;05;75mcharCodeAt[m(end);
  [00;38;05;242m// CESU-8: lead surrogate (D800-DBFF) is also the incomplete character[m
  [00;38;05;171mif[m (charCode >= 0xD800 && charCode <= 0xDBFF) {
    [00;38;05;171mvar[m size = [00;38;05;171mthis[m.surrogateSize;
    [00;38;05;171mthis[m.charLength += size;
    [00;38;05;171mthis[m.charReceived += size;
    [00;38;05;171mthis[m.charBuffer.[00;38;05;75mcopy[m([00;38;05;171mthis[m.charBuffer, size, 0, size);
    buffer.[00;38;05;75mcopy[m([00;38;05;171mthis[m.charBuffer, 0, 0, size);
    [00;38;05;171mreturn[m charStr.[00;38;05;75msubstring[m(0, end);
  }

  [00;38;05;242m// or just emit the charStr[m
  [00;38;05;171mreturn[m charStr;
};

[00;38;05;242m// detectIncompleteChar determines if there is an incomplete UTF-8 character at[m
[00;38;05;242m// the end of the given buffer. If so, it sets this.charLength to the byte[m
[00;38;05;242m// length that character, and sets this.charReceived to the number of bytes[m
[00;38;05;242m// that are available for this character.[m
StringDecoder.[00;38;05;171mprototype[m.detectIncompleteChar = [00;38;05;171mfunction[m(buffer) {
  [00;38;05;242m// determine how many bytes we have to check at the end of this buffer[m
  [00;38;05;171mvar[m i = (buffer.length >= 3) ? 3 : buffer.length;

  [00;38;05;242m// Figure out if one of the last i bytes of our buffer announces an[m
  [00;38;05;242m// incomplete char.[m
  [00;38;05;171mfor[m (; i > 0; i--) {
    [00;38;05;171mvar[m c = buffer[buffer.length - i];

    [00;38;05;242m// See http://en.wikipedia.org/wiki/UTF-8#Description[m

    [00;38;05;242m// 110XXXXX[m
    [00;38;05;171mif[m (i == 1 && c >> 5 == 0x06) {
      [00;38;05;171mthis[m.charLength = 2;
      [00;38;05;171mbreak[m;
    }

    [00;38;05;242m// 1110XXXX[m
    [00;38;05;171mif[m (i <= 2 && c >> 4 == 0x0E) {
      [00;38;05;171mthis[m.charLength = 3;
      [00;38;05;171mbreak[m;
    }

    [00;38;05;242m// 11110XXX[m
    [00;38;05;171mif[m (i <= 3 && c >> 3 == 0x1E) {
      [00;38;05;171mthis[m.charLength = 4;
      [00;38;05;171mbreak[m;
    }
  }
  [00;38;05;171mthis[m.charReceived = i;
};

StringDecoder.[00;38;05;171mprototype[m.end = [00;38;05;171mfunction[m(buffer) {
  [00;38;05;171mvar[m res = [00;38;05;196m''[m;
  [00;38;05;171mif[m (buffer && buffer.length)
    res = [00;38;05;171mthis[m.[00;38;05;75mwrite[m(buffer);

  [00;38;05;171mif[m ([00;38;05;171mthis[m.charReceived) {
    [00;38;05;171mvar[m cr = [00;38;05;171mthis[m.charReceived;
    [00;38;05;171mvar[m buf = [00;38;05;171mthis[m.charBuffer;
    [00;38;05;171mvar[m enc = [00;38;05;171mthis[m.encoding;
    res += buf.[00;38;05;75mslice[m(0, cr).[00;38;05;75mtoString[m(enc);
  }

  [00;38;05;171mreturn[m res;
};

[00;38;05;171mfunction[m [00;38;05;75mpassThroughWrite[m(buffer) {
  [00;38;05;171mreturn[m buffer.[00;38;05;75mtoString[m([00;38;05;171mthis[m.encoding);
}

[00;38;05;171mfunction[m [00;38;05;75mutf16DetectIncompleteChar[m(buffer) {
  [00;38;05;171mthis[m.charReceived = buffer.length % 2;
  [00;38;05;171mthis[m.charLength = [00;38;05;171mthis[m.charReceived ? 2 : 0;
}

[00;38;05;171mfunction[m [00;38;05;75mbase64DetectIncompleteChar[m(buffer) {
  [00;38;05;171mthis[m.charReceived = buffer.length % 3;
  [00;38;05;171mthis[m.charLength = [00;38;05;171mthis[m.charReceived ? 3 : 0;
}


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 18 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;


[00;38;05;171mvar[m required = [00;38;05;75m__webpack_require__[m(34)
  , lolcation = [00;38;05;75m__webpack_require__[m(40)
  , qs = [00;38;05;75m__webpack_require__[m(31)
  , relativere = [00;38;05;208m/^\/(?!\/)/[m;

[00;38;05;242m/**[m
[00;38;05;242m * These are the parse instructions for the URL parsers, it informs the parser[m
[00;38;05;242m * about:[m
[00;38;05;242m *[m
[00;38;05;242m * 0. The char it Needs to parse, if it's a string it should be done using[m
[00;38;05;242m *    indexOf, RegExp using exec and NaN means set as current value.[m
[00;38;05;242m * 1. The property we should set when parsing this value.[m
[00;38;05;242m * 2. Indication if it's backwards or forward parsing, when set as number it's[m
[00;38;05;242m *    the value of extra chars that should be split off.[m
[00;38;05;242m * 3. Inherit from location if non existing in the parser.[m
[00;38;05;242m * 4. `toLowerCase` the resulting value.[m
[00;38;05;242m */[m
[00;38;05;171mvar[m instructions = [
  [[00;38;05;196m'#'[m, [00;38;05;196m'hash'[m],                        [00;38;05;242m// Extract from the back.[m
  [[00;38;05;196m'?'[m, [00;38;05;196m'query'[m],                       [00;38;05;242m// Extract from the back.[m
  [[00;38;05;196m'//'[m, [00;38;05;196m'protocol'[m, 2, 1, 1],          [00;38;05;242m// Extract from the front.[m
  [[00;38;05;196m'/'[m, [00;38;05;196m'pathname'[m],                    [00;38;05;242m// Extract from the back.[m
  [[00;38;05;196m'@'[m, [00;38;05;196m'auth'[m, 1],                     [00;38;05;242m// Extract from the front.[m
  [NaN, [00;38;05;196m'host'[m, undefined, 1, 1],       [00;38;05;242m// Set left over value.[m
  [[00;38;05;208m/\:(\d+)$/[m, [00;38;05;196m'port'[m],                 [00;38;05;242m// RegExp the back.[m
  [NaN, [00;38;05;196m'hostname'[m, undefined, 1, 1]    [00;38;05;242m// Set left over.[m
];

[00;38;05;242m/**[m
[00;38;05;242m * The actual URL instance. Instead of returning an object we've opted-in to[m
[00;38;05;242m * create an actual constructor as it's much more memory efficient and[m
[00;38;05;242m * faster and it pleases my CDO.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@constructor[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {String} address URL we want to parse.[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {Boolean|function} parser Parser for the query string.[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {Object} location Location defaults for relative paths.[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m public[m
[00;38;05;242m */[m
[00;38;05;171mfunction[m [00;38;05;75mURL[m(address, location, parser) {
  [00;38;05;171mif[m (!([00;38;05;171mthis[m [00;38;05;171minstanceof[m URL)) {
    [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mURL[m(address, location, parser);
  }

  [00;38;05;171mvar[m relative = relativere.[00;38;05;75mtest[m(address)
    , parse, instruction, index, key
    , type = [00;38;05;171mtypeof[m location
    , url = [00;38;05;171mthis[m
    , i = 0;

  [00;38;05;242m//[m
  [00;38;05;242m// The following if statements allows this module two have compatibility with[m
  [00;38;05;242m// 2 different API:[m
  [00;38;05;242m//[m
  [00;38;05;242m// 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments[m
  [00;38;05;242m//    where the boolean indicates that the query string should also be parsed.[m
  [00;38;05;242m//[m
  [00;38;05;242m// 2. The `URL` interface of the browser which accepts a URL, object as[m
  [00;38;05;242m//    arguments. The supplied object will be used as default values / fall-back[m
  [00;38;05;242m//    for relative paths.[m
  [00;38;05;242m//[m
  [00;38;05;171mif[m ([00;38;05;196m'object'[m !== type && [00;38;05;196m'string'[m !== type) {
    parser = location;
    location = [00;38;05;171mnull[m;
  }

  [00;38;05;171mif[m (parser && [00;38;05;196m'function'[m !== [00;38;05;171mtypeof[m parser) {
    parser = qs.parse;
  }

  location = [00;38;05;75mlolcation[m(location);

  [00;38;05;171mfor[m (; i < instructions.length; i++) {
    instruction = instructions[i];
    parse = instruction[0];
    key = instruction[1];

    [00;38;05;171mif[m (parse !== parse) {
      url[key] = address;
    } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;196m'string'[m === [00;38;05;171mtypeof[m parse) {
      [00;38;05;171mif[m (~(index = address.[00;38;05;75mindexOf[m(parse))) {
        [00;38;05;171mif[m ([00;38;05;196m'number'[m === [00;38;05;171mtypeof[m instruction[2]) {
          url[key] = address.[00;38;05;75mslice[m(0, index);
          address = address.[00;38;05;75mslice[m(index + instruction[2]);
        } [00;38;05;171melse[m {
          url[key] = address.[00;38;05;75mslice[m(index);
          address = address.[00;38;05;75mslice[m(0, index);
        }
      }
    } [00;38;05;171melse[m [00;38;05;171mif[m (index = parse.[00;38;05;75mexec[m(address)) {
      url[key] = index[1];
      address = address.[00;38;05;75mslice[m(0, address.length - index[0].length);
    }

    url[key] = url[key] || (instruction[3] || ([00;38;05;196m'port'[m === key && relative) ? location[key] || [00;38;05;196m''[m : [00;38;05;196m''[m);

    [00;38;05;242m//[m
    [00;38;05;242m// Hostname, host and protocol should be lowercased so they can be used to[m
    [00;38;05;242m// create a proper `origin`.[m
    [00;38;05;242m//[m
    [00;38;05;171mif[m (instruction[4]) {
      url[key] = url[key].[00;38;05;75mtoLowerCase[m();
    }
  }

  [00;38;05;242m//[m
  [00;38;05;242m// Also parse the supplied query string in to an object. If we're supplied[m
  [00;38;05;242m// with a custom parser as function use that instead of the default build-in[m
  [00;38;05;242m// parser.[m
  [00;38;05;242m//[m
  [00;38;05;171mif[m (parser) url.query = [00;38;05;75mparser[m(url.query);

  [00;38;05;242m//[m
  [00;38;05;242m// We should not add port numbers if they are already the default port number[m
  [00;38;05;242m// for a given protocol. As the host also contains the port number we're going[m
  [00;38;05;242m// override it with the hostname which contains no port number.[m
  [00;38;05;242m//[m
  [00;38;05;171mif[m (![00;38;05;75mrequired[m(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = [00;38;05;196m''[m;
  }

  [00;38;05;242m//[m
  [00;38;05;242m// Parse down the `auth` for the username and password.[m
  [00;38;05;242m//[m
  url.username = url.password = [00;38;05;196m''[m;
  [00;38;05;171mif[m (url.auth) {
    instruction = url.auth.[00;38;05;75msplit[m([00;38;05;196m':'[m);
    url.username = instruction[0] || [00;38;05;196m''[m;
    url.password = instruction[1] || [00;38;05;196m''[m;
  }

  [00;38;05;242m//[m
  [00;38;05;242m// The href is just the compiled result.[m
  [00;38;05;242m//[m
  url.href = url.[00;38;05;75mtoString[m();
}

[00;38;05;242m/**[m
[00;38;05;242m * This is convenience method for changing properties in the URL instance to[m
[00;38;05;242m * insure that they all propagate correctly.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {String} prop Property we need to adjust.[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {Mixed} value The newly assigned value.[m
[00;38;05;242m * [m[00;38;05;70m@returns[m[00;38;05;242m {URL}[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m public[m
[00;38;05;242m */[m
URL.[00;38;05;171mprototype[m.set = [00;38;05;171mfunction[m [00;38;05;75mset[m(part, value, fn) {
  [00;38;05;171mvar[m url = [00;38;05;171mthis[m;

  [00;38;05;171mif[m ([00;38;05;196m'query'[m === part) {
    [00;38;05;171mif[m ([00;38;05;196m'string'[m === [00;38;05;171mtypeof[m value && value.length) {
      value = (fn || qs.parse)(value);
    }

    url[part] = value;
  } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;196m'port'[m === part) {
    url[part] = value;

    [00;38;05;171mif[m (![00;38;05;75mrequired[m(value, url.protocol)) {
      url.host = url.hostname;
      url[part] = [00;38;05;196m''[m;
    } [00;38;05;171melse[m [00;38;05;171mif[m (value) {
      url.host = url.hostname +[00;38;05;196m':'[m+ value;
    }
  } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;196m'hostname'[m === part) {
    url[part] = value;

    [00;38;05;171mif[m (url.port) value += [00;38;05;196m':'[m+ url.port;
    url.host = value;
  } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;196m'host'[m === part) {
    url[part] = value;

    [00;38;05;171mif[m ([00;38;05;208m/\:\d+/[m.[00;38;05;75mtest[m(value)) {
      value = value.[00;38;05;75msplit[m([00;38;05;196m':'[m);
      url.hostname = value[0];
      url.port = value[1];
    }
  } [00;38;05;171melse[m {
    url[part] = value;
  }

  url.href = url.[00;38;05;75mtoString[m();
  [00;38;05;171mreturn[m url;
};

[00;38;05;242m/**[m
[00;38;05;242m * Transform the properties back in to a valid and full URL string.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {Function} stringify Optional query stringify function.[m
[00;38;05;242m * [m[00;38;05;70m@returns[m[00;38;05;242m {String}[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m public[m
[00;38;05;242m */[m
URL.[00;38;05;171mprototype[m.toString = [00;38;05;171mfunction[m [00;38;05;75mtoString[m(stringify) {
  [00;38;05;171mif[m (!stringify || [00;38;05;196m'function'[m !== [00;38;05;171mtypeof[m stringify) stringify = qs.stringify;

  [00;38;05;171mvar[m query
    , url = [00;38;05;171mthis[m
    , result = url.protocol +[00;38;05;196m'//'[m;

  [00;38;05;171mif[m (url.username) {
    result += url.username;
    [00;38;05;171mif[m (url.password) result += [00;38;05;196m':'[m+ url.password;
    result += [00;38;05;196m'@'[m;
  }

  result += url.hostname;
  [00;38;05;171mif[m (url.port) result += [00;38;05;196m':'[m+ url.port;

  result += url.pathname;

  query = [00;38;05;196m'object'[m === [00;38;05;171mtypeof[m url.query ? [00;38;05;75mstringify[m(url.query) : url.query;
  [00;38;05;171mif[m (query) result += [00;38;05;196m'?'[m !== query.[00;38;05;75mcharAt[m(0) ? [00;38;05;196m'?'[m+ query : query;

  [00;38;05;171mif[m (url.hash) result += url.hash;

  [00;38;05;171mreturn[m result;
};

[00;38;05;242m//[m
[00;38;05;242m// Expose the URL parser and some additional properties that might be useful for[m
[00;38;05;242m// others.[m
[00;38;05;242m//[m
URL.qs = qs;
URL.location = lolcation;
module.exports = URL;


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 19 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;
[00;38;05;242m// Copyright Joyent, Inc. and other Node contributors.[m
[00;38;05;242m//[m
[00;38;05;242m// Permission is hereby granted, free of charge, to any person obtaining a[m
[00;38;05;242m// copy of this software and associated documentation files (the[m
[00;38;05;242m// "Software"), to deal in the Software without restriction, including[m
[00;38;05;242m// without limitation the rights to use, copy, modify, merge, publish,[m
[00;38;05;242m// distribute, sublicense, and/or sell copies of the Software, and to permit[m
[00;38;05;242m// persons to whom the Software is furnished to do so, subject to the[m
[00;38;05;242m// following conditions:[m
[00;38;05;242m//[m
[00;38;05;242m// The above copyright notice and this permission notice shall be included[m
[00;38;05;242m// in all copies or substantial portions of the Software.[m
[00;38;05;242m//[m
[00;38;05;242m// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS[m
[00;38;05;242m// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF[m
[00;38;05;242m// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN[m
[00;38;05;242m// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,[m
[00;38;05;242m// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR[m
[00;38;05;242m// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE[m
[00;38;05;242m// USE OR OTHER DEALINGS IN THE SOFTWARE.[m



[00;38;05;171mvar[m punycode = [00;38;05;75m__webpack_require__[m(27);
[00;38;05;171mvar[m util = [00;38;05;75m__webpack_require__[m(41);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

[00;38;05;171mfunction[m [00;38;05;75mUrl[m() {
  [00;38;05;171mthis[m.protocol = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.slashes = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.auth = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.host = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.port = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.hostname = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.hash = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.search = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.query = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.pathname = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.path = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.href = [00;38;05;171mnull[m;
}

[00;38;05;242m// Reference: RFC 3986, RFC 1808, RFC 2396[m

[00;38;05;242m// define these here so at least they only have to be[m
[00;38;05;242m// compiled once on the first module load.[m
[00;38;05;171mvar[m protocolPattern = [00;38;05;208m/^([a-z0-9.+-]+:)/i[m,
    portPattern = [00;38;05;208m/:[0-9]*$/[m,

    [00;38;05;242m// Special case for a simple path URL[m
    simplePathPattern = [00;38;05;208m/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/[m,

    [00;38;05;242m// RFC 2396: characters reserved for delimiting URLs.[m
    [00;38;05;242m// We actually just auto-escape these.[m
    delims = [[00;38;05;196m'<'[m, [00;38;05;196m'>'[m, [00;38;05;196m'"'[m, [00;38;05;196m'`'[m, [00;38;05;196m' '[m, [00;38;05;196m'[m\r[00;38;05;196m'[m, [00;38;05;196m'[m\n[00;38;05;196m'[m, [00;38;05;196m'[m\t[00;38;05;196m'[m],

    [00;38;05;242m// RFC 2396: characters not allowed for various reasons.[m
    unwise = [[00;38;05;196m'{'[m, [00;38;05;196m'}'[m, [00;38;05;196m'|'[m, [00;38;05;196m'[m\\[00;38;05;196m'[m, [00;38;05;196m'^'[m, [00;38;05;196m'`'[m].[00;38;05;75mconcat[m(delims),

    [00;38;05;242m// Allowed by RFCs, but cause of XSS attacks.  Always escape these.[m
    autoEscape = [[00;38;05;196m'[m\'[00;38;05;196m'[m].[00;38;05;75mconcat[m(unwise),
    [00;38;05;242m// Characters that are never ever allowed in a hostname.[m
    [00;38;05;242m// Note that any invalid chars are also handled, but these[m
    [00;38;05;242m// are the ones that are *expected* to be seen, so we fast-path[m
    [00;38;05;242m// them.[m
    nonHostChars = [[00;38;05;196m'%'[m, [00;38;05;196m'/'[m, [00;38;05;196m'?'[m, [00;38;05;196m';'[m, [00;38;05;196m'#'[m].[00;38;05;75mconcat[m(autoEscape),
    hostEndingChars = [[00;38;05;196m'/'[m, [00;38;05;196m'?'[m, [00;38;05;196m'#'[m],
    hostnameMaxLen = 255,
    hostnamePartPattern = [00;38;05;208m/^[+a-z0-9A-Z_-]{0,63}$/[m,
    hostnamePartStart = [00;38;05;208m/^([+a-z0-9A-Z_-]{0,63})(.*)$/[m,
    [00;38;05;242m// protocols that can allow "unsafe" and "unwise" chars.[m
    unsafeProtocol = {
      [00;38;05;196m'javascript'[m: [00;38;05;171mtrue[m,
      [00;38;05;196m'javascript:'[m: [00;38;05;171mtrue[m
    },
    [00;38;05;242m// protocols that never have a hostname.[m
    hostlessProtocol = {
      [00;38;05;196m'javascript'[m: [00;38;05;171mtrue[m,
      [00;38;05;196m'javascript:'[m: [00;38;05;171mtrue[m
    },
    [00;38;05;242m// protocols that always contain a // bit.[m
    slashedProtocol = {
      [00;38;05;196m'http'[m: [00;38;05;171mtrue[m,
      [00;38;05;196m'https'[m: [00;38;05;171mtrue[m,
      [00;38;05;196m'ftp'[m: [00;38;05;171mtrue[m,
      [00;38;05;196m'gopher'[m: [00;38;05;171mtrue[m,
      [00;38;05;196m'file'[m: [00;38;05;171mtrue[m,
      [00;38;05;196m'http:'[m: [00;38;05;171mtrue[m,
      [00;38;05;196m'https:'[m: [00;38;05;171mtrue[m,
      [00;38;05;196m'ftp:'[m: [00;38;05;171mtrue[m,
      [00;38;05;196m'gopher:'[m: [00;38;05;171mtrue[m,
      [00;38;05;196m'file:'[m: [00;38;05;171mtrue[m
    },
    querystring = [00;38;05;75m__webpack_require__[m(30);

[00;38;05;171mfunction[m [00;38;05;75murlParse[m(url, parseQueryString, slashesDenoteHost) {
  [00;38;05;171mif[m (url && util.[00;38;05;75misObject[m(url) && url [00;38;05;171minstanceof[m Url) [00;38;05;171mreturn[m url;

  [00;38;05;171mvar[m u = [00;38;05;171mnew[m Url;
  u.[00;38;05;75mparse[m(url, parseQueryString, slashesDenoteHost);
  [00;38;05;171mreturn[m u;
}

Url.[00;38;05;171mprototype[m.parse = [00;38;05;171mfunction[m(url, parseQueryString, slashesDenoteHost) {
  [00;38;05;171mif[m (!util.[00;38;05;75misString[m(url)) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mTypeError[m([00;38;05;196m"Parameter 'url' must be a string, not "[m + [00;38;05;171mtypeof[m url);
  }

  [00;38;05;242m// Copy chrome, IE, opera backslash-handling behavior.[m
  [00;38;05;242m// Back slashes before the query string get converted to forward slashes[m
  [00;38;05;242m// See: https://code.google.com/p/chromium/issues/detail?id=25916[m
  [00;38;05;171mvar[m queryIndex = url.[00;38;05;75mindexOf[m([00;38;05;196m'?'[m),
      splitter =
          (queryIndex !== -1 && queryIndex < url.[00;38;05;75mindexOf[m([00;38;05;196m'#'[m)) ? [00;38;05;196m'?'[m : [00;38;05;196m'#'[m,
      uSplit = url.[00;38;05;75msplit[m(splitter),
      slashRegex = [00;38;05;208m/\\/g[m;
  uSplit[0] = uSplit[0].[00;38;05;75mreplace[m(slashRegex, [00;38;05;196m'/'[m);
  url = uSplit.[00;38;05;75mjoin[m(splitter);

  [00;38;05;171mvar[m rest = url;

  [00;38;05;242m// trim before proceeding.[m
  [00;38;05;242m// This is to support parse stuff like "  http://foo.com  \n"[m
  rest = rest.[00;38;05;75mtrim[m();

  [00;38;05;171mif[m (!slashesDenoteHost && url.[00;38;05;75msplit[m([00;38;05;196m'#'[m).length === 1) {
    [00;38;05;242m// Try fast path regexp[m
    [00;38;05;171mvar[m simplePath = simplePathPattern.[00;38;05;75mexec[m(rest);
    [00;38;05;171mif[m (simplePath) {
      [00;38;05;171mthis[m.path = rest;
      [00;38;05;171mthis[m.href = rest;
      [00;38;05;171mthis[m.pathname = simplePath[1];
      [00;38;05;171mif[m (simplePath[2]) {
        [00;38;05;171mthis[m.search = simplePath[2];
        [00;38;05;171mif[m (parseQueryString) {
          [00;38;05;171mthis[m.query = querystring.[00;38;05;75mparse[m([00;38;05;171mthis[m.search.[00;38;05;75msubstr[m(1));
        } [00;38;05;171melse[m {
          [00;38;05;171mthis[m.query = [00;38;05;171mthis[m.search.[00;38;05;75msubstr[m(1);
        }
      } [00;38;05;171melse[m [00;38;05;171mif[m (parseQueryString) {
        [00;38;05;171mthis[m.search = [00;38;05;196m''[m;
        [00;38;05;171mthis[m.query = {};
      }
      [00;38;05;171mreturn[m [00;38;05;171mthis[m;
    }
  }

  [00;38;05;171mvar[m proto = protocolPattern.[00;38;05;75mexec[m(rest);
  [00;38;05;171mif[m (proto) {
    proto = proto[0];
    [00;38;05;171mvar[m lowerProto = proto.[00;38;05;75mtoLowerCase[m();
    [00;38;05;171mthis[m.protocol = lowerProto;
    rest = rest.[00;38;05;75msubstr[m(proto.length);
  }

  [00;38;05;242m// figure out if it's got a host[m
  [00;38;05;242m// user@server is *always* interpreted as a hostname, and url[m
  [00;38;05;242m// resolution will treat //foo/bar as host=foo,path=bar because that's[m
  [00;38;05;242m// how the browser resolves relative URLs.[m
  [00;38;05;171mif[m (slashesDenoteHost || proto || rest.[00;38;05;75mmatch[m([00;38;05;208m/^\/\/[^@\/]+@[^@\/]+/[m)) {
    [00;38;05;171mvar[m slashes = rest.[00;38;05;75msubstr[m(0, 2) === [00;38;05;196m'//'[m;
    [00;38;05;171mif[m (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.[00;38;05;75msubstr[m(2);
      [00;38;05;171mthis[m.slashes = [00;38;05;171mtrue[m;
    }
  }

  [00;38;05;171mif[m (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    [00;38;05;242m// there's a hostname.[m
    [00;38;05;242m// the first instance of /, ?, ;, or # ends the host.[m
    [00;38;05;242m//[m
    [00;38;05;242m// If there is an @ in the hostname, then non-host chars *are* allowed[m
    [00;38;05;242m// to the left of the last @ sign, unless some host-ending character[m
    [00;38;05;242m// comes *before* the @-sign.[m
    [00;38;05;242m// URLs are obnoxious.[m
    [00;38;05;242m//[m
    [00;38;05;242m// ex:[m
    [00;38;05;242m// http://a@b@c/ => user:a@b host:c[m
    [00;38;05;242m// http://a@b?@c => user:a host:c path:/?@c[m

    [00;38;05;242m// v0.12 TODO(isaacs): This is not quite how Chrome does things.[m
    [00;38;05;242m// Review our test case against browsers more comprehensively.[m

    [00;38;05;242m// find the first instance of any hostEndingChars[m
    [00;38;05;171mvar[m hostEnd = -1;
    [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < hostEndingChars.length; i++) {
      [00;38;05;171mvar[m hec = rest.[00;38;05;75mindexOf[m(hostEndingChars[i]);
      [00;38;05;171mif[m (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    [00;38;05;242m// at this point, either we have an explicit point where the[m
    [00;38;05;242m// auth portion cannot go past, or the last @ char is the decider.[m
    [00;38;05;171mvar[m auth, atSign;
    [00;38;05;171mif[m (hostEnd === -1) {
      [00;38;05;242m// atSign can be anywhere.[m
      atSign = rest.[00;38;05;75mlastIndexOf[m([00;38;05;196m'@'[m);
    } [00;38;05;171melse[m {
      [00;38;05;242m// atSign must be in auth portion.[m
      [00;38;05;242m// http://a@b/c@d => host:b auth:a path:/c@d[m
      atSign = rest.[00;38;05;75mlastIndexOf[m([00;38;05;196m'@'[m, hostEnd);
    }

    [00;38;05;242m// Now we have a portion which is definitely the auth.[m
    [00;38;05;242m// Pull that off.[m
    [00;38;05;171mif[m (atSign !== -1) {
      auth = rest.[00;38;05;75mslice[m(0, atSign);
      rest = rest.[00;38;05;75mslice[m(atSign + 1);
      [00;38;05;171mthis[m.auth = [00;38;05;75mdecodeURIComponent[m(auth);
    }

    [00;38;05;242m// the host is the remaining to the left of the first non-host char[m
    hostEnd = -1;
    [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < nonHostChars.length; i++) {
      [00;38;05;171mvar[m hec = rest.[00;38;05;75mindexOf[m(nonHostChars[i]);
      [00;38;05;171mif[m (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    [00;38;05;242m// if we still have not hit it, then the entire thing is a host.[m
    [00;38;05;171mif[m (hostEnd === -1)
      hostEnd = rest.length;

    [00;38;05;171mthis[m.host = rest.[00;38;05;75mslice[m(0, hostEnd);
    rest = rest.[00;38;05;75mslice[m(hostEnd);

    [00;38;05;242m// pull out port.[m
    [00;38;05;171mthis[m.[00;38;05;75mparseHost[m();

    [00;38;05;242m// we've indicated that there is a hostname,[m
    [00;38;05;242m// so even if it's empty, it has to be present.[m
    [00;38;05;171mthis[m.hostname = [00;38;05;171mthis[m.hostname || [00;38;05;196m''[m;

    [00;38;05;242m// if hostname begins with [ and ends with ][m
    [00;38;05;242m// assume that it's an IPv6 address.[m
    [00;38;05;171mvar[m ipv6Hostname = [00;38;05;171mthis[m.hostname[0] === [00;38;05;196m'['[m &&
        [00;38;05;171mthis[m.hostname[[00;38;05;171mthis[m.hostname.length - 1] === [00;38;05;196m']'[m;

    [00;38;05;242m// validate a little.[m
    [00;38;05;171mif[m (!ipv6Hostname) {
      [00;38;05;171mvar[m hostparts = [00;38;05;171mthis[m.hostname.[00;38;05;75msplit[m([00;38;05;208m/\./[m);
      [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0, l = hostparts.length; i < l; i++) {
        [00;38;05;171mvar[m part = hostparts[i];
        [00;38;05;171mif[m (!part) [00;38;05;171mcontinue[m;
        [00;38;05;171mif[m (!part.[00;38;05;75mmatch[m(hostnamePartPattern)) {
          [00;38;05;171mvar[m newpart = [00;38;05;196m''[m;
          [00;38;05;171mfor[m ([00;38;05;171mvar[m j = 0, k = part.length; j < k; j++) {
            [00;38;05;171mif[m (part.[00;38;05;75mcharCodeAt[m(j) > 127) {
              [00;38;05;242m// we replace non-ASCII char with a temporary placeholder[m
              [00;38;05;242m// we need this to make sure size of hostname is not[m
              [00;38;05;242m// broken by replacing non-ASCII by nothing[m
              newpart += [00;38;05;196m'x'[m;
            } [00;38;05;171melse[m {
              newpart += part[j];
            }
          }
          [00;38;05;242m// we test again with ASCII char only[m
          [00;38;05;171mif[m (!newpart.[00;38;05;75mmatch[m(hostnamePartPattern)) {
            [00;38;05;171mvar[m validParts = hostparts.[00;38;05;75mslice[m(0, i);
            [00;38;05;171mvar[m notHost = hostparts.[00;38;05;75mslice[m(i + 1);
            [00;38;05;171mvar[m bit = part.[00;38;05;75mmatch[m(hostnamePartStart);
            [00;38;05;171mif[m (bit) {
              validParts.[00;38;05;75mpush[m(bit[1]);
              notHost.[00;38;05;75munshift[m(bit[2]);
            }
            [00;38;05;171mif[m (notHost.length) {
              rest = [00;38;05;196m'/'[m + notHost.[00;38;05;75mjoin[m([00;38;05;196m'.'[m) + rest;
            }
            [00;38;05;171mthis[m.hostname = validParts.[00;38;05;75mjoin[m([00;38;05;196m'.'[m);
            [00;38;05;171mbreak[m;
          }
        }
      }
    }

    [00;38;05;171mif[m ([00;38;05;171mthis[m.hostname.length > hostnameMaxLen) {
      [00;38;05;171mthis[m.hostname = [00;38;05;196m''[m;
    } [00;38;05;171melse[m {
      [00;38;05;242m// hostnames are always lower case.[m
      [00;38;05;171mthis[m.hostname = [00;38;05;171mthis[m.hostname.[00;38;05;75mtoLowerCase[m();
    }

    [00;38;05;171mif[m (!ipv6Hostname) {
      [00;38;05;242m// IDNA Support: Returns a punycoded representation of "domain".[m
      [00;38;05;242m// It only converts parts of the domain name that[m
      [00;38;05;242m// have non-ASCII characters, i.e. it doesn't matter if[m
      [00;38;05;242m// you call it with a domain that already is ASCII-only.[m
      [00;38;05;171mthis[m.hostname = punycode.[00;38;05;75mtoASCII[m([00;38;05;171mthis[m.hostname);
    }

    [00;38;05;171mvar[m p = [00;38;05;171mthis[m.port ? [00;38;05;196m':'[m + [00;38;05;171mthis[m.port : [00;38;05;196m''[m;
    [00;38;05;171mvar[m h = [00;38;05;171mthis[m.hostname || [00;38;05;196m''[m;
    [00;38;05;171mthis[m.host = h + p;
    [00;38;05;171mthis[m.href += [00;38;05;171mthis[m.host;

    [00;38;05;242m// strip [ and ] from the hostname[m
    [00;38;05;242m// the host field still retains them, though[m
    [00;38;05;171mif[m (ipv6Hostname) {
      [00;38;05;171mthis[m.hostname = [00;38;05;171mthis[m.hostname.[00;38;05;75msubstr[m(1, [00;38;05;171mthis[m.hostname.length - 2);
      [00;38;05;171mif[m (rest[0] !== [00;38;05;196m'/'[m) {
        rest = [00;38;05;196m'/'[m + rest;
      }
    }
  }

  [00;38;05;242m// now rest is set to the post-host stuff.[m
  [00;38;05;242m// chop off any delim chars.[m
  [00;38;05;171mif[m (!unsafeProtocol[lowerProto]) {

    [00;38;05;242m// First, make 100% sure that any "autoEscape" chars get[m
    [00;38;05;242m// escaped, even if encodeURIComponent doesn't think they[m
    [00;38;05;242m// need to be.[m
    [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0, l = autoEscape.length; i < l; i++) {
      [00;38;05;171mvar[m ae = autoEscape[i];
      [00;38;05;171mif[m (rest.[00;38;05;75mindexOf[m(ae) === -1)
        [00;38;05;171mcontinue[m;
      [00;38;05;171mvar[m esc = [00;38;05;75mencodeURIComponent[m(ae);
      [00;38;05;171mif[m (esc === ae) {
        esc = [00;38;05;75mescape[m(ae);
      }
      rest = rest.[00;38;05;75msplit[m(ae).[00;38;05;75mjoin[m(esc);
    }
  }


  [00;38;05;242m// chop off from the tail first.[m
  [00;38;05;171mvar[m hash = rest.[00;38;05;75mindexOf[m([00;38;05;196m'#'[m);
  [00;38;05;171mif[m (hash !== -1) {
    [00;38;05;242m// got a fragment string.[m
    [00;38;05;171mthis[m.hash = rest.[00;38;05;75msubstr[m(hash);
    rest = rest.[00;38;05;75mslice[m(0, hash);
  }
  [00;38;05;171mvar[m qm = rest.[00;38;05;75mindexOf[m([00;38;05;196m'?'[m);
  [00;38;05;171mif[m (qm !== -1) {
    [00;38;05;171mthis[m.search = rest.[00;38;05;75msubstr[m(qm);
    [00;38;05;171mthis[m.query = rest.[00;38;05;75msubstr[m(qm + 1);
    [00;38;05;171mif[m (parseQueryString) {
      [00;38;05;171mthis[m.query = querystring.[00;38;05;75mparse[m([00;38;05;171mthis[m.query);
    }
    rest = rest.[00;38;05;75mslice[m(0, qm);
  } [00;38;05;171melse[m [00;38;05;171mif[m (parseQueryString) {
    [00;38;05;242m// no query string, but parseQueryString still requested[m
    [00;38;05;171mthis[m.search = [00;38;05;196m''[m;
    [00;38;05;171mthis[m.query = {};
  }
  [00;38;05;171mif[m (rest) [00;38;05;171mthis[m.pathname = rest;
  [00;38;05;171mif[m (slashedProtocol[lowerProto] &&
      [00;38;05;171mthis[m.hostname && ![00;38;05;171mthis[m.pathname) {
    [00;38;05;171mthis[m.pathname = [00;38;05;196m'/'[m;
  }

  [00;38;05;242m//to support http.request[m
  [00;38;05;171mif[m ([00;38;05;171mthis[m.pathname || [00;38;05;171mthis[m.search) {
    [00;38;05;171mvar[m p = [00;38;05;171mthis[m.pathname || [00;38;05;196m''[m;
    [00;38;05;171mvar[m s = [00;38;05;171mthis[m.search || [00;38;05;196m''[m;
    [00;38;05;171mthis[m.path = p + s;
  }

  [00;38;05;242m// finally, reconstruct the href based on what has been validated.[m
  [00;38;05;171mthis[m.href = [00;38;05;171mthis[m.[00;38;05;75mformat[m();
  [00;38;05;171mreturn[m [00;38;05;171mthis[m;
};

[00;38;05;242m// format a parsed object into a url string[m
[00;38;05;171mfunction[m [00;38;05;75murlFormat[m(obj) {
  [00;38;05;242m// ensure it's an object, and not a string url.[m
  [00;38;05;242m// If it's an obj, this is a no-op.[m
  [00;38;05;242m// this way, you can call url_format() on strings[m
  [00;38;05;242m// to clean up potentially wonky urls.[m
  [00;38;05;171mif[m (util.[00;38;05;75misString[m(obj)) obj = [00;38;05;75murlParse[m(obj);
  [00;38;05;171mif[m (!(obj [00;38;05;171minstanceof[m Url)) [00;38;05;171mreturn[m Url.[00;38;05;171mprototype[m.format.[00;38;05;75mcall[m(obj);
  [00;38;05;171mreturn[m obj.[00;38;05;75mformat[m();
}

Url.[00;38;05;171mprototype[m.format = [00;38;05;171mfunction[m() {
  [00;38;05;171mvar[m auth = [00;38;05;171mthis[m.auth || [00;38;05;196m''[m;
  [00;38;05;171mif[m (auth) {
    auth = [00;38;05;75mencodeURIComponent[m(auth);
    auth = auth.[00;38;05;75mreplace[m([00;38;05;208m/%3A/i[m, [00;38;05;196m':'[m);
    auth += [00;38;05;196m'@'[m;
  }

  [00;38;05;171mvar[m protocol = [00;38;05;171mthis[m.protocol || [00;38;05;196m''[m,
      pathname = [00;38;05;171mthis[m.pathname || [00;38;05;196m''[m,
      hash = [00;38;05;171mthis[m.hash || [00;38;05;196m''[m,
      host = [00;38;05;171mfalse[m,
      query = [00;38;05;196m''[m;

  [00;38;05;171mif[m ([00;38;05;171mthis[m.host) {
    host = auth + [00;38;05;171mthis[m.host;
  } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;171mthis[m.hostname) {
    host = auth + ([00;38;05;171mthis[m.hostname.[00;38;05;75mindexOf[m([00;38;05;196m':'[m) === -1 ?
        [00;38;05;171mthis[m.hostname :
        [00;38;05;196m'['[m + [00;38;05;171mthis[m.hostname + [00;38;05;196m']'[m);
    [00;38;05;171mif[m ([00;38;05;171mthis[m.port) {
      host += [00;38;05;196m':'[m + [00;38;05;171mthis[m.port;
    }
  }

  [00;38;05;171mif[m ([00;38;05;171mthis[m.query &&
      util.[00;38;05;75misObject[m([00;38;05;171mthis[m.query) &&
      Object.[00;38;05;75mkeys[m([00;38;05;171mthis[m.query).length) {
    query = querystring.[00;38;05;75mstringify[m([00;38;05;171mthis[m.query);
  }

  [00;38;05;171mvar[m search = [00;38;05;171mthis[m.search || (query && ([00;38;05;196m'?'[m + query)) || [00;38;05;196m''[m;

  [00;38;05;171mif[m (protocol && protocol.[00;38;05;75msubstr[m(-1) !== [00;38;05;196m':'[m) protocol += [00;38;05;196m':'[m;

  [00;38;05;242m// only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.[m
  [00;38;05;242m// unless they had them to begin with.[m
  [00;38;05;171mif[m ([00;38;05;171mthis[m.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== [00;38;05;171mfalse[m) {
    host = [00;38;05;196m'//'[m + (host || [00;38;05;196m''[m);
    [00;38;05;171mif[m (pathname && pathname.[00;38;05;75mcharAt[m(0) !== [00;38;05;196m'/'[m) pathname = [00;38;05;196m'/'[m + pathname;
  } [00;38;05;171melse[m [00;38;05;171mif[m (!host) {
    host = [00;38;05;196m''[m;
  }

  [00;38;05;171mif[m (hash && hash.[00;38;05;75mcharAt[m(0) !== [00;38;05;196m'#'[m) hash = [00;38;05;196m'#'[m + hash;
  [00;38;05;171mif[m (search && search.[00;38;05;75mcharAt[m(0) !== [00;38;05;196m'?'[m) search = [00;38;05;196m'?'[m + search;

  pathname = pathname.[00;38;05;75mreplace[m([00;38;05;208m/[?#]/g[m, [00;38;05;171mfunction[m(match) {
    [00;38;05;171mreturn[m [00;38;05;75mencodeURIComponent[m(match);
  });
  search = search.[00;38;05;75mreplace[m([00;38;05;196m'#'[m, [00;38;05;196m'%23'[m);

  [00;38;05;171mreturn[m protocol + host + pathname + search + hash;
};

[00;38;05;171mfunction[m [00;38;05;75murlResolve[m(source, relative) {
  [00;38;05;171mreturn[m [00;38;05;75murlParse[m(source, [00;38;05;171mfalse[m, [00;38;05;171mtrue[m).[00;38;05;75mresolve[m(relative);
}

Url.[00;38;05;171mprototype[m.resolve = [00;38;05;171mfunction[m(relative) {
  [00;38;05;171mreturn[m [00;38;05;171mthis[m.[00;38;05;75mresolveObject[m([00;38;05;75murlParse[m(relative, [00;38;05;171mfalse[m, [00;38;05;171mtrue[m)).[00;38;05;75mformat[m();
};

[00;38;05;171mfunction[m [00;38;05;75murlResolveObject[m(source, relative) {
  [00;38;05;171mif[m (!source) [00;38;05;171mreturn[m relative;
  [00;38;05;171mreturn[m [00;38;05;75murlParse[m(source, [00;38;05;171mfalse[m, [00;38;05;171mtrue[m).[00;38;05;75mresolveObject[m(relative);
}

Url.[00;38;05;171mprototype[m.resolveObject = [00;38;05;171mfunction[m(relative) {
  [00;38;05;171mif[m (util.[00;38;05;75misString[m(relative)) {
    [00;38;05;171mvar[m rel = [00;38;05;171mnew[m [00;38;05;75mUrl[m();
    rel.[00;38;05;75mparse[m(relative, [00;38;05;171mfalse[m, [00;38;05;171mtrue[m);
    relative = rel;
  }

  [00;38;05;171mvar[m result = [00;38;05;171mnew[m [00;38;05;75mUrl[m();
  [00;38;05;171mvar[m tkeys = Object.[00;38;05;75mkeys[m([00;38;05;171mthis[m);
  [00;38;05;171mfor[m ([00;38;05;171mvar[m tk = 0; tk < tkeys.length; tk++) {
    [00;38;05;171mvar[m tkey = tkeys[tk];
    result[tkey] = [00;38;05;171mthis[m[tkey];
  }

  [00;38;05;242m// hash is always overridden, no matter what.[m
  [00;38;05;242m// even href="" will remove it.[m
  result.hash = relative.hash;

  [00;38;05;242m// if the relative url is empty, then there's nothing left to do here.[m
  [00;38;05;171mif[m (relative.href === [00;38;05;196m''[m) {
    result.href = result.[00;38;05;75mformat[m();
    [00;38;05;171mreturn[m result;
  }

  [00;38;05;242m// hrefs like //foo/bar always cut to the protocol.[m
  [00;38;05;171mif[m (relative.slashes && !relative.protocol) {
    [00;38;05;242m// take everything except the protocol from relative[m
    [00;38;05;171mvar[m rkeys = Object.[00;38;05;75mkeys[m(relative);
    [00;38;05;171mfor[m ([00;38;05;171mvar[m rk = 0; rk < rkeys.length; rk++) {
      [00;38;05;171mvar[m rkey = rkeys[rk];
      [00;38;05;171mif[m (rkey !== [00;38;05;196m'protocol'[m)
        result[rkey] = relative[rkey];
    }

    [00;38;05;242m//urlParse appends trailing / to urls like http://www.example.com[m
    [00;38;05;171mif[m (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = [00;38;05;196m'/'[m;
    }

    result.href = result.[00;38;05;75mformat[m();
    [00;38;05;171mreturn[m result;
  }

  [00;38;05;171mif[m (relative.protocol && relative.protocol !== result.protocol) {
    [00;38;05;242m// if it's a known url protocol, then changing[m
    [00;38;05;242m// the protocol does weird things[m
    [00;38;05;242m// first, if it's not file:, then we MUST have a host,[m
    [00;38;05;242m// and if there was a path[m
    [00;38;05;242m// to begin with, then we MUST have a path.[m
    [00;38;05;242m// if it is file:, then the host is dropped,[m
    [00;38;05;242m// because that's known to be hostless.[m
    [00;38;05;242m// anything else is assumed to be absolute.[m
    [00;38;05;171mif[m (!slashedProtocol[relative.protocol]) {
      [00;38;05;171mvar[m keys = Object.[00;38;05;75mkeys[m(relative);
      [00;38;05;171mfor[m ([00;38;05;171mvar[m v = 0; v < keys.length; v++) {
        [00;38;05;171mvar[m k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.[00;38;05;75mformat[m();
      [00;38;05;171mreturn[m result;
    }

    result.protocol = relative.protocol;
    [00;38;05;171mif[m (!relative.host && !hostlessProtocol[relative.protocol]) {
      [00;38;05;171mvar[m relPath = (relative.pathname || [00;38;05;196m''[m).[00;38;05;75msplit[m([00;38;05;196m'/'[m);
      [00;38;05;171mwhile[m (relPath.length && !(relative.host = relPath.[00;38;05;75mshift[m()));
      [00;38;05;171mif[m (!relative.host) relative.host = [00;38;05;196m''[m;
      [00;38;05;171mif[m (!relative.hostname) relative.hostname = [00;38;05;196m''[m;
      [00;38;05;171mif[m (relPath[0] !== [00;38;05;196m''[m) relPath.[00;38;05;75munshift[m([00;38;05;196m''[m);
      [00;38;05;171mif[m (relPath.length < 2) relPath.[00;38;05;75munshift[m([00;38;05;196m''[m);
      result.pathname = relPath.[00;38;05;75mjoin[m([00;38;05;196m'/'[m);
    } [00;38;05;171melse[m {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || [00;38;05;196m''[m;
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    [00;38;05;242m// to support http.request[m
    [00;38;05;171mif[m (result.pathname || result.search) {
      [00;38;05;171mvar[m p = result.pathname || [00;38;05;196m''[m;
      [00;38;05;171mvar[m s = result.search || [00;38;05;196m''[m;
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.[00;38;05;75mformat[m();
    [00;38;05;171mreturn[m result;
  }

  [00;38;05;171mvar[m isSourceAbs = (result.pathname && result.pathname.[00;38;05;75mcharAt[m(0) === [00;38;05;196m'/'[m),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.[00;38;05;75mcharAt[m(0) === [00;38;05;196m'/'[m
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.[00;38;05;75msplit[m([00;38;05;196m'/'[m) || [],
      relPath = relative.pathname && relative.pathname.[00;38;05;75msplit[m([00;38;05;196m'/'[m) || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  [00;38;05;242m// if the url is a non-slashed url, then relative[m
  [00;38;05;242m// links like ../.. should be able[m
  [00;38;05;242m// to crawl up to the hostname, as well.  This is strange.[m
  [00;38;05;242m// result.protocol has already been set by now.[m
  [00;38;05;242m// Later on, put the first path part into the host field.[m
  [00;38;05;171mif[m (psychotic) {
    result.hostname = [00;38;05;196m''[m;
    result.port = [00;38;05;171mnull[m;
    [00;38;05;171mif[m (result.host) {
      [00;38;05;171mif[m (srcPath[0] === [00;38;05;196m''[m) srcPath[0] = result.host;
      [00;38;05;171melse[m srcPath.[00;38;05;75munshift[m(result.host);
    }
    result.host = [00;38;05;196m''[m;
    [00;38;05;171mif[m (relative.protocol) {
      relative.hostname = [00;38;05;171mnull[m;
      relative.port = [00;38;05;171mnull[m;
      [00;38;05;171mif[m (relative.host) {
        [00;38;05;171mif[m (relPath[0] === [00;38;05;196m''[m) relPath[0] = relative.host;
        [00;38;05;171melse[m relPath.[00;38;05;75munshift[m(relative.host);
      }
      relative.host = [00;38;05;171mnull[m;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === [00;38;05;196m''[m || srcPath[0] === [00;38;05;196m''[m);
  }

  [00;38;05;171mif[m (isRelAbs) {
    [00;38;05;242m// it's absolute.[m
    result.host = (relative.host || relative.host === [00;38;05;196m''[m) ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === [00;38;05;196m''[m) ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    [00;38;05;242m// fall through to the dot-handling below.[m
  } [00;38;05;171melse[m [00;38;05;171mif[m (relPath.length) {
    [00;38;05;242m// it's relative[m
    [00;38;05;242m// throw away the existing file, and take the new path instead.[m
    [00;38;05;171mif[m (!srcPath) srcPath = [];
    srcPath.[00;38;05;75mpop[m();
    srcPath = srcPath.[00;38;05;75mconcat[m(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } [00;38;05;171melse[m [00;38;05;171mif[m (!util.[00;38;05;75misNullOrUndefined[m(relative.search)) {
    [00;38;05;242m// just pull out the search.[m
    [00;38;05;242m// like href='?foo'.[m
    [00;38;05;242m// Put this after the other two cases because it simplifies the booleans[m
    [00;38;05;171mif[m (psychotic) {
      result.hostname = result.host = srcPath.[00;38;05;75mshift[m();
      [00;38;05;242m//occationaly the auth can get stuck only in host[m
      [00;38;05;242m//this especially happens in cases like[m
      [00;38;05;242m//url.resolveObject('mailto:local1@domain1', 'local2@domain2')[m
      [00;38;05;171mvar[m authInHost = result.host && result.host.[00;38;05;75mindexOf[m([00;38;05;196m'@'[m) > 0 ?
                       result.host.[00;38;05;75msplit[m([00;38;05;196m'@'[m) : [00;38;05;171mfalse[m;
      [00;38;05;171mif[m (authInHost) {
        result.auth = authInHost.[00;38;05;75mshift[m();
        result.host = result.hostname = authInHost.[00;38;05;75mshift[m();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    [00;38;05;242m//to support http.request[m
    [00;38;05;171mif[m (!util.[00;38;05;75misNull[m(result.pathname) || !util.[00;38;05;75misNull[m(result.search)) {
      result.path = (result.pathname ? result.pathname : [00;38;05;196m''[m) +
                    (result.search ? result.search : [00;38;05;196m''[m);
    }
    result.href = result.[00;38;05;75mformat[m();
    [00;38;05;171mreturn[m result;
  }

  [00;38;05;171mif[m (!srcPath.length) {
    [00;38;05;242m// no path at all.  easy.[m
    [00;38;05;242m// we've already handled the other stuff above.[m
    result.pathname = [00;38;05;171mnull[m;
    [00;38;05;242m//to support http.request[m
    [00;38;05;171mif[m (result.search) {
      result.path = [00;38;05;196m'/'[m + result.search;
    } [00;38;05;171melse[m {
      result.path = [00;38;05;171mnull[m;
    }
    result.href = result.[00;38;05;75mformat[m();
    [00;38;05;171mreturn[m result;
  }

  [00;38;05;242m// if a url ENDs in . or .., then it must get a trailing slash.[m
  [00;38;05;242m// however, if it ends in anything else non-slashy,[m
  [00;38;05;242m// then it must NOT get a trailing slash.[m
  [00;38;05;171mvar[m last = srcPath.[00;38;05;75mslice[m(-1)[0];
  [00;38;05;171mvar[m hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === [00;38;05;196m'.'[m || last === [00;38;05;196m'..'[m) || last === [00;38;05;196m''[m);

  [00;38;05;242m// strip single dots, resolve double dots to parent dir[m
  [00;38;05;242m// if the path tries to go above the root, `up` ends up > 0[m
  [00;38;05;171mvar[m up = 0;
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    [00;38;05;171mif[m (last === [00;38;05;196m'.'[m) {
      srcPath.[00;38;05;75msplice[m(i, 1);
    } [00;38;05;171melse[m [00;38;05;171mif[m (last === [00;38;05;196m'..'[m) {
      srcPath.[00;38;05;75msplice[m(i, 1);
      up++;
    } [00;38;05;171melse[m [00;38;05;171mif[m (up) {
      srcPath.[00;38;05;75msplice[m(i, 1);
      up--;
    }
  }

  [00;38;05;242m// if the path is allowed to go above the root, restore leading ..s[m
  [00;38;05;171mif[m (!mustEndAbs && !removeAllDots) {
    [00;38;05;171mfor[m (; up--; up) {
      srcPath.[00;38;05;75munshift[m([00;38;05;196m'..'[m);
    }
  }

  [00;38;05;171mif[m (mustEndAbs && srcPath[0] !== [00;38;05;196m''[m &&
      (!srcPath[0] || srcPath[0].[00;38;05;75mcharAt[m(0) !== [00;38;05;196m'/'[m)) {
    srcPath.[00;38;05;75munshift[m([00;38;05;196m''[m);
  }

  [00;38;05;171mif[m (hasTrailingSlash && (srcPath.[00;38;05;75mjoin[m([00;38;05;196m'/'[m).[00;38;05;75msubstr[m(-1) !== [00;38;05;196m'/'[m)) {
    srcPath.[00;38;05;75mpush[m([00;38;05;196m''[m);
  }

  [00;38;05;171mvar[m isAbsolute = srcPath[0] === [00;38;05;196m''[m ||
      (srcPath[0] && srcPath[0].[00;38;05;75mcharAt[m(0) === [00;38;05;196m'/'[m);

  [00;38;05;242m// put the host back[m
  [00;38;05;171mif[m (psychotic) {
    result.hostname = result.host = isAbsolute ? [00;38;05;196m''[m :
                                    srcPath.length ? srcPath.[00;38;05;75mshift[m() : [00;38;05;196m''[m;
    [00;38;05;242m//occationaly the auth can get stuck only in host[m
    [00;38;05;242m//this especially happens in cases like[m
    [00;38;05;242m//url.resolveObject('mailto:local1@domain1', 'local2@domain2')[m
    [00;38;05;171mvar[m authInHost = result.host && result.host.[00;38;05;75mindexOf[m([00;38;05;196m'@'[m) > 0 ?
                     result.host.[00;38;05;75msplit[m([00;38;05;196m'@'[m) : [00;38;05;171mfalse[m;
    [00;38;05;171mif[m (authInHost) {
      result.auth = authInHost.[00;38;05;75mshift[m();
      result.host = result.hostname = authInHost.[00;38;05;75mshift[m();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  [00;38;05;171mif[m (mustEndAbs && !isAbsolute) {
    srcPath.[00;38;05;75munshift[m([00;38;05;196m''[m);
  }

  [00;38;05;171mif[m (!srcPath.length) {
    result.pathname = [00;38;05;171mnull[m;
    result.path = [00;38;05;171mnull[m;
  } [00;38;05;171melse[m {
    result.pathname = srcPath.[00;38;05;75mjoin[m([00;38;05;196m'/'[m);
  }

  [00;38;05;242m//to support request.http[m
  [00;38;05;171mif[m (!util.[00;38;05;75misNull[m(result.pathname) || !util.[00;38;05;75misNull[m(result.search)) {
    result.path = (result.pathname ? result.pathname : [00;38;05;196m''[m) +
                  (result.search ? result.search : [00;38;05;196m''[m);
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.[00;38;05;75mformat[m();
  [00;38;05;171mreturn[m result;
};

Url.[00;38;05;171mprototype[m.parseHost = [00;38;05;171mfunction[m() {
  [00;38;05;171mvar[m host = [00;38;05;171mthis[m.host;
  [00;38;05;171mvar[m port = portPattern.[00;38;05;75mexec[m(host);
  [00;38;05;171mif[m (port) {
    port = port[0];
    [00;38;05;171mif[m (port !== [00;38;05;196m':'[m) {
      [00;38;05;171mthis[m.port = port.[00;38;05;75msubstr[m(1);
    }
    host = host.[00;38;05;75msubstr[m(0, host.length - port.length);
  }
  [00;38;05;171mif[m (host) [00;38;05;171mthis[m.hostname = host;
};


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 20 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(process) {[00;38;05;171mvar[m original = [00;38;05;75m__webpack_require__[m(26)
  , parse = [00;38;05;75m__webpack_require__[m(19).parse
  , events = [00;38;05;75m__webpack_require__[m(7)
  , https = [00;38;05;75m__webpack_require__[m(24)
  , http = [00;38;05;75m__webpack_require__[m(15)
  , util = [00;38;05;75m__webpack_require__[m(45);

[00;38;05;242m/**[m
[00;38;05;242m * Creates a new EventSource object[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {String} url the URL to which to connect[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {Object} [eventSourceInitDict] extra init params. See README for details.[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m public[m
[00;38;05;242m **/[m
[00;38;05;171mfunction[m [00;38;05;75mEventSource[m(url, eventSourceInitDict) {
  [00;38;05;171mvar[m readyState = EventSource.CONNECTING;
  Object.[00;38;05;75mdefineProperty[m([00;38;05;171mthis[m, [00;38;05;196m'readyState'[m, {
    get: [00;38;05;171mfunction[m () {
      [00;38;05;171mreturn[m readyState;
    }
  });

  Object.[00;38;05;75mdefineProperty[m([00;38;05;171mthis[m, [00;38;05;196m'url'[m, {
    get: [00;38;05;171mfunction[m () {
      [00;38;05;171mreturn[m url;
    }
  });

  [00;38;05;171mvar[m self = [00;38;05;171mthis[m;
  self.reconnectInterval = 1000;

  [00;38;05;171mfunction[m [00;38;05;75monConnectionClosed[m() {
    [00;38;05;171mif[m (readyState === EventSource.CLOSED) [00;38;05;171mreturn[m;
    readyState = EventSource.CONNECTING;
    [00;38;05;75m_emit[m([00;38;05;196m'error'[m, [00;38;05;171mnew[m [00;38;05;75mEvent[m([00;38;05;196m'error'[m));

    [00;38;05;242m// The url may have been changed by a temporary[m
    [00;38;05;242m// redirect. If that's the case, revert it now.[m
    [00;38;05;171mif[m (reconnectUrl) {
      url = reconnectUrl;
      reconnectUrl = [00;38;05;171mnull[m;
    }
    [00;38;05;75msetTimeout[m([00;38;05;171mfunction[m () {
      [00;38;05;171mif[m (readyState !== EventSource.CONNECTING) {
        [00;38;05;171mreturn[m;
      }
      [00;38;05;75mconnect[m();
    }, self.reconnectInterval);
  }

  [00;38;05;171mvar[m req;
  [00;38;05;171mvar[m lastEventId = [00;38;05;196m''[m;
  [00;38;05;171mif[m (eventSourceInitDict && eventSourceInitDict.headers && eventSourceInitDict.headers[[00;38;05;196m'Last-Event-ID'[m]) {
    lastEventId = eventSourceInitDict.headers[[00;38;05;196m'Last-Event-ID'[m];
    [00;38;05;171mdelete[m eventSourceInitDict.headers[[00;38;05;196m'Last-Event-ID'[m];
  }

  [00;38;05;171mvar[m discardTrailingNewline = [00;38;05;171mfalse[m
    , data = [00;38;05;196m''[m
    , eventName = [00;38;05;196m''[m;

  [00;38;05;171mvar[m reconnectUrl = [00;38;05;171mnull[m;

  [00;38;05;171mfunction[m [00;38;05;75mconnect[m() {

    [00;38;05;171mvar[m options = [00;38;05;75mparse[m(url);
    [00;38;05;171mvar[m isSecure = options.protocol == [00;38;05;196m'https:'[m;
    options.headers = { [00;38;05;196m'Cache-Control'[m: [00;38;05;196m'no-cache'[m, [00;38;05;196m'Accept'[m: [00;38;05;196m'text/event-stream'[m };
    [00;38;05;171mif[m (lastEventId) options.headers[[00;38;05;196m'Last-Event-ID'[m] = lastEventId;
    [00;38;05;171mif[m (eventSourceInitDict && eventSourceInitDict.headers) {
      [00;38;05;171mfor[m ([00;38;05;171mvar[m i [00;38;05;171min[m eventSourceInitDict.headers) {
        [00;38;05;171mvar[m header = eventSourceInitDict.headers[i];
        [00;38;05;171mif[m (header) {
          options.headers[i] = header;
        }
      }
    }

    options.rejectUnauthorized = !(eventSourceInitDict && eventSourceInitDict.rejectUnauthorized == [00;38;05;171mfalse[m);

    [00;38;05;242m// If specify http proxy, make the request to sent to the proxy server,[m
    [00;38;05;242m// and include the original url in path and Host headers[m
    [00;38;05;171mif[m (eventSourceInitDict && eventSourceInitDict.proxy) {
        [00;38;05;171mvar[m proxy = [00;38;05;75mparse[m(eventSourceInitDict.proxy);
        options.path = url;
        options.headers.Host = options.host;
        options.hostname = proxy.hostname;
        options.host = proxy.host;
        options.port = proxy.port;
    }

    req = (isSecure ? https : http).[00;38;05;75mrequest[m(options, [00;38;05;171mfunction[m (res) {
      [00;38;05;242m// Handle HTTP redirects[m
      [00;38;05;171mif[m (res.statusCode == 301 || res.statusCode == 307) {
        [00;38;05;171mif[m (!res.headers.location) {
          [00;38;05;242m// Server sent redirect response without Location header.[m
          [00;38;05;75m_emit[m([00;38;05;196m'error'[m, [00;38;05;171mnew[m [00;38;05;75mEvent[m([00;38;05;196m'error'[m, {status: res.statusCode}));
          [00;38;05;171mreturn[m;
        }
        [00;38;05;171mif[m (res.statusCode == 307) reconnectUrl = url;
        url = res.headers.location;
        process.[00;38;05;75mnextTick[m(connect);
        [00;38;05;171mreturn[m;
      }

      [00;38;05;171mif[m (res.statusCode !== 200) {
        [00;38;05;75m_emit[m([00;38;05;196m'error'[m, [00;38;05;171mnew[m [00;38;05;75mEvent[m([00;38;05;196m'error'[m, {status: res.statusCode}));
        [00;38;05;171mif[m (res.statusCode == 204) [00;38;05;171mreturn[m self.[00;38;05;75mclose[m();
        [00;38;05;171mreturn[m
      }

      readyState = EventSource.OPEN;
      res.[00;38;05;75mon[m([00;38;05;196m'close'[m, [00;38;05;171mfunction[m() {
        res.[00;38;05;75mremoveAllListeners[m([00;38;05;196m'close'[m);
        res.[00;38;05;75mremoveAllListeners[m([00;38;05;196m'end'[m);
        [00;38;05;75monConnectionClosed[m();
      });

      res.[00;38;05;75mon[m([00;38;05;196m'end'[m, [00;38;05;171mfunction[m() {
        res.[00;38;05;75mremoveAllListeners[m([00;38;05;196m'close'[m);
        res.[00;38;05;75mremoveAllListeners[m([00;38;05;196m'end'[m);
        [00;38;05;75monConnectionClosed[m();
      });
      [00;38;05;75m_emit[m([00;38;05;196m'open'[m, [00;38;05;171mnew[m [00;38;05;75mEvent[m([00;38;05;196m'open'[m));

      [00;38;05;242m// text/event-stream parser adapted from webkit's[m
      [00;38;05;242m// Source/WebCore/page/EventSource.cpp[m
      [00;38;05;171mvar[m buf = [00;38;05;196m''[m;
      res.[00;38;05;75mon[m([00;38;05;196m'data'[m, [00;38;05;171mfunction[m (chunk) {
        buf += chunk;

        [00;38;05;171mvar[m pos = 0
          , length = buf.length;
        [00;38;05;171mwhile[m (pos < length) {
          [00;38;05;171mif[m (discardTrailingNewline) {
            [00;38;05;171mif[m (buf[pos] === [00;38;05;196m'[m\n[00;38;05;196m'[m) {
              ++pos;
            }
            discardTrailingNewline = [00;38;05;171mfalse[m;
          }

          [00;38;05;171mvar[m lineLength = -1
            , fieldLength = -1
            , c;

          [00;38;05;171mfor[m ([00;38;05;171mvar[m i = pos; lineLength < 0 && i < length; ++i) {
            c = buf[i];
            [00;38;05;171mif[m (c === [00;38;05;196m':'[m) {
              [00;38;05;171mif[m (fieldLength < 0) {
                fieldLength = i - pos;
              }
            } [00;38;05;171melse[m [00;38;05;171mif[m (c === [00;38;05;196m'[m\r[00;38;05;196m'[m) {
              discardTrailingNewline = [00;38;05;171mtrue[m;
              lineLength = i - pos;
            } [00;38;05;171melse[m [00;38;05;171mif[m (c === [00;38;05;196m'[m\n[00;38;05;196m'[m) {
              lineLength = i - pos;
            }
          }

          [00;38;05;171mif[m (lineLength < 0) {
            [00;38;05;171mbreak[m;
          }

          [00;38;05;75mparseEventStreamLine[m(buf, pos, fieldLength, lineLength);

          pos += lineLength + 1;
        }

        [00;38;05;171mif[m (pos === length) {
          buf = [00;38;05;196m''[m;
        } [00;38;05;171melse[m [00;38;05;171mif[m (pos > 0) {
          buf = buf.[00;38;05;75mslice[m(pos);
        }
      });
    });

    req.[00;38;05;75mon[m([00;38;05;196m'error'[m, onConnectionClosed);
    [00;38;05;171mif[m (req.setNoDelay) req.[00;38;05;75msetNoDelay[m([00;38;05;171mtrue[m);
    req.[00;38;05;75mend[m();
  }

  [00;38;05;75mconnect[m();

  [00;38;05;171mfunction[m [00;38;05;75m_emit[m() {
    [00;38;05;171mif[m (self.[00;38;05;75mlisteners[m(arguments[0]).length > 0) {
      self.emit.[00;38;05;75mapply[m(self, arguments);
    }
  }

  [00;38;05;171mthis[m.close = [00;38;05;171mfunction[m () {
    [00;38;05;171mif[m (readyState == EventSource.CLOSED) [00;38;05;171mreturn[m;
    readyState = EventSource.CLOSED;
    [00;38;05;171mif[m (req.abort) req.[00;38;05;75mabort[m();
    [00;38;05;171mif[m (req.xhr && req.xhr.abort) req.xhr.[00;38;05;75mabort[m();
  };

  [00;38;05;171mfunction[m [00;38;05;75mparseEventStreamLine[m(buf, pos, fieldLength, lineLength) {
    [00;38;05;171mif[m (lineLength === 0) {
      [00;38;05;171mif[m (data.length > 0) {
        [00;38;05;171mvar[m type = eventName || [00;38;05;196m'message'[m;
        [00;38;05;75m_emit[m(type, [00;38;05;171mnew[m [00;38;05;75mMessageEvent[m(type, {
          data: data.[00;38;05;75mslice[m(0, -1), [00;38;05;242m// remove trailing newline[m
          lastEventId: lastEventId,
          origin: [00;38;05;75moriginal[m(url)
        }));
        data = [00;38;05;196m''[m;
      }
      eventName = void 0;
    } [00;38;05;171melse[m [00;38;05;171mif[m (fieldLength > 0) {
      [00;38;05;171mvar[m noValue = fieldLength < 0
        , step = 0
        , field = buf.[00;38;05;75mslice[m(pos, pos + (noValue ? lineLength : fieldLength));

      [00;38;05;171mif[m (noValue) {
        step = lineLength;
      } [00;38;05;171melse[m [00;38;05;171mif[m (buf[pos + fieldLength + 1] !== [00;38;05;196m' '[m) {
        step = fieldLength + 1;
      } [00;38;05;171melse[m {
        step = fieldLength + 2;
      }
      pos += step;
      [00;38;05;171mvar[m valueLength = lineLength - step
        , value = buf.[00;38;05;75mslice[m(pos, pos + valueLength);

      [00;38;05;171mif[m (field === [00;38;05;196m'data'[m) {
        data += value + [00;38;05;196m'[m\n[00;38;05;196m'[m;
      } [00;38;05;171melse[m [00;38;05;171mif[m (field === [00;38;05;196m'event'[m) {
        eventName = value;
      } [00;38;05;171melse[m [00;38;05;171mif[m (field === [00;38;05;196m'id'[m) {
        lastEventId = value;
      } [00;38;05;171melse[m [00;38;05;171mif[m (field === [00;38;05;196m'retry'[m) {
        [00;38;05;171mvar[m retry = [00;38;05;75mparseInt[m(value, 10);
        [00;38;05;171mif[m (!Number.[00;38;05;75misNaN[m(retry)) {
          self.reconnectInterval = retry;
        }
      }
    }
  }
}

module.exports = EventSource;

util.[00;38;05;75minherits[m(EventSource, events.EventEmitter);
EventSource.[00;38;05;171mprototype[m.constructor = EventSource; [00;38;05;242m// make stacktraces readable[m

[[00;38;05;196m'open'[m, [00;38;05;196m'error'[m, [00;38;05;196m'message'[m].[00;38;05;75mforEach[m([00;38;05;171mfunction[m (method) {
  Object.[00;38;05;75mdefineProperty[m(EventSource.[00;38;05;171mprototype[m, [00;38;05;196m'on'[m + method, {
    [00;38;05;242m/**[m
[00;38;05;242m     * Returns the current listener[m
[00;38;05;242m     *[m
[00;38;05;242m     * [m[00;38;05;70m@return[m[00;38;05;242m {Mixed} the set function or undefined[m
[00;38;05;242m     * [m[00;38;05;70m@api[m[00;38;05;242m private[m
[00;38;05;242m     */[m
    get: [00;38;05;171mfunction[m [00;38;05;75mget[m() {
      [00;38;05;171mvar[m listener = [00;38;05;171mthis[m.[00;38;05;75mlisteners[m(method)[0];
      [00;38;05;171mreturn[m listener ? (listener._listener ? listener._listener : listener) : undefined;
    },

    [00;38;05;242m/**[m
[00;38;05;242m     * Start listening for events[m
[00;38;05;242m     *[m
[00;38;05;242m     * [m[00;38;05;70m@param[m[00;38;05;242m {Function} listener the listener[m
[00;38;05;242m     * [m[00;38;05;70m@return[m[00;38;05;242m {Mixed} the set function or undefined[m
[00;38;05;242m     * [m[00;38;05;70m@api[m[00;38;05;242m private[m
[00;38;05;242m     */[m
    set: [00;38;05;171mfunction[m [00;38;05;75mset[m(listener) {
      [00;38;05;171mthis[m.[00;38;05;75mremoveAllListeners[m(method);
      [00;38;05;171mthis[m.[00;38;05;75maddEventListener[m(method, listener);
    }
  });
});

[00;38;05;242m/**[m
[00;38;05;242m * Ready states[m
[00;38;05;242m */[m
Object.[00;38;05;75mdefineProperty[m(EventSource, [00;38;05;196m'CONNECTING'[m, { enumerable: [00;38;05;171mtrue[m, value: 0});
Object.[00;38;05;75mdefineProperty[m(EventSource, [00;38;05;196m'OPEN'[m, { enumerable: [00;38;05;171mtrue[m, value: 1});
Object.[00;38;05;75mdefineProperty[m(EventSource, [00;38;05;196m'CLOSED'[m, { enumerable: [00;38;05;171mtrue[m, value: 2});

[00;38;05;242m/**[m
[00;38;05;242m * Emulates the W3C Browser based WebSocket interface using addEventListener.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {String} method Listen for an event[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {Function} listener callback[m
[00;38;05;242m * [m[00;38;05;70m@see[m[00;38;05;242m [m[00;38;05;75mhttps://developer.mozilla.org/en/DOM/element.addEventListener[m
[00;38;05;242m * [m[00;38;05;70m@see[m[00;38;05;242m [m[00;38;05;75mhttp://dev.w3.org/html5/websockets/[m[00;38;05;242m#the-websocket-interface[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m public[m
[00;38;05;242m */[m
EventSource.[00;38;05;171mprototype[m.addEventListener = [00;38;05;171mfunction[m [00;38;05;75maddEventListener[m(method, listener) {
  [00;38;05;171mif[m ([00;38;05;171mtypeof[m listener === [00;38;05;196m'function'[m) {
    [00;38;05;242m// store a reference so we can return the original function again[m
    listener._listener = listener;
    [00;38;05;171mthis[m.[00;38;05;75mon[m(method, listener);
  }
};

[00;38;05;242m/**[m
[00;38;05;242m * W3C Event[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@see[m[00;38;05;242m [m[00;38;05;75mhttp://www.w3.org/TR/DOM-Level-3-Events/[m[00;38;05;242m#interface-Event[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m private[m
[00;38;05;242m */[m
[00;38;05;171mfunction[m [00;38;05;75mEvent[m(type, optionalProperties) {
  Object.[00;38;05;75mdefineProperty[m([00;38;05;171mthis[m, [00;38;05;196m'type'[m, { writable: [00;38;05;171mfalse[m, value: type, enumerable: [00;38;05;171mtrue[m });
  [00;38;05;171mif[m (optionalProperties) {
    [00;38;05;171mfor[m ([00;38;05;171mvar[m f [00;38;05;171min[m optionalProperties) {
      [00;38;05;171mif[m (optionalProperties.[00;38;05;75mhasOwnProperty[m(f)) {
        Object.[00;38;05;75mdefineProperty[m([00;38;05;171mthis[m, f, { writable: [00;38;05;171mfalse[m, value: optionalProperties[f], enumerable: [00;38;05;171mtrue[m });
      }
    }
  }
}

[00;38;05;242m/**[m
[00;38;05;242m * W3C MessageEvent[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@see[m[00;38;05;242m [m[00;38;05;75mhttp://www.w3.org/TR/webmessaging/[m[00;38;05;242m#event-definitions[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m private[m
[00;38;05;242m */[m
[00;38;05;171mfunction[m [00;38;05;75mMessageEvent[m(type, eventInitDict) {
  Object.[00;38;05;75mdefineProperty[m([00;38;05;171mthis[m, [00;38;05;196m'type'[m, { writable: [00;38;05;171mfalse[m, value: type, enumerable: [00;38;05;171mtrue[m });
  [00;38;05;171mfor[m ([00;38;05;171mvar[m f [00;38;05;171min[m eventInitDict) {
    [00;38;05;171mif[m (eventInitDict.[00;38;05;75mhasOwnProperty[m(f)) {
      Object.[00;38;05;75mdefineProperty[m([00;38;05;171mthis[m, f, { writable: [00;38;05;171mfalse[m, value: eventInitDict[f], enumerable: [00;38;05;171mtrue[m });
    }
  }
}

[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(2)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 21 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

window.EventSourcePolyfill = [00;38;05;75m__webpack_require__[m(20);
window.EventSource = window.EventSource || window.EventSourcePolyfill


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 22 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

[00;38;05;171mvar[m lookup = []
[00;38;05;171mvar[m revLookup = []
[00;38;05;171mvar[m Arr = [00;38;05;171mtypeof[m Uint8Array !== [00;38;05;196m'undefined'[m ? Uint8Array : Array

[00;38;05;171mvar[m code = [00;38;05;196m'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'[m
[00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.[00;38;05;75mcharCodeAt[m(i)] = i
}

revLookup[[00;38;05;196m'-'[m.[00;38;05;75mcharCodeAt[m(0)] = 62
revLookup[[00;38;05;196m'_'[m.[00;38;05;75mcharCodeAt[m(0)] = 63

[00;38;05;171mfunction[m [00;38;05;75mplaceHoldersCount[m (b64) {
  [00;38;05;171mvar[m len = b64.length
  [00;38;05;171mif[m (len % 4 > 0) {
    [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'Invalid string. Length must be a multiple of 4'[m)
  }

  [00;38;05;242m// the number of equal signs (place holders)[m
  [00;38;05;242m// if there are two placeholders, than the two characters before it[m
  [00;38;05;242m// represent one byte[m
  [00;38;05;242m// if there is only one, then the three characters before it represent 2 bytes[m
  [00;38;05;242m// this is just a cheap hack to not do indexOf twice[m
  [00;38;05;171mreturn[m b64[len - 2] === [00;38;05;196m'='[m ? 2 : b64[len - 1] === [00;38;05;196m'='[m ? 1 : 0
}

[00;38;05;171mfunction[m [00;38;05;75mbyteLength[m (b64) {
  [00;38;05;242m// base64 is 4/3 + up to two characters of the original data[m
  [00;38;05;171mreturn[m b64.length * 3 / 4 - [00;38;05;75mplaceHoldersCount[m(b64)
}

[00;38;05;171mfunction[m [00;38;05;75mtoByteArray[m (b64) {
  [00;38;05;171mvar[m i, j, l, tmp, placeHolders, arr
  [00;38;05;171mvar[m len = b64.length
  placeHolders = [00;38;05;75mplaceHoldersCount[m(b64)

  arr = [00;38;05;171mnew[m [00;38;05;75mArr[m(len * 3 / 4 - placeHolders)

  [00;38;05;242m// if there are placeholders, only get up to the last complete 4 chars[m
  l = placeHolders > 0 ? len - 4 : len

  [00;38;05;171mvar[m L = 0

  [00;38;05;171mfor[m (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.[00;38;05;75mcharCodeAt[m(i)] << 18) | (revLookup[b64.[00;38;05;75mcharCodeAt[m(i + 1)] << 12) | (revLookup[b64.[00;38;05;75mcharCodeAt[m(i + 2)] << 6) | revLookup[b64.[00;38;05;75mcharCodeAt[m(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  [00;38;05;171mif[m (placeHolders === 2) {
    tmp = (revLookup[b64.[00;38;05;75mcharCodeAt[m(i)] << 2) | (revLookup[b64.[00;38;05;75mcharCodeAt[m(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } [00;38;05;171melse[m [00;38;05;171mif[m (placeHolders === 1) {
    tmp = (revLookup[b64.[00;38;05;75mcharCodeAt[m(i)] << 10) | (revLookup[b64.[00;38;05;75mcharCodeAt[m(i + 1)] << 4) | (revLookup[b64.[00;38;05;75mcharCodeAt[m(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  [00;38;05;171mreturn[m arr
}

[00;38;05;171mfunction[m [00;38;05;75mtripletToBase64[m (num) {
  [00;38;05;171mreturn[m lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

[00;38;05;171mfunction[m [00;38;05;75mencodeChunk[m (uint8, start, end) {
  [00;38;05;171mvar[m tmp
  [00;38;05;171mvar[m output = []
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.[00;38;05;75mpush[m([00;38;05;75mtripletToBase64[m(tmp))
  }
  [00;38;05;171mreturn[m output.[00;38;05;75mjoin[m([00;38;05;196m''[m)
}

[00;38;05;171mfunction[m [00;38;05;75mfromByteArray[m (uint8) {
  [00;38;05;171mvar[m tmp
  [00;38;05;171mvar[m len = uint8.length
  [00;38;05;171mvar[m extraBytes = len % 3 [00;38;05;242m// if we have 1 byte left, pad 2 bytes[m
  [00;38;05;171mvar[m output = [00;38;05;196m''[m
  [00;38;05;171mvar[m parts = []
  [00;38;05;171mvar[m maxChunkLength = 16383 [00;38;05;242m// must be multiple of 3[m

  [00;38;05;242m// go through the array every three bytes, we'll deal with trailing stuff later[m
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.[00;38;05;75mpush[m([00;38;05;75mencodeChunk[m(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  [00;38;05;242m// pad the end with zeros, but make sure to not forget the extra bytes[m
  [00;38;05;171mif[m (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += [00;38;05;196m'=='[m
  } [00;38;05;171melse[m [00;38;05;171mif[m (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += [00;38;05;196m'='[m
  }

  parts.[00;38;05;75mpush[m(output)

  [00;38;05;171mreturn[m parts.[00;38;05;75mjoin[m([00;38;05;196m''[m)
}


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 23 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports) {

module.exports = {
  [00;38;05;196m"100"[m: [00;38;05;196m"Continue"[m,
  [00;38;05;196m"101"[m: [00;38;05;196m"Switching Protocols"[m,
  [00;38;05;196m"102"[m: [00;38;05;196m"Processing"[m,
  [00;38;05;196m"200"[m: [00;38;05;196m"OK"[m,
  [00;38;05;196m"201"[m: [00;38;05;196m"Created"[m,
  [00;38;05;196m"202"[m: [00;38;05;196m"Accepted"[m,
  [00;38;05;196m"203"[m: [00;38;05;196m"Non-Authoritative Information"[m,
  [00;38;05;196m"204"[m: [00;38;05;196m"No Content"[m,
  [00;38;05;196m"205"[m: [00;38;05;196m"Reset Content"[m,
  [00;38;05;196m"206"[m: [00;38;05;196m"Partial Content"[m,
  [00;38;05;196m"207"[m: [00;38;05;196m"Multi-Status"[m,
  [00;38;05;196m"208"[m: [00;38;05;196m"Already Reported"[m,
  [00;38;05;196m"226"[m: [00;38;05;196m"IM Used"[m,
  [00;38;05;196m"300"[m: [00;38;05;196m"Multiple Choices"[m,
  [00;38;05;196m"301"[m: [00;38;05;196m"Moved Permanently"[m,
  [00;38;05;196m"302"[m: [00;38;05;196m"Found"[m,
  [00;38;05;196m"303"[m: [00;38;05;196m"See Other"[m,
  [00;38;05;196m"304"[m: [00;38;05;196m"Not Modified"[m,
  [00;38;05;196m"305"[m: [00;38;05;196m"Use Proxy"[m,
  [00;38;05;196m"307"[m: [00;38;05;196m"Temporary Redirect"[m,
  [00;38;05;196m"308"[m: [00;38;05;196m"Permanent Redirect"[m,
  [00;38;05;196m"400"[m: [00;38;05;196m"Bad Request"[m,
  [00;38;05;196m"401"[m: [00;38;05;196m"Unauthorized"[m,
  [00;38;05;196m"402"[m: [00;38;05;196m"Payment Required"[m,
  [00;38;05;196m"403"[m: [00;38;05;196m"Forbidden"[m,
  [00;38;05;196m"404"[m: [00;38;05;196m"Not Found"[m,
  [00;38;05;196m"405"[m: [00;38;05;196m"Method Not Allowed"[m,
  [00;38;05;196m"406"[m: [00;38;05;196m"Not Acceptable"[m,
  [00;38;05;196m"407"[m: [00;38;05;196m"Proxy Authentication Required"[m,
  [00;38;05;196m"408"[m: [00;38;05;196m"Request Timeout"[m,
  [00;38;05;196m"409"[m: [00;38;05;196m"Conflict"[m,
  [00;38;05;196m"410"[m: [00;38;05;196m"Gone"[m,
  [00;38;05;196m"411"[m: [00;38;05;196m"Length Required"[m,
  [00;38;05;196m"412"[m: [00;38;05;196m"Precondition Failed"[m,
  [00;38;05;196m"413"[m: [00;38;05;196m"Payload Too Large"[m,
  [00;38;05;196m"414"[m: [00;38;05;196m"URI Too Long"[m,
  [00;38;05;196m"415"[m: [00;38;05;196m"Unsupported Media Type"[m,
  [00;38;05;196m"416"[m: [00;38;05;196m"Range Not Satisfiable"[m,
  [00;38;05;196m"417"[m: [00;38;05;196m"Expectation Failed"[m,
  [00;38;05;196m"418"[m: [00;38;05;196m"I'm a teapot"[m,
  [00;38;05;196m"421"[m: [00;38;05;196m"Misdirected Request"[m,
  [00;38;05;196m"422"[m: [00;38;05;196m"Unprocessable Entity"[m,
  [00;38;05;196m"423"[m: [00;38;05;196m"Locked"[m,
  [00;38;05;196m"424"[m: [00;38;05;196m"Failed Dependency"[m,
  [00;38;05;196m"425"[m: [00;38;05;196m"Unordered Collection"[m,
  [00;38;05;196m"426"[m: [00;38;05;196m"Upgrade Required"[m,
  [00;38;05;196m"428"[m: [00;38;05;196m"Precondition Required"[m,
  [00;38;05;196m"429"[m: [00;38;05;196m"Too Many Requests"[m,
  [00;38;05;196m"431"[m: [00;38;05;196m"Request Header Fields Too Large"[m,
  [00;38;05;196m"451"[m: [00;38;05;196m"Unavailable For Legal Reasons"[m,
  [00;38;05;196m"500"[m: [00;38;05;196m"Internal Server Error"[m,
  [00;38;05;196m"501"[m: [00;38;05;196m"Not Implemented"[m,
  [00;38;05;196m"502"[m: [00;38;05;196m"Bad Gateway"[m,
  [00;38;05;196m"503"[m: [00;38;05;196m"Service Unavailable"[m,
  [00;38;05;196m"504"[m: [00;38;05;196m"Gateway Timeout"[m,
  [00;38;05;196m"505"[m: [00;38;05;196m"HTTP Version Not Supported"[m,
  [00;38;05;196m"506"[m: [00;38;05;196m"Variant Also Negotiates"[m,
  [00;38;05;196m"507"[m: [00;38;05;196m"Insufficient Storage"[m,
  [00;38;05;196m"508"[m: [00;38;05;196m"Loop Detected"[m,
  [00;38;05;196m"509"[m: [00;38;05;196m"Bandwidth Limit Exceeded"[m,
  [00;38;05;196m"510"[m: [00;38;05;196m"Not Extended"[m,
  [00;38;05;196m"511"[m: [00;38;05;196m"Network Authentication Required"[m
}


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 24 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;171mvar[m http = [00;38;05;75m__webpack_require__[m(15);

[00;38;05;171mvar[m https = module.exports;

[00;38;05;171mfor[m ([00;38;05;171mvar[m key [00;38;05;171min[m http) {
    [00;38;05;171mif[m (http.[00;38;05;75mhasOwnProperty[m(key)) https[key] = http[key];
};

https.request = [00;38;05;171mfunction[m (params, cb) {
    [00;38;05;171mif[m (!params) params = {};
    params.scheme = [00;38;05;196m'https'[m;
    params.protocol = [00;38;05;196m'https:'[m;
    [00;38;05;171mreturn[m http.request.[00;38;05;75mcall[m([00;38;05;171mthis[m, params, cb);
}


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 25 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports) {

exports.read = [00;38;05;171mfunction[m (buffer, offset, isLE, mLen, nBytes) {
  [00;38;05;171mvar[m e, m
  [00;38;05;171mvar[m eLen = nBytes * 8 - mLen - 1
  [00;38;05;171mvar[m eMax = (1 << eLen) - 1
  [00;38;05;171mvar[m eBias = eMax >> 1
  [00;38;05;171mvar[m nBits = -7
  [00;38;05;171mvar[m i = isLE ? (nBytes - 1) : 0
  [00;38;05;171mvar[m d = isLE ? -1 : 1
  [00;38;05;171mvar[m s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  [00;38;05;171mfor[m (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  [00;38;05;171mfor[m (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  [00;38;05;171mif[m (e === 0) {
    e = 1 - eBias
  } [00;38;05;171melse[m [00;38;05;171mif[m (e === eMax) {
    [00;38;05;171mreturn[m m ? NaN : ((s ? -1 : 1) * Infinity)
  } [00;38;05;171melse[m {
    m = m + Math.[00;38;05;75mpow[m(2, mLen)
    e = e - eBias
  }
  [00;38;05;171mreturn[m (s ? -1 : 1) * m * Math.[00;38;05;75mpow[m(2, e - mLen)
}

exports.write = [00;38;05;171mfunction[m (buffer, value, offset, isLE, mLen, nBytes) {
  [00;38;05;171mvar[m e, m, c
  [00;38;05;171mvar[m eLen = nBytes * 8 - mLen - 1
  [00;38;05;171mvar[m eMax = (1 << eLen) - 1
  [00;38;05;171mvar[m eBias = eMax >> 1
  [00;38;05;171mvar[m rt = (mLen === 23 ? Math.[00;38;05;75mpow[m(2, -24) - Math.[00;38;05;75mpow[m(2, -77) : 0)
  [00;38;05;171mvar[m i = isLE ? 0 : (nBytes - 1)
  [00;38;05;171mvar[m d = isLE ? 1 : -1
  [00;38;05;171mvar[m s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.[00;38;05;75mabs[m(value)

  [00;38;05;171mif[m ([00;38;05;75misNaN[m(value) || value === Infinity) {
    m = [00;38;05;75misNaN[m(value) ? 1 : 0
    e = eMax
  } [00;38;05;171melse[m {
    e = Math.[00;38;05;75mfloor[m(Math.[00;38;05;75mlog[m(value) / Math.LN2)
    [00;38;05;171mif[m (value * (c = Math.[00;38;05;75mpow[m(2, -e)) < 1) {
      e--
      c *= 2
    }
    [00;38;05;171mif[m (e + eBias >= 1) {
      value += rt / c
    } [00;38;05;171melse[m {
      value += rt * Math.[00;38;05;75mpow[m(2, 1 - eBias)
    }
    [00;38;05;171mif[m (value * c >= 2) {
      e++
      c /= 2
    }

    [00;38;05;171mif[m (e + eBias >= eMax) {
      m = 0
      e = eMax
    } [00;38;05;171melse[m [00;38;05;171mif[m (e + eBias >= 1) {
      m = (value * c - 1) * Math.[00;38;05;75mpow[m(2, mLen)
      e = e + eBias
    } [00;38;05;171melse[m {
      m = value * Math.[00;38;05;75mpow[m(2, eBias - 1) * Math.[00;38;05;75mpow[m(2, mLen)
      e = 0
    }
  }

  [00;38;05;171mfor[m (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  [00;38;05;171mfor[m (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 26 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;


[00;38;05;171mvar[m parse = [00;38;05;75m__webpack_require__[m(18);

[00;38;05;242m/**[m
[00;38;05;242m * Transform an URL to a valid origin value.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {String|Object} url URL to transform to it's origin.[m
[00;38;05;242m * [m[00;38;05;70m@returns[m[00;38;05;242m {String} The origin.[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m public[m
[00;38;05;242m */[m
[00;38;05;171mfunction[m [00;38;05;75morigin[m(url) {
  [00;38;05;171mif[m ([00;38;05;196m'string'[m === [00;38;05;171mtypeof[m url) url = [00;38;05;75mparse[m(url);

  [00;38;05;242m//[m
  [00;38;05;242m// 6.2.  ASCII Serialization of an Origin[m
  [00;38;05;242m// http://tools.ietf.org/html/rfc6454#section-6.2[m
  [00;38;05;242m//[m
  [00;38;05;171mif[m (!url.protocol || !url.hostname) [00;38;05;171mreturn[m [00;38;05;196m'null'[m;

  [00;38;05;242m//[m
  [00;38;05;242m// 4. Origin of a URI[m
  [00;38;05;242m// http://tools.ietf.org/html/rfc6454#section-4[m
  [00;38;05;242m//[m
  [00;38;05;242m// States that url.scheme, host should be converted to lower case. This also[m
  [00;38;05;242m// makes it easier to match origins as everything is just lower case.[m
  [00;38;05;242m//[m
  [00;38;05;171mreturn[m (url.protocol +[00;38;05;196m'//'[m+ url.host).[00;38;05;75mtoLowerCase[m();
}

[00;38;05;242m/**[m
[00;38;05;242m * Check if the origins are the same.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {String} a URL or origin of a.[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {String} b URL or origin of b.[m
[00;38;05;242m * [m[00;38;05;70m@returns[m[00;38;05;242m {Boolean}[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m public[m
[00;38;05;242m */[m
origin.same = [00;38;05;171mfunction[m [00;38;05;75msame[m(a, b) {
  [00;38;05;171mreturn[m [00;38;05;75morigin[m(a) === [00;38;05;75morigin[m(b);
};

[00;38;05;242m//[m
[00;38;05;242m// Expose the origin[m
[00;38;05;242m//[m
module.exports = origin;


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 27 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(module, global) {[00;38;05;171mvar[m __WEBPACK_AMD_DEFINE_RESULT__;[00;38;05;242m/*! [m[00;38;05;75mhttps://mths.be/punycode[m[00;38;05;242m v1.4.1 by @mathias */[m
;([00;38;05;171mfunction[m(root) {

	[00;38;05;242m/** Detect free variables */[m
	[00;38;05;171mvar[m freeExports = [00;38;05;171mtypeof[m exports == [00;38;05;196m'object'[m && exports &&
		!exports.nodeType && exports;
	[00;38;05;171mvar[m freeModule = [00;38;05;171mtypeof[m module == [00;38;05;196m'object'[m && module &&
		!module.nodeType && module;
	[00;38;05;171mvar[m freeGlobal = [00;38;05;171mtypeof[m global == [00;38;05;196m'object'[m && global;
	[00;38;05;171mif[m (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	[00;38;05;242m/**[m
[00;38;05;242m	 * The `punycode` object.[m
[00;38;05;242m	 * [m[00;38;05;70m@name[m[00;38;05;242m punycode[m
[00;38;05;242m	 * [m[00;38;05;70m@type[m[00;38;05;242m Object[m
[00;38;05;242m	 */[m
	[00;38;05;171mvar[m punycode,

	[00;38;05;242m/** Highest positive signed 32-bit float value */[m
	maxInt = 2147483647, [00;38;05;242m// aka. 0x7FFFFFFF or 2^31-1[m

	[00;38;05;242m/** Bootstring parameters */[m
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, [00;38;05;242m// 0x80[m
	delimiter = [00;38;05;196m'-'[m, [00;38;05;242m// '\x2D'[m

	[00;38;05;242m/** Regular expressions */[m
	regexPunycode = [00;38;05;208m/^xn--/[m,
	regexNonASCII = [00;38;05;208m/[^\x20-\x7E]/[m, [00;38;05;242m// unprintable ASCII chars + non-ASCII chars[m
	regexSeparators = [00;38;05;208m/[\x2E\u3002\uFF0E\uFF61]/g[m, [00;38;05;242m// RFC 3490 separators[m

	[00;38;05;242m/** Error messages */[m
	errors = {
		[00;38;05;196m'overflow'[m: [00;38;05;196m'Overflow: input needs wider integers to process'[m,
		[00;38;05;196m'not-basic'[m: [00;38;05;196m'Illegal input >= 0x80 (not a basic code point)'[m,
		[00;38;05;196m'invalid-input'[m: [00;38;05;196m'Invalid input'[m
	},

	[00;38;05;242m/** Convenience shortcuts */[m
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	[00;38;05;242m/** Temporary variable */[m
	key;

	[00;38;05;242m/*--------------------------------------------------------------------------*/[m

	[00;38;05;242m/**[m
[00;38;05;242m	 * A generic error utility function.[m
[00;38;05;242m	 * [m[00;38;05;70m@private[m
[00;38;05;242m	 * [m[00;38;05;70m@param[m[00;38;05;242m {String} type The error type.[m
[00;38;05;242m	 * [m[00;38;05;70m@returns[m[00;38;05;242m {Error} Throws a `RangeError` with the applicable error message.[m
[00;38;05;242m	 */[m
	[00;38;05;171mfunction[m [00;38;05;75merror[m(type) {
		[00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mRangeError[m(errors[type]);
	}

	[00;38;05;242m/**[m
[00;38;05;242m	 * A generic `Array#map` utility function.[m
[00;38;05;242m	 * [m[00;38;05;70m@private[m
[00;38;05;242m	 * [m[00;38;05;70m@param[m[00;38;05;242m {Array} array The array to iterate over.[m
[00;38;05;242m	 * [m[00;38;05;70m@param[m[00;38;05;242m {Function} callback The function that gets called for every array[m
[00;38;05;242m	 * item.[m
[00;38;05;242m	 * [m[00;38;05;70m@returns[m[00;38;05;242m {Array} A new array of values returned by the callback function.[m
[00;38;05;242m	 */[m
	[00;38;05;171mfunction[m [00;38;05;75mmap[m(array, fn) {
		[00;38;05;171mvar[m length = array.length;
		[00;38;05;171mvar[m result = [];
		[00;38;05;171mwhile[m (length--) {
			result[length] = [00;38;05;75mfn[m(array[length]);
		}
		[00;38;05;171mreturn[m result;
	}

	[00;38;05;242m/**[m
[00;38;05;242m	 * A simple `Array#map`-like wrapper to work with domain name strings or email[m
[00;38;05;242m	 * addresses.[m
[00;38;05;242m	 * [m[00;38;05;70m@private[m
[00;38;05;242m	 * [m[00;38;05;70m@param[m[00;38;05;242m {String} domain The domain name or email address.[m
[00;38;05;242m	 * [m[00;38;05;70m@param[m[00;38;05;242m {Function} callback The function that gets called for every[m
[00;38;05;242m	 * character.[m
[00;38;05;242m	 * [m[00;38;05;70m@returns[m[00;38;05;242m {Array} A new string of characters returned by the callback[m
[00;38;05;242m	 * function.[m
[00;38;05;242m	 */[m
	[00;38;05;171mfunction[m [00;38;05;75mmapDomain[m(string, fn) {
		[00;38;05;171mvar[m parts = string.[00;38;05;75msplit[m([00;38;05;196m'@'[m);
		[00;38;05;171mvar[m result = [00;38;05;196m''[m;
		[00;38;05;171mif[m (parts.length > 1) {
			[00;38;05;242m// In email addresses, only the domain name should be punycoded. Leave[m
			[00;38;05;242m// the local part (i.e. everything up to `@`) intact.[m
			result = parts[0] + [00;38;05;196m'@'[m;
			string = parts[1];
		}
		[00;38;05;242m// Avoid `split(regex)` for IE8 compatibility. See #17.[m
		string = string.[00;38;05;75mreplace[m(regexSeparators, [00;38;05;196m'[m\x[00;38;05;196m2E'[m);
		[00;38;05;171mvar[m labels = string.[00;38;05;75msplit[m([00;38;05;196m'.'[m);
		[00;38;05;171mvar[m encoded = [00;38;05;75mmap[m(labels, fn).[00;38;05;75mjoin[m([00;38;05;196m'.'[m);
		[00;38;05;171mreturn[m result + encoded;
	}

	[00;38;05;242m/**[m
[00;38;05;242m	 * Creates an array containing the numeric code points of each Unicode[m
[00;38;05;242m	 * character in the string. While JavaScript uses UCS-2 internally,[m
[00;38;05;242m	 * this function will convert a pair of surrogate halves (each of which[m
[00;38;05;242m	 * UCS-2 exposes as separate characters) into a single code point,[m
[00;38;05;242m	 * matching UTF-16.[m
[00;38;05;242m	 * [m[00;38;05;70m@see[m[00;38;05;242m `punycode.ucs2.encode`[m
[00;38;05;242m	 * [m[00;38;05;70m@see[m[00;38;05;242m [m[00;38;05;75m<https://mathiasbynens.be/notes/javascript-encoding>[m
[00;38;05;242m	 * [m[00;38;05;70m@memberOf[m[00;38;05;242m punycode.ucs2[m
[00;38;05;242m	 * [m[00;38;05;70m@name[m[00;38;05;242m decode[m
[00;38;05;242m	 * [m[00;38;05;70m@param[m[00;38;05;242m {String} string The Unicode input string (UCS-2).[m
[00;38;05;242m	 * [m[00;38;05;70m@returns[m[00;38;05;242m {Array} The new array of code points.[m
[00;38;05;242m	 */[m
	[00;38;05;171mfunction[m [00;38;05;75mucs2decode[m(string) {
		[00;38;05;171mvar[m output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		[00;38;05;171mwhile[m (counter < length) {
			value = string.[00;38;05;75mcharCodeAt[m(counter++);
			[00;38;05;171mif[m (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				[00;38;05;242m// high surrogate, and there is a next character[m
				extra = string.[00;38;05;75mcharCodeAt[m(counter++);
				[00;38;05;171mif[m ((extra & 0xFC00) == 0xDC00) { [00;38;05;242m// low surrogate[m
					output.[00;38;05;75mpush[m(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} [00;38;05;171melse[m {
					[00;38;05;242m// unmatched surrogate; only append this code unit, in case the next[m
					[00;38;05;242m// code unit is the high surrogate of a surrogate pair[m
					output.[00;38;05;75mpush[m(value);
					counter--;
				}
			} [00;38;05;171melse[m {
				output.[00;38;05;75mpush[m(value);
			}
		}
		[00;38;05;171mreturn[m output;
	}

	[00;38;05;242m/**[m
[00;38;05;242m	 * Creates a string based on an array of numeric code points.[m
[00;38;05;242m	 * [m[00;38;05;70m@see[m[00;38;05;242m `punycode.ucs2.decode`[m
[00;38;05;242m	 * [m[00;38;05;70m@memberOf[m[00;38;05;242m punycode.ucs2[m
[00;38;05;242m	 * [m[00;38;05;70m@name[m[00;38;05;242m encode[m
[00;38;05;242m	 * [m[00;38;05;70m@param[m[00;38;05;242m {Array} codePoints The array of numeric code points.[m
[00;38;05;242m	 * [m[00;38;05;70m@returns[m[00;38;05;242m {String} The new Unicode string (UCS-2).[m
[00;38;05;242m	 */[m
	[00;38;05;171mfunction[m [00;38;05;75mucs2encode[m(array) {
		[00;38;05;171mreturn[m [00;38;05;75mmap[m(array, [00;38;05;171mfunction[m(value) {
			[00;38;05;171mvar[m output = [00;38;05;196m''[m;
			[00;38;05;171mif[m (value > 0xFFFF) {
				value -= 0x10000;
				output += [00;38;05;75mstringFromCharCode[m(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += [00;38;05;75mstringFromCharCode[m(value);
			[00;38;05;171mreturn[m output;
		}).[00;38;05;75mjoin[m([00;38;05;196m''[m);
	}

	[00;38;05;242m/**[m
[00;38;05;242m	 * Converts a basic code point into a digit/integer.[m
[00;38;05;242m	 * [m[00;38;05;70m@see[m[00;38;05;242m `digitToBasic()`[m
[00;38;05;242m	 * [m[00;38;05;70m@private[m
[00;38;05;242m	 * [m[00;38;05;70m@param[m[00;38;05;242m {Number} codePoint The basic numeric code point value.[m
[00;38;05;242m	 * [m[00;38;05;70m@returns[m[00;38;05;242m {Number} The numeric value of a basic code point (for use in[m
[00;38;05;242m	 * representing integers) in the range `0` to `base - 1`, or `base` if[m
[00;38;05;242m	 * the code point does not represent a value.[m
[00;38;05;242m	 */[m
	[00;38;05;171mfunction[m [00;38;05;75mbasicToDigit[m(codePoint) {
		[00;38;05;171mif[m (codePoint - 48 < 10) {
			[00;38;05;171mreturn[m codePoint - 22;
		}
		[00;38;05;171mif[m (codePoint - 65 < 26) {
			[00;38;05;171mreturn[m codePoint - 65;
		}
		[00;38;05;171mif[m (codePoint - 97 < 26) {
			[00;38;05;171mreturn[m codePoint - 97;
		}
		[00;38;05;171mreturn[m base;
	}

	[00;38;05;242m/**[m
[00;38;05;242m	 * Converts a digit/integer into a basic code point.[m
[00;38;05;242m	 * [m[00;38;05;70m@see[m[00;38;05;242m `basicToDigit()`[m
[00;38;05;242m	 * [m[00;38;05;70m@private[m
[00;38;05;242m	 * [m[00;38;05;70m@param[m[00;38;05;242m {Number} digit The numeric value of a basic code point.[m
[00;38;05;242m	 * [m[00;38;05;70m@returns[m[00;38;05;242m {Number} The basic code point whose value (when used for[m
[00;38;05;242m	 * representing integers) is `digit`, which needs to be in the range[m
[00;38;05;242m	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is[m
[00;38;05;242m	 * used; else, the lowercase form is used. The behavior is undefined[m
[00;38;05;242m	 * if `flag` is non-zero and `digit` has no uppercase form.[m
[00;38;05;242m	 */[m
	[00;38;05;171mfunction[m [00;38;05;75mdigitToBasic[m(digit, flag) {
		[00;38;05;242m//  0..25 map to ASCII a..z or A..Z[m
		[00;38;05;242m// 26..35 map to ASCII 0..9[m
		[00;38;05;171mreturn[m digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	[00;38;05;242m/**[m
[00;38;05;242m	 * Bias adaptation function as per section 3.4 of RFC 3492.[m
[00;38;05;242m	 * [m[00;38;05;75mhttps://tools.ietf.org/html/rfc3492[m[00;38;05;242m#section-3.4[m
[00;38;05;242m	 * [m[00;38;05;70m@private[m
[00;38;05;242m	 */[m
	[00;38;05;171mfunction[m [00;38;05;75madapt[m(delta, numPoints, firstTime) {
		[00;38;05;171mvar[m k = 0;
		delta = firstTime ? [00;38;05;75mfloor[m(delta / damp) : delta >> 1;
		delta += [00;38;05;75mfloor[m(delta / numPoints);
		[00;38;05;171mfor[m ([00;38;05;242m/* no initialization */[m; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = [00;38;05;75mfloor[m(delta / baseMinusTMin);
		}
		[00;38;05;171mreturn[m [00;38;05;75mfloor[m(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	[00;38;05;242m/**[m
[00;38;05;242m	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode[m
[00;38;05;242m	 * symbols.[m
[00;38;05;242m	 * [m[00;38;05;70m@memberOf[m[00;38;05;242m punycode[m
[00;38;05;242m	 * [m[00;38;05;70m@param[m[00;38;05;242m {String} input The Punycode string of ASCII-only symbols.[m
[00;38;05;242m	 * [m[00;38;05;70m@returns[m[00;38;05;242m {String} The resulting string of Unicode symbols.[m
[00;38;05;242m	 */[m
	[00;38;05;171mfunction[m [00;38;05;75mdecode[m(input) {
		[00;38;05;242m// Don't use UCS-2[m
		[00;38;05;171mvar[m output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    [00;38;05;242m/** Cached calculation results */[m
		    baseMinusT;

		[00;38;05;242m// Handle the basic code points: let `basic` be the number of input code[m
		[00;38;05;242m// points before the last delimiter, or `0` if there is none, then copy[m
		[00;38;05;242m// the first basic code points to the output.[m

		basic = input.[00;38;05;75mlastIndexOf[m(delimiter);
		[00;38;05;171mif[m (basic < 0) {
			basic = 0;
		}

		[00;38;05;171mfor[m (j = 0; j < basic; ++j) {
			[00;38;05;242m// if it's not a basic code point[m
			[00;38;05;171mif[m (input.[00;38;05;75mcharCodeAt[m(j) >= 0x80) {
				[00;38;05;75merror[m([00;38;05;196m'not-basic'[m);
			}
			output.[00;38;05;75mpush[m(input.[00;38;05;75mcharCodeAt[m(j));
		}

		[00;38;05;242m// Main decoding loop: start just after the last delimiter if any basic code[m
		[00;38;05;242m// points were copied; start at the beginning otherwise.[m

		[00;38;05;171mfor[m (index = basic > 0 ? basic + 1 : 0; index < inputLength; [00;38;05;242m/* no final expression */[m) {

			[00;38;05;242m// `index` is the index of the next character to be consumed.[m
			[00;38;05;242m// Decode a generalized variable-length integer into `delta`,[m
			[00;38;05;242m// which gets added to `i`. The overflow checking is easier[m
			[00;38;05;242m// if we increase `i` as we go, then subtract off its starting[m
			[00;38;05;242m// value at the end to obtain `delta`.[m
			[00;38;05;171mfor[m (oldi = i, w = 1, k = base; [00;38;05;242m/* no condition */[m; k += base) {

				[00;38;05;171mif[m (index >= inputLength) {
					[00;38;05;75merror[m([00;38;05;196m'invalid-input'[m);
				}

				digit = [00;38;05;75mbasicToDigit[m(input.[00;38;05;75mcharCodeAt[m(index++));

				[00;38;05;171mif[m (digit >= base || digit > [00;38;05;75mfloor[m((maxInt - i) / w)) {
					[00;38;05;75merror[m([00;38;05;196m'overflow'[m);
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				[00;38;05;171mif[m (digit < t) {
					[00;38;05;171mbreak[m;
				}

				baseMinusT = base - t;
				[00;38;05;171mif[m (w > [00;38;05;75mfloor[m(maxInt / baseMinusT)) {
					[00;38;05;75merror[m([00;38;05;196m'overflow'[m);
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = [00;38;05;75madapt[m(i - oldi, out, oldi == 0);

			[00;38;05;242m// `i` was supposed to wrap around from `out` to `0`,[m
			[00;38;05;242m// incrementing `n` each time, so we'll fix that now:[m
			[00;38;05;171mif[m ([00;38;05;75mfloor[m(i / out) > maxInt - n) {
				[00;38;05;75merror[m([00;38;05;196m'overflow'[m);
			}

			n += [00;38;05;75mfloor[m(i / out);
			i %= out;

			[00;38;05;242m// Insert `n` at position `i` of the output[m
			output.[00;38;05;75msplice[m(i++, 0, n);

		}

		[00;38;05;171mreturn[m [00;38;05;75mucs2encode[m(output);
	}

	[00;38;05;242m/**[m
[00;38;05;242m	 * Converts a string of Unicode symbols (e.g. a domain name label) to a[m
[00;38;05;242m	 * Punycode string of ASCII-only symbols.[m
[00;38;05;242m	 * [m[00;38;05;70m@memberOf[m[00;38;05;242m punycode[m
[00;38;05;242m	 * [m[00;38;05;70m@param[m[00;38;05;242m {String} input The string of Unicode symbols.[m
[00;38;05;242m	 * [m[00;38;05;70m@returns[m[00;38;05;242m {String} The resulting Punycode string of ASCII-only symbols.[m
[00;38;05;242m	 */[m
	[00;38;05;171mfunction[m [00;38;05;75mencode[m(input) {
		[00;38;05;171mvar[m n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    [00;38;05;242m/** `inputLength` will hold the number of code points in `input`. */[m
		    inputLength,
		    [00;38;05;242m/** Cached calculation results */[m
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		[00;38;05;242m// Convert the input in UCS-2 to Unicode[m
		input = [00;38;05;75mucs2decode[m(input);

		[00;38;05;242m// Cache the length[m
		inputLength = input.length;

		[00;38;05;242m// Initialize the state[m
		n = initialN;
		delta = 0;
		bias = initialBias;

		[00;38;05;242m// Handle the basic code points[m
		[00;38;05;171mfor[m (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			[00;38;05;171mif[m (currentValue < 0x80) {
				output.[00;38;05;75mpush[m([00;38;05;75mstringFromCharCode[m(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		[00;38;05;242m// `handledCPCount` is the number of code points that have been handled;[m
		[00;38;05;242m// `basicLength` is the number of basic code points.[m

		[00;38;05;242m// Finish the basic string - if it is not empty - with a delimiter[m
		[00;38;05;171mif[m (basicLength) {
			output.[00;38;05;75mpush[m(delimiter);
		}

		[00;38;05;242m// Main encoding loop:[m
		[00;38;05;171mwhile[m (handledCPCount < inputLength) {

			[00;38;05;242m// All non-basic code points < n have been handled already. Find the next[m
			[00;38;05;242m// larger one:[m
			[00;38;05;171mfor[m (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				[00;38;05;171mif[m (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			[00;38;05;242m// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,[m
			[00;38;05;242m// but guard against overflow[m
			handledCPCountPlusOne = handledCPCount + 1;
			[00;38;05;171mif[m (m - n > [00;38;05;75mfloor[m((maxInt - delta) / handledCPCountPlusOne)) {
				[00;38;05;75merror[m([00;38;05;196m'overflow'[m);
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			[00;38;05;171mfor[m (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				[00;38;05;171mif[m (currentValue < n && ++delta > maxInt) {
					[00;38;05;75merror[m([00;38;05;196m'overflow'[m);
				}

				[00;38;05;171mif[m (currentValue == n) {
					[00;38;05;242m// Represent delta as a generalized variable-length integer[m
					[00;38;05;171mfor[m (q = delta, k = base; [00;38;05;242m/* no condition */[m; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						[00;38;05;171mif[m (q < t) {
							[00;38;05;171mbreak[m;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.[00;38;05;75mpush[m(
							[00;38;05;75mstringFromCharCode[m([00;38;05;75mdigitToBasic[m(t + qMinusT % baseMinusT, 0))
						);
						q = [00;38;05;75mfloor[m(qMinusT / baseMinusT);
					}

					output.[00;38;05;75mpush[m([00;38;05;75mstringFromCharCode[m([00;38;05;75mdigitToBasic[m(q, 0)));
					bias = [00;38;05;75madapt[m(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		[00;38;05;171mreturn[m output.[00;38;05;75mjoin[m([00;38;05;196m''[m);
	}

	[00;38;05;242m/**[m
[00;38;05;242m	 * Converts a Punycode string representing a domain name or an email address[m
[00;38;05;242m	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.[m
[00;38;05;242m	 * it doesn't matter if you call it on a string that has already been[m
[00;38;05;242m	 * converted to Unicode.[m
[00;38;05;242m	 * [m[00;38;05;70m@memberOf[m[00;38;05;242m punycode[m
[00;38;05;242m	 * [m[00;38;05;70m@param[m[00;38;05;242m {String} input The Punycoded domain name or email address to[m
[00;38;05;242m	 * convert to Unicode.[m
[00;38;05;242m	 * [m[00;38;05;70m@returns[m[00;38;05;242m {String} The Unicode representation of the given Punycode[m
[00;38;05;242m	 * string.[m
[00;38;05;242m	 */[m
	[00;38;05;171mfunction[m [00;38;05;75mtoUnicode[m(input) {
		[00;38;05;171mreturn[m [00;38;05;75mmapDomain[m(input, [00;38;05;171mfunction[m(string) {
			[00;38;05;171mreturn[m regexPunycode.[00;38;05;75mtest[m(string)
				? [00;38;05;75mdecode[m(string.[00;38;05;75mslice[m(4).[00;38;05;75mtoLowerCase[m())
				: string;
		});
	}

	[00;38;05;242m/**[m
[00;38;05;242m	 * Converts a Unicode string representing a domain name or an email address to[m
[00;38;05;242m	 * Punycode. Only the non-ASCII parts of the domain name will be converted,[m
[00;38;05;242m	 * i.e. it doesn't matter if you call it with a domain that's already in[m
[00;38;05;242m	 * ASCII.[m
[00;38;05;242m	 * [m[00;38;05;70m@memberOf[m[00;38;05;242m punycode[m
[00;38;05;242m	 * [m[00;38;05;70m@param[m[00;38;05;242m {String} input The domain name or email address to convert, as a[m
[00;38;05;242m	 * Unicode string.[m
[00;38;05;242m	 * [m[00;38;05;70m@returns[m[00;38;05;242m {String} The Punycode representation of the given domain name or[m
[00;38;05;242m	 * email address.[m
[00;38;05;242m	 */[m
	[00;38;05;171mfunction[m [00;38;05;75mtoASCII[m(input) {
		[00;38;05;171mreturn[m [00;38;05;75mmapDomain[m(input, [00;38;05;171mfunction[m(string) {
			[00;38;05;171mreturn[m regexNonASCII.[00;38;05;75mtest[m(string)
				? [00;38;05;196m'xn--'[m + [00;38;05;75mencode[m(string)
				: string;
		});
	}

	[00;38;05;242m/*--------------------------------------------------------------------------*/[m

	[00;38;05;242m/** Define the public API */[m
	punycode = {
		[00;38;05;242m/**[m
[00;38;05;242m		 * A string representing the current Punycode.js version number.[m
[00;38;05;242m		 * [m[00;38;05;70m@memberOf[m[00;38;05;242m punycode[m
[00;38;05;242m		 * [m[00;38;05;70m@type[m[00;38;05;242m String[m
[00;38;05;242m		 */[m
		[00;38;05;196m'version'[m: [00;38;05;196m'1.4.1'[m,
		[00;38;05;242m/**[m
[00;38;05;242m		 * An object of methods to convert from JavaScript's internal character[m
[00;38;05;242m		 * representation (UCS-2) to Unicode code points, and back.[m
[00;38;05;242m		 * [m[00;38;05;70m@see[m[00;38;05;242m [m[00;38;05;75m<https://mathiasbynens.be/notes/javascript-encoding>[m
[00;38;05;242m		 * [m[00;38;05;70m@memberOf[m[00;38;05;242m punycode[m
[00;38;05;242m		 * [m[00;38;05;70m@type[m[00;38;05;242m Object[m
[00;38;05;242m		 */[m
		[00;38;05;196m'ucs2'[m: {
			[00;38;05;196m'decode'[m: ucs2decode,
			[00;38;05;196m'encode'[m: ucs2encode
		},
		[00;38;05;196m'decode'[m: decode,
		[00;38;05;196m'encode'[m: encode,
		[00;38;05;196m'toASCII'[m: toASCII,
		[00;38;05;196m'toUnicode'[m: toUnicode
	};

	[00;38;05;242m/** Expose `punycode` */[m
	[00;38;05;242m// Some AMD build optimizers, like r.js, check for specific condition patterns[m
	[00;38;05;242m// like the following:[m
	[00;38;05;171mif[m (
		[00;38;05;171mtrue[m
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = [00;38;05;171mfunction[m() {
			[00;38;05;171mreturn[m punycode;
		}.[00;38;05;75mcall[m(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} [00;38;05;171melse[m [00;38;05;171mif[m (freeExports && freeModule) {
		[00;38;05;171mif[m (module.exports == freeExports) {
			[00;38;05;242m// in Node.js, io.js, or RingoJS v0.8.0+[m
			freeModule.exports = punycode;
		} [00;38;05;171melse[m {
			[00;38;05;242m// in Narwhal or RingoJS v0.7.0-[m
			[00;38;05;171mfor[m (key [00;38;05;171min[m punycode) {
				punycode.[00;38;05;75mhasOwnProperty[m(key) && (freeExports[key] = punycode[key]);
			}
		}
	} [00;38;05;171melse[m {
		[00;38;05;242m// in Rhino or a web browser[m
		root.punycode = punycode;
	}

}([00;38;05;171mthis[m));

[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(46)(module), [00;38;05;75m__webpack_require__[m(0)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 28 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;
[00;38;05;242m// Copyright Joyent, Inc. and other Node contributors.[m
[00;38;05;242m//[m
[00;38;05;242m// Permission is hereby granted, free of charge, to any person obtaining a[m
[00;38;05;242m// copy of this software and associated documentation files (the[m
[00;38;05;242m// "Software"), to deal in the Software without restriction, including[m
[00;38;05;242m// without limitation the rights to use, copy, modify, merge, publish,[m
[00;38;05;242m// distribute, sublicense, and/or sell copies of the Software, and to permit[m
[00;38;05;242m// persons to whom the Software is furnished to do so, subject to the[m
[00;38;05;242m// following conditions:[m
[00;38;05;242m//[m
[00;38;05;242m// The above copyright notice and this permission notice shall be included[m
[00;38;05;242m// in all copies or substantial portions of the Software.[m
[00;38;05;242m//[m
[00;38;05;242m// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS[m
[00;38;05;242m// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF[m
[00;38;05;242m// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN[m
[00;38;05;242m// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,[m
[00;38;05;242m// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR[m
[00;38;05;242m// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE[m
[00;38;05;242m// USE OR OTHER DEALINGS IN THE SOFTWARE.[m



[00;38;05;242m// If obj.hasOwnProperty has been overridden, then calling[m
[00;38;05;242m// obj.hasOwnProperty(prop) will break.[m
[00;38;05;242m// See: https://github.com/joyent/node/issues/1707[m
[00;38;05;171mfunction[m [00;38;05;75mhasOwnProperty[m(obj, prop) {
  [00;38;05;171mreturn[m Object.[00;38;05;171mprototype[m.hasOwnProperty.[00;38;05;75mcall[m(obj, prop);
}

module.exports = [00;38;05;171mfunction[m(qs, sep, eq, options) {
  sep = sep || [00;38;05;196m'&'[m;
  eq = eq || [00;38;05;196m'='[m;
  [00;38;05;171mvar[m obj = {};

  [00;38;05;171mif[m ([00;38;05;171mtypeof[m qs !== [00;38;05;196m'string'[m || qs.length === 0) {
    [00;38;05;171mreturn[m obj;
  }

  [00;38;05;171mvar[m regexp = [00;38;05;208m/\+/g[m;
  qs = qs.[00;38;05;75msplit[m(sep);

  [00;38;05;171mvar[m maxKeys = 1000;
  [00;38;05;171mif[m (options && [00;38;05;171mtypeof[m options.maxKeys === [00;38;05;196m'number'[m) {
    maxKeys = options.maxKeys;
  }

  [00;38;05;171mvar[m len = qs.length;
  [00;38;05;242m// maxKeys <= 0 means that we should not limit keys count[m
  [00;38;05;171mif[m (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < len; ++i) {
    [00;38;05;171mvar[m x = qs[i].[00;38;05;75mreplace[m(regexp, [00;38;05;196m'%20'[m),
        idx = x.[00;38;05;75mindexOf[m(eq),
        kstr, vstr, k, v;

    [00;38;05;171mif[m (idx >= 0) {
      kstr = x.[00;38;05;75msubstr[m(0, idx);
      vstr = x.[00;38;05;75msubstr[m(idx + 1);
    } [00;38;05;171melse[m {
      kstr = x;
      vstr = [00;38;05;196m''[m;
    }

    k = [00;38;05;75mdecodeURIComponent[m(kstr);
    v = [00;38;05;75mdecodeURIComponent[m(vstr);

    [00;38;05;171mif[m (![00;38;05;75mhasOwnProperty[m(obj, k)) {
      obj[k] = v;
    } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;75misArray[m(obj[k])) {
      obj[k].[00;38;05;75mpush[m(v);
    } [00;38;05;171melse[m {
      obj[k] = [obj[k], v];
    }
  }

  [00;38;05;171mreturn[m obj;
};

[00;38;05;171mvar[m isArray = Array.isArray || [00;38;05;171mfunction[m (xs) {
  [00;38;05;171mreturn[m Object.[00;38;05;171mprototype[m.toString.[00;38;05;75mcall[m(xs) === [00;38;05;196m'[object Array]'[m;
};


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 29 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;
[00;38;05;242m// Copyright Joyent, Inc. and other Node contributors.[m
[00;38;05;242m//[m
[00;38;05;242m// Permission is hereby granted, free of charge, to any person obtaining a[m
[00;38;05;242m// copy of this software and associated documentation files (the[m
[00;38;05;242m// "Software"), to deal in the Software without restriction, including[m
[00;38;05;242m// without limitation the rights to use, copy, modify, merge, publish,[m
[00;38;05;242m// distribute, sublicense, and/or sell copies of the Software, and to permit[m
[00;38;05;242m// persons to whom the Software is furnished to do so, subject to the[m
[00;38;05;242m// following conditions:[m
[00;38;05;242m//[m
[00;38;05;242m// The above copyright notice and this permission notice shall be included[m
[00;38;05;242m// in all copies or substantial portions of the Software.[m
[00;38;05;242m//[m
[00;38;05;242m// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS[m
[00;38;05;242m// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF[m
[00;38;05;242m// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN[m
[00;38;05;242m// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,[m
[00;38;05;242m// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR[m
[00;38;05;242m// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE[m
[00;38;05;242m// USE OR OTHER DEALINGS IN THE SOFTWARE.[m



[00;38;05;171mvar[m stringifyPrimitive = [00;38;05;171mfunction[m(v) {
  [00;38;05;171mswitch[m ([00;38;05;171mtypeof[m v) {
    [00;38;05;171mcase[m [00;38;05;196m'string'[m:
      [00;38;05;171mreturn[m v;

    [00;38;05;171mcase[m [00;38;05;196m'boolean'[m:
      [00;38;05;171mreturn[m v ? [00;38;05;196m'true'[m : [00;38;05;196m'false'[m;

    [00;38;05;171mcase[m [00;38;05;196m'number'[m:
      [00;38;05;171mreturn[m [00;38;05;75misFinite[m(v) ? v : [00;38;05;196m''[m;

    [00;38;05;171mdefault[m:
      [00;38;05;171mreturn[m [00;38;05;196m''[m;
  }
};

module.exports = [00;38;05;171mfunction[m(obj, sep, eq, name) {
  sep = sep || [00;38;05;196m'&'[m;
  eq = eq || [00;38;05;196m'='[m;
  [00;38;05;171mif[m (obj === [00;38;05;171mnull[m) {
    obj = undefined;
  }

  [00;38;05;171mif[m ([00;38;05;171mtypeof[m obj === [00;38;05;196m'object'[m) {
    [00;38;05;171mreturn[m [00;38;05;75mmap[m([00;38;05;75mobjectKeys[m(obj), [00;38;05;171mfunction[m(k) {
      [00;38;05;171mvar[m ks = [00;38;05;75mencodeURIComponent[m([00;38;05;75mstringifyPrimitive[m(k)) + eq;
      [00;38;05;171mif[m ([00;38;05;75misArray[m(obj[k])) {
        [00;38;05;171mreturn[m [00;38;05;75mmap[m(obj[k], [00;38;05;171mfunction[m(v) {
          [00;38;05;171mreturn[m ks + [00;38;05;75mencodeURIComponent[m([00;38;05;75mstringifyPrimitive[m(v));
        }).[00;38;05;75mjoin[m(sep);
      } [00;38;05;171melse[m {
        [00;38;05;171mreturn[m ks + [00;38;05;75mencodeURIComponent[m([00;38;05;75mstringifyPrimitive[m(obj[k]));
      }
    }).[00;38;05;75mjoin[m(sep);

  }

  [00;38;05;171mif[m (!name) [00;38;05;171mreturn[m [00;38;05;196m''[m;
  [00;38;05;171mreturn[m [00;38;05;75mencodeURIComponent[m([00;38;05;75mstringifyPrimitive[m(name)) + eq +
         [00;38;05;75mencodeURIComponent[m([00;38;05;75mstringifyPrimitive[m(obj));
};

[00;38;05;171mvar[m isArray = Array.isArray || [00;38;05;171mfunction[m (xs) {
  [00;38;05;171mreturn[m Object.[00;38;05;171mprototype[m.toString.[00;38;05;75mcall[m(xs) === [00;38;05;196m'[object Array]'[m;
};

[00;38;05;171mfunction[m [00;38;05;75mmap[m (xs, f) {
  [00;38;05;171mif[m (xs.map) [00;38;05;171mreturn[m xs.[00;38;05;75mmap[m(f);
  [00;38;05;171mvar[m res = [];
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < xs.length; i++) {
    res.[00;38;05;75mpush[m([00;38;05;75mf[m(xs[i], i));
  }
  [00;38;05;171mreturn[m res;
}

[00;38;05;171mvar[m objectKeys = Object.keys || [00;38;05;171mfunction[m (obj) {
  [00;38;05;171mvar[m res = [];
  [00;38;05;171mfor[m ([00;38;05;171mvar[m key [00;38;05;171min[m obj) {
    [00;38;05;171mif[m (Object.[00;38;05;171mprototype[m.hasOwnProperty.[00;38;05;75mcall[m(obj, key)) res.[00;38;05;75mpush[m(key);
  }
  [00;38;05;171mreturn[m res;
};


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 30 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;


exports.decode = exports.parse = [00;38;05;75m__webpack_require__[m(28);
exports.encode = exports.stringify = [00;38;05;75m__webpack_require__[m(29);


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 31 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;


[00;38;05;171mvar[m has = Object.[00;38;05;171mprototype[m.hasOwnProperty;

[00;38;05;242m/**[m
[00;38;05;242m * Simple query string parser.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {String} query The query string that needs to be parsed.[m
[00;38;05;242m * [m[00;38;05;70m@returns[m[00;38;05;242m {Object}[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m public[m
[00;38;05;242m */[m
[00;38;05;171mfunction[m [00;38;05;75mquerystring[m(query) {
  [00;38;05;171mvar[m parser = [00;38;05;208m/([^=?&]+)=?([^&]*)/g[m
    , result = {}
    , part;

  [00;38;05;242m//[m
  [00;38;05;242m// Little nifty parsing hack, leverage the fact that RegExp.exec increments[m
  [00;38;05;242m// the lastIndex property so we can continue executing this loop until we've[m
  [00;38;05;242m// parsed all results.[m
  [00;38;05;242m//[m
  [00;38;05;171mfor[m (;
    part = parser.[00;38;05;75mexec[m(query);
    result[[00;38;05;75mdecodeURIComponent[m(part[1])] = [00;38;05;75mdecodeURIComponent[m(part[2])
  );

  [00;38;05;171mreturn[m result;
}

[00;38;05;242m/**[m
[00;38;05;242m * Transform a query string to an object.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {Object} obj Object that should be transformed.[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {String} prefix Optional prefix.[m
[00;38;05;242m * [m[00;38;05;70m@returns[m[00;38;05;242m {String}[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m public[m
[00;38;05;242m */[m
[00;38;05;171mfunction[m [00;38;05;75mquerystringify[m(obj, prefix) {
  prefix = prefix || [00;38;05;196m''[m;

  [00;38;05;171mvar[m pairs = [];

  [00;38;05;242m//[m
  [00;38;05;242m// Optionally prefix with a '?' if needed[m
  [00;38;05;242m//[m
  [00;38;05;171mif[m ([00;38;05;196m'string'[m !== [00;38;05;171mtypeof[m prefix) prefix = [00;38;05;196m'?'[m;

  [00;38;05;171mfor[m ([00;38;05;171mvar[m key [00;38;05;171min[m obj) {
    [00;38;05;171mif[m (has.[00;38;05;75mcall[m(obj, key)) {
      pairs.[00;38;05;75mpush[m([00;38;05;75mencodeURIComponent[m(key) +[00;38;05;196m'='[m+ [00;38;05;75mencodeURIComponent[m(obj[key]));
    }
  }

  [00;38;05;171mreturn[m pairs.length ? prefix + pairs.[00;38;05;75mjoin[m([00;38;05;196m'&'[m) : [00;38;05;196m''[m;
}

[00;38;05;242m//[m
[00;38;05;242m// Expose the module.[m
[00;38;05;242m//[m
exports.stringify = querystringify;
exports.parse = querystring;


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 32 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;
[00;38;05;242m// a passthrough stream.[m
[00;38;05;242m// basically just the most minimal sort of Transform stream.[m
[00;38;05;242m// Every written chunk gets output as-is.[m



module.exports = PassThrough;

[00;38;05;171mvar[m Transform = [00;38;05;75m__webpack_require__[m(11);

[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m util = [00;38;05;75m__webpack_require__[m(5);
util.inherits = [00;38;05;75m__webpack_require__[m(3);
[00;38;05;242m/*</replacement>*/[m

util.[00;38;05;75minherits[m(PassThrough, Transform);

[00;38;05;171mfunction[m [00;38;05;75mPassThrough[m(options) {
  [00;38;05;171mif[m (!([00;38;05;171mthis[m [00;38;05;171minstanceof[m PassThrough)) [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mPassThrough[m(options);

  Transform.[00;38;05;75mcall[m([00;38;05;171mthis[m, options);
}

PassThrough.[00;38;05;171mprototype[m._transform = [00;38;05;171mfunction[m (chunk, encoding, cb) {
  [00;38;05;75mcb[m([00;38;05;171mnull[m, chunk);
};

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 33 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;


[00;38;05;171mvar[m Buffer = [00;38;05;75m__webpack_require__[m(1).Buffer;
[00;38;05;242m/*<replacement>*/[m
[00;38;05;171mvar[m bufferShim = [00;38;05;75m__webpack_require__[m(6);
[00;38;05;242m/*</replacement>*/[m

module.exports = BufferList;

[00;38;05;171mfunction[m [00;38;05;75mBufferList[m() {
  [00;38;05;171mthis[m.head = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.tail = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.length = 0;
}

BufferList.[00;38;05;171mprototype[m.push = [00;38;05;171mfunction[m (v) {
  [00;38;05;171mvar[m entry = { data: v, next: [00;38;05;171mnull[m };
  [00;38;05;171mif[m ([00;38;05;171mthis[m.length > 0) [00;38;05;171mthis[m.tail.next = entry;[00;38;05;171melse[m [00;38;05;171mthis[m.head = entry;
  [00;38;05;171mthis[m.tail = entry;
  ++[00;38;05;171mthis[m.length;
};

BufferList.[00;38;05;171mprototype[m.unshift = [00;38;05;171mfunction[m (v) {
  [00;38;05;171mvar[m entry = { data: v, next: [00;38;05;171mthis[m.head };
  [00;38;05;171mif[m ([00;38;05;171mthis[m.length === 0) [00;38;05;171mthis[m.tail = entry;
  [00;38;05;171mthis[m.head = entry;
  ++[00;38;05;171mthis[m.length;
};

BufferList.[00;38;05;171mprototype[m.shift = [00;38;05;171mfunction[m () {
  [00;38;05;171mif[m ([00;38;05;171mthis[m.length === 0) [00;38;05;171mreturn[m;
  [00;38;05;171mvar[m ret = [00;38;05;171mthis[m.head.data;
  [00;38;05;171mif[m ([00;38;05;171mthis[m.length === 1) [00;38;05;171mthis[m.head = [00;38;05;171mthis[m.tail = [00;38;05;171mnull[m;[00;38;05;171melse[m [00;38;05;171mthis[m.head = [00;38;05;171mthis[m.head.next;
  --[00;38;05;171mthis[m.length;
  [00;38;05;171mreturn[m ret;
};

BufferList.[00;38;05;171mprototype[m.clear = [00;38;05;171mfunction[m () {
  [00;38;05;171mthis[m.head = [00;38;05;171mthis[m.tail = [00;38;05;171mnull[m;
  [00;38;05;171mthis[m.length = 0;
};

BufferList.[00;38;05;171mprototype[m.join = [00;38;05;171mfunction[m (s) {
  [00;38;05;171mif[m ([00;38;05;171mthis[m.length === 0) [00;38;05;171mreturn[m [00;38;05;196m''[m;
  [00;38;05;171mvar[m p = [00;38;05;171mthis[m.head;
  [00;38;05;171mvar[m ret = [00;38;05;196m''[m + p.data;
  [00;38;05;171mwhile[m (p = p.next) {
    ret += s + p.data;
  }[00;38;05;171mreturn[m ret;
};

BufferList.[00;38;05;171mprototype[m.concat = [00;38;05;171mfunction[m (n) {
  [00;38;05;171mif[m ([00;38;05;171mthis[m.length === 0) [00;38;05;171mreturn[m bufferShim.[00;38;05;75malloc[m(0);
  [00;38;05;171mif[m ([00;38;05;171mthis[m.length === 1) [00;38;05;171mreturn[m [00;38;05;171mthis[m.head.data;
  [00;38;05;171mvar[m ret = bufferShim.[00;38;05;75mallocUnsafe[m(n >>> 0);
  [00;38;05;171mvar[m p = [00;38;05;171mthis[m.head;
  [00;38;05;171mvar[m i = 0;
  [00;38;05;171mwhile[m (p) {
    p.data.[00;38;05;75mcopy[m(ret, i);
    i += p.data.length;
    p = p.next;
  }
  [00;38;05;171mreturn[m ret;
};

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 34 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;


[00;38;05;242m/**[m
[00;38;05;242m * Check if we're required to add a port number.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@see[m[00;38;05;242m [m[00;38;05;75mhttps://url.spec.whatwg.org/[m[00;38;05;242m#default-port[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {Number|String} port Port number we need to check[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {String} protocol Protocol we need to check against.[m
[00;38;05;242m * [m[00;38;05;70m@returns[m[00;38;05;242m {Boolean} Is it a default port for the given protocol[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m private[m
[00;38;05;242m */[m
module.exports = [00;38;05;171mfunction[m [00;38;05;75mrequired[m(port, protocol) {
  protocol = protocol.[00;38;05;75msplit[m([00;38;05;196m':'[m)[0];
  port = +port;

  [00;38;05;171mif[m (!port) [00;38;05;171mreturn[m [00;38;05;171mfalse[m;

  [00;38;05;171mswitch[m (protocol) {
    [00;38;05;171mcase[m [00;38;05;196m'http'[m:
    [00;38;05;171mcase[m [00;38;05;196m'ws'[m:
    [00;38;05;171mreturn[m port !== 80;

    [00;38;05;171mcase[m [00;38;05;196m'https'[m:
    [00;38;05;171mcase[m [00;38;05;196m'wss'[m:
    [00;38;05;171mreturn[m port !== 443;

    [00;38;05;171mcase[m [00;38;05;196m'ftp'[m:
    [00;38;05;171mreturn[m port !== 21;

    [00;38;05;171mcase[m [00;38;05;196m'gopher'[m:
    [00;38;05;171mreturn[m port !== 70;

    [00;38;05;171mcase[m [00;38;05;196m'file'[m:
    [00;38;05;171mreturn[m [00;38;05;171mfalse[m;
  }

  [00;38;05;171mreturn[m port !== 0;
};


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 35 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(global, process) {([00;38;05;171mfunction[m (global, undefined) {
    [00;38;05;196m"use strict"[m;

    [00;38;05;171mif[m (global.setImmediate) {
        [00;38;05;171mreturn[m;
    }

    [00;38;05;171mvar[m nextHandle = 1; [00;38;05;242m// Spec says greater than zero[m
    [00;38;05;171mvar[m tasksByHandle = {};
    [00;38;05;171mvar[m currentlyRunningATask = [00;38;05;171mfalse[m;
    [00;38;05;171mvar[m doc = global.document;
    [00;38;05;171mvar[m registerImmediate;

    [00;38;05;171mfunction[m [00;38;05;75msetImmediate[m(callback) {
      [00;38;05;242m// Callback can either be a function or a string[m
      [00;38;05;171mif[m ([00;38;05;171mtypeof[m callback !== [00;38;05;196m"function"[m) {
        callback = [00;38;05;171mnew[m [00;38;05;75mFunction[m([00;38;05;196m""[m + callback);
      }
      [00;38;05;242m// Copy function arguments[m
      [00;38;05;171mvar[m args = [00;38;05;171mnew[m [00;38;05;75mArray[m(arguments.length - 1);
      [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      [00;38;05;242m// Store and register the task[m
      [00;38;05;171mvar[m task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      [00;38;05;75mregisterImmediate[m(nextHandle);
      [00;38;05;171mreturn[m nextHandle++;
    }

    [00;38;05;171mfunction[m [00;38;05;75mclearImmediate[m(handle) {
        [00;38;05;171mdelete[m tasksByHandle[handle];
    }

    [00;38;05;171mfunction[m [00;38;05;75mrun[m(task) {
        [00;38;05;171mvar[m callback = task.callback;
        [00;38;05;171mvar[m args = task.args;
        [00;38;05;171mswitch[m (args.length) {
        [00;38;05;171mcase[m 0:
            [00;38;05;75mcallback[m();
            [00;38;05;171mbreak[m;
        [00;38;05;171mcase[m 1:
            [00;38;05;75mcallback[m(args[0]);
            [00;38;05;171mbreak[m;
        [00;38;05;171mcase[m 2:
            [00;38;05;75mcallback[m(args[0], args[1]);
            [00;38;05;171mbreak[m;
        [00;38;05;171mcase[m 3:
            [00;38;05;75mcallback[m(args[0], args[1], args[2]);
            [00;38;05;171mbreak[m;
        [00;38;05;171mdefault[m:
            callback.[00;38;05;75mapply[m(undefined, args);
            [00;38;05;171mbreak[m;
        }
    }

    [00;38;05;171mfunction[m [00;38;05;75mrunIfPresent[m(handle) {
        [00;38;05;242m// From the spec: "Wait until any invocations of this algorithm started before this one have completed."[m
        [00;38;05;242m// So if we're currently running a task, we'll need to delay this invocation.[m
        [00;38;05;171mif[m (currentlyRunningATask) {
            [00;38;05;242m// Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a[m
            [00;38;05;242m// "too much recursion" error.[m
            [00;38;05;75msetTimeout[m(runIfPresent, 0, handle);
        } [00;38;05;171melse[m {
            [00;38;05;171mvar[m task = tasksByHandle[handle];
            [00;38;05;171mif[m (task) {
                currentlyRunningATask = [00;38;05;171mtrue[m;
                [00;38;05;171mtry[m {
                    [00;38;05;75mrun[m(task);
                } [00;38;05;171mfinally[m {
                    [00;38;05;75mclearImmediate[m(handle);
                    currentlyRunningATask = [00;38;05;171mfalse[m;
                }
            }
        }
    }

    [00;38;05;171mfunction[m [00;38;05;75minstallNextTickImplementation[m() {
        registerImmediate = [00;38;05;171mfunction[m(handle) {
            process.[00;38;05;75mnextTick[m([00;38;05;171mfunction[m () { [00;38;05;75mrunIfPresent[m(handle); });
        };
    }

    [00;38;05;171mfunction[m [00;38;05;75mcanUsePostMessage[m() {
        [00;38;05;242m// The test against `importScripts` prevents this implementation from being installed inside a web worker,[m
        [00;38;05;242m// where `global.postMessage` means something completely different and can't be used for this purpose.[m
        [00;38;05;171mif[m (global.postMessage && !global.importScripts) {
            [00;38;05;171mvar[m postMessageIsAsynchronous = [00;38;05;171mtrue[m;
            [00;38;05;171mvar[m oldOnMessage = global.onmessage;
            global.onmessage = [00;38;05;171mfunction[m() {
                postMessageIsAsynchronous = [00;38;05;171mfalse[m;
            };
            global.[00;38;05;75mpostMessage[m([00;38;05;196m""[m, [00;38;05;196m"*"[m);
            global.onmessage = oldOnMessage;
            [00;38;05;171mreturn[m postMessageIsAsynchronous;
        }
    }

    [00;38;05;171mfunction[m [00;38;05;75minstallPostMessageImplementation[m() {
        [00;38;05;242m// Installs an event handler on `global` for the `message` event: see[m
        [00;38;05;242m// * https://developer.mozilla.org/en/DOM/window.postMessage[m
        [00;38;05;242m// * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages[m

        [00;38;05;171mvar[m messagePrefix = [00;38;05;196m"setImmediate$"[m + Math.[00;38;05;75mrandom[m() + [00;38;05;196m"$"[m;
        [00;38;05;171mvar[m onGlobalMessage = [00;38;05;171mfunction[m(event) {
            [00;38;05;171mif[m (event.source === global &&
                [00;38;05;171mtypeof[m event.data === [00;38;05;196m"string"[m &&
                event.data.[00;38;05;75mindexOf[m(messagePrefix) === 0) {
                [00;38;05;75mrunIfPresent[m(+event.data.[00;38;05;75mslice[m(messagePrefix.length));
            }
        };

        [00;38;05;171mif[m (global.addEventListener) {
            global.[00;38;05;75maddEventListener[m([00;38;05;196m"message"[m, onGlobalMessage, [00;38;05;171mfalse[m);
        } [00;38;05;171melse[m {
            global.[00;38;05;75mattachEvent[m([00;38;05;196m"onmessage"[m, onGlobalMessage);
        }

        registerImmediate = [00;38;05;171mfunction[m(handle) {
            global.[00;38;05;75mpostMessage[m(messagePrefix + handle, [00;38;05;196m"*"[m);
        };
    }

    [00;38;05;171mfunction[m [00;38;05;75minstallMessageChannelImplementation[m() {
        [00;38;05;171mvar[m channel = [00;38;05;171mnew[m [00;38;05;75mMessageChannel[m();
        channel.port1.onmessage = [00;38;05;171mfunction[m(event) {
            [00;38;05;171mvar[m handle = event.data;
            [00;38;05;75mrunIfPresent[m(handle);
        };

        registerImmediate = [00;38;05;171mfunction[m(handle) {
            channel.port2.[00;38;05;75mpostMessage[m(handle);
        };
    }

    [00;38;05;171mfunction[m [00;38;05;75minstallReadyStateChangeImplementation[m() {
        [00;38;05;171mvar[m html = doc.documentElement;
        registerImmediate = [00;38;05;171mfunction[m(handle) {
            [00;38;05;242m// Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted[m
            [00;38;05;242m// into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.[m
            [00;38;05;171mvar[m script = doc.[00;38;05;75mcreateElement[m([00;38;05;196m"script"[m);
            script.onreadystatechange = [00;38;05;171mfunction[m () {
                [00;38;05;75mrunIfPresent[m(handle);
                script.onreadystatechange = [00;38;05;171mnull[m;
                html.[00;38;05;75mremoveChild[m(script);
                script = [00;38;05;171mnull[m;
            };
            html.[00;38;05;75mappendChild[m(script);
        };
    }

    [00;38;05;171mfunction[m [00;38;05;75minstallSetTimeoutImplementation[m() {
        registerImmediate = [00;38;05;171mfunction[m(handle) {
            [00;38;05;75msetTimeout[m(runIfPresent, 0, handle);
        };
    }

    [00;38;05;242m// If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.[m
    [00;38;05;171mvar[m attachTo = Object.getPrototypeOf && Object.[00;38;05;75mgetPrototypeOf[m(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    [00;38;05;242m// Don't get fooled by e.g. browserify environments.[m
    [00;38;05;171mif[m ({}.toString.[00;38;05;75mcall[m(global.process) === [00;38;05;196m"[object process]"[m) {
        [00;38;05;242m// For Node.js before 0.9[m
        [00;38;05;75minstallNextTickImplementation[m();

    } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;75mcanUsePostMessage[m()) {
        [00;38;05;242m// For non-IE10 modern browsers[m
        [00;38;05;75minstallPostMessageImplementation[m();

    } [00;38;05;171melse[m [00;38;05;171mif[m (global.MessageChannel) {
        [00;38;05;242m// For web workers, where supported[m
        [00;38;05;75minstallMessageChannelImplementation[m();

    } [00;38;05;171melse[m [00;38;05;171mif[m (doc && [00;38;05;196m"onreadystatechange"[m [00;38;05;171min[m doc.[00;38;05;75mcreateElement[m([00;38;05;196m"script"[m)) {
        [00;38;05;242m// For IE 6–8[m
        [00;38;05;75minstallReadyStateChangeImplementation[m();

    } [00;38;05;171melse[m {
        [00;38;05;242m// For older browsers[m
        [00;38;05;75minstallSetTimeoutImplementation[m();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}([00;38;05;171mtypeof[m self === [00;38;05;196m"undefined"[m ? [00;38;05;171mtypeof[m global === [00;38;05;196m"undefined"[m ? [00;38;05;171mthis[m : global : self));

[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(0), [00;38;05;75m__webpack_require__[m(2)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 36 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(Buffer, global, process) {[00;38;05;171mvar[m capability = [00;38;05;75m__webpack_require__[m(16)
[00;38;05;171mvar[m inherits = [00;38;05;75m__webpack_require__[m(3)
[00;38;05;171mvar[m response = [00;38;05;75m__webpack_require__[m(37)
[00;38;05;171mvar[m stream = [00;38;05;75m__webpack_require__[m(14)
[00;38;05;171mvar[m toArrayBuffer = [00;38;05;75m__webpack_require__[m(39)

[00;38;05;171mvar[m IncomingMessage = response.IncomingMessage
[00;38;05;171mvar[m rStates = response.readyStates

[00;38;05;171mfunction[m [00;38;05;75mdecideMode[m (preferBinary, useFetch) {
	[00;38;05;171mif[m (capability.fetch && useFetch) {
		[00;38;05;171mreturn[m [00;38;05;196m'fetch'[m
	} [00;38;05;171melse[m [00;38;05;171mif[m (capability.mozchunkedarraybuffer) {
		[00;38;05;171mreturn[m [00;38;05;196m'moz-chunked-arraybuffer'[m
	} [00;38;05;171melse[m [00;38;05;171mif[m (capability.msstream) {
		[00;38;05;171mreturn[m [00;38;05;196m'ms-stream'[m
	} [00;38;05;171melse[m [00;38;05;171mif[m (capability.arraybuffer && preferBinary) {
		[00;38;05;171mreturn[m [00;38;05;196m'arraybuffer'[m
	} [00;38;05;171melse[m [00;38;05;171mif[m (capability.vbArray && preferBinary) {
		[00;38;05;171mreturn[m [00;38;05;196m'text:vbarray'[m
	} [00;38;05;171melse[m {
		[00;38;05;171mreturn[m [00;38;05;196m'text'[m
	}
}

[00;38;05;171mvar[m ClientRequest = module.exports = [00;38;05;171mfunction[m (opts) {
	[00;38;05;171mvar[m self = [00;38;05;171mthis[m
	stream.Writable.[00;38;05;75mcall[m(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	[00;38;05;171mif[m (opts.auth)
		self.[00;38;05;75msetHeader[m([00;38;05;196m'Authorization'[m, [00;38;05;196m'Basic '[m + [00;38;05;171mnew[m [00;38;05;75mBuffer[m(opts.auth).[00;38;05;75mtoString[m([00;38;05;196m'base64'[m))
	Object.[00;38;05;75mkeys[m(opts.headers).[00;38;05;75mforEach[m([00;38;05;171mfunction[m (name) {
		self.[00;38;05;75msetHeader[m(name, opts.headers[name])
	})

	[00;38;05;171mvar[m preferBinary
	[00;38;05;171mvar[m useFetch = [00;38;05;171mtrue[m
	[00;38;05;171mif[m (opts.mode === [00;38;05;196m'disable-fetch'[m || [00;38;05;196m'timeout'[m [00;38;05;171min[m opts) {
		[00;38;05;242m// If the use of XHR should be preferred and includes preserving the 'content-type' header.[m
		[00;38;05;242m// Force XHR to be used since the Fetch API does not yet support timeouts.[m
		useFetch = [00;38;05;171mfalse[m
		preferBinary = [00;38;05;171mtrue[m
	} [00;38;05;171melse[m [00;38;05;171mif[m (opts.mode === [00;38;05;196m'prefer-streaming'[m) {
		[00;38;05;242m// If streaming is a high priority but binary compatibility and[m
		[00;38;05;242m// the accuracy of the 'content-type' header aren't[m
		preferBinary = [00;38;05;171mfalse[m
	} [00;38;05;171melse[m [00;38;05;171mif[m (opts.mode === [00;38;05;196m'allow-wrong-content-type'[m) {
		[00;38;05;242m// If streaming is more important than preserving the 'content-type' header[m
		preferBinary = !capability.overrideMimeType
	} [00;38;05;171melse[m [00;38;05;171mif[m (!opts.mode || opts.mode === [00;38;05;196m'default'[m || opts.mode === [00;38;05;196m'prefer-fast'[m) {
		[00;38;05;242m// Use binary if text streaming may corrupt data or the content-type header, or for speed[m
		preferBinary = [00;38;05;171mtrue[m
	} [00;38;05;171melse[m {
		[00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'Invalid value for opts.mode'[m)
	}
	self._mode = [00;38;05;75mdecideMode[m(preferBinary, useFetch)

	self.[00;38;05;75mon[m([00;38;05;196m'finish'[m, [00;38;05;171mfunction[m () {
		self.[00;38;05;75m_onFinish[m()
	})
}

[00;38;05;75minherits[m(ClientRequest, stream.Writable)

ClientRequest.[00;38;05;171mprototype[m.setHeader = [00;38;05;171mfunction[m (name, value) {
	[00;38;05;171mvar[m self = [00;38;05;171mthis[m
	[00;38;05;171mvar[m lowerName = name.[00;38;05;75mtoLowerCase[m()
	[00;38;05;242m// This check is not necessary, but it prevents warnings from browsers about setting unsafe[m
	[00;38;05;242m// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but[m
	[00;38;05;242m// http-browserify did it, so I will too.[m
	[00;38;05;171mif[m (unsafeHeaders.[00;38;05;75mindexOf[m(lowerName) !== -1)
		[00;38;05;171mreturn[m

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.[00;38;05;171mprototype[m.getHeader = [00;38;05;171mfunction[m (name) {
	[00;38;05;171mvar[m self = [00;38;05;171mthis[m
	[00;38;05;171mreturn[m self._headers[name.[00;38;05;75mtoLowerCase[m()].value
}

ClientRequest.[00;38;05;171mprototype[m.removeHeader = [00;38;05;171mfunction[m (name) {
	[00;38;05;171mvar[m self = [00;38;05;171mthis[m
	[00;38;05;171mdelete[m self._headers[name.[00;38;05;75mtoLowerCase[m()]
}

ClientRequest.[00;38;05;171mprototype[m._onFinish = [00;38;05;171mfunction[m () {
	[00;38;05;171mvar[m self = [00;38;05;171mthis[m

	[00;38;05;171mif[m (self._destroyed)
		[00;38;05;171mreturn[m
	[00;38;05;171mvar[m opts = self._opts

	[00;38;05;171mvar[m headersObj = self._headers
	[00;38;05;171mvar[m body = [00;38;05;171mnull[m
	[00;38;05;171mif[m (opts.method !== [00;38;05;196m'GET'[m && opts.method !== [00;38;05;196m'HEAD'[m) {
		[00;38;05;171mif[m (capability.blobConstructor) {
			body = [00;38;05;171mnew[m global.[00;38;05;75mBlob[m(self._body.[00;38;05;75mmap[m([00;38;05;171mfunction[m (buffer) {
				[00;38;05;171mreturn[m [00;38;05;75mtoArrayBuffer[m(buffer)
			}), {
				type: (headersObj[[00;38;05;196m'content-type'[m] || {}).value || [00;38;05;196m''[m
			})
		} [00;38;05;171melse[m {
			[00;38;05;242m// get utf8 string[m
			body = Buffer.[00;38;05;75mconcat[m(self._body).[00;38;05;75mtoString[m()
		}
	}

	[00;38;05;242m// create flattened list of headers[m
	[00;38;05;171mvar[m headersList = []
	Object.[00;38;05;75mkeys[m(headersObj).[00;38;05;75mforEach[m([00;38;05;171mfunction[m (keyName) {
		[00;38;05;171mvar[m name = headersObj[keyName].name
		[00;38;05;171mvar[m value = headersObj[keyName].value
		[00;38;05;171mif[m (Array.[00;38;05;75misArray[m(value)) {
			value.[00;38;05;75mforEach[m([00;38;05;171mfunction[m (v) {
				headersList.[00;38;05;75mpush[m([name, v])
			})
		} [00;38;05;171melse[m {
			headersList.[00;38;05;75mpush[m([name, value])
		}
	})

	[00;38;05;171mif[m (self._mode === [00;38;05;196m'fetch'[m) {
		global.[00;38;05;75mfetch[m(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: [00;38;05;196m'cors'[m,
			credentials: opts.withCredentials ? [00;38;05;196m'include'[m : [00;38;05;196m'same-origin'[m
		}).[00;38;05;75mthen[m([00;38;05;171mfunction[m (response) {
			self._fetchResponse = response
			self.[00;38;05;75m_connect[m()
		}, [00;38;05;171mfunction[m (reason) {
			self.[00;38;05;75memit[m([00;38;05;196m'error'[m, reason)
		})
	} [00;38;05;171melse[m {
		[00;38;05;171mvar[m xhr = self._xhr = [00;38;05;171mnew[m global.[00;38;05;75mXMLHttpRequest[m()
		[00;38;05;171mtry[m {
			xhr.[00;38;05;75mopen[m(self._opts.method, self._opts.url, [00;38;05;171mtrue[m)
		} [00;38;05;171mcatch[m (err) {
			process.[00;38;05;75mnextTick[m([00;38;05;171mfunction[m () {
				self.[00;38;05;75memit[m([00;38;05;196m'error'[m, err)
			})
			[00;38;05;171mreturn[m
		}

		[00;38;05;242m// Can't set responseType on really old browsers[m
		[00;38;05;171mif[m ([00;38;05;196m'responseType'[m [00;38;05;171min[m xhr)
			xhr.responseType = self._mode.[00;38;05;75msplit[m([00;38;05;196m':'[m)[0]

		[00;38;05;171mif[m ([00;38;05;196m'withCredentials'[m [00;38;05;171min[m xhr)
			xhr.withCredentials = !!opts.withCredentials

		[00;38;05;171mif[m (self._mode === [00;38;05;196m'text'[m && [00;38;05;196m'overrideMimeType'[m [00;38;05;171min[m xhr)
			xhr.[00;38;05;75moverrideMimeType[m([00;38;05;196m'text/plain; charset=x-user-defined'[m)

		[00;38;05;171mif[m ([00;38;05;196m'timeout'[m [00;38;05;171min[m opts) {
			xhr.timeout = opts.timeout
			xhr.ontimeout = [00;38;05;171mfunction[m () {
				self.[00;38;05;75memit[m([00;38;05;196m'timeout'[m)
			}
		}

		headersList.[00;38;05;75mforEach[m([00;38;05;171mfunction[m (header) {
			xhr.[00;38;05;75msetRequestHeader[m(header[0], header[1])
		})

		self._response = [00;38;05;171mnull[m
		xhr.onreadystatechange = [00;38;05;171mfunction[m () {
			[00;38;05;171mswitch[m (xhr.readyState) {
				[00;38;05;171mcase[m rStates.LOADING:
				[00;38;05;171mcase[m rStates.DONE:
					self.[00;38;05;75m_onXHRProgress[m()
					[00;38;05;171mbreak[m
			}
		}
		[00;38;05;242m// Necessary for streaming in Firefox, since xhr.response is ONLY defined[m
		[00;38;05;242m// in onprogress, not in onreadystatechange with xhr.readyState = 3[m
		[00;38;05;171mif[m (self._mode === [00;38;05;196m'moz-chunked-arraybuffer'[m) {
			xhr.onprogress = [00;38;05;171mfunction[m () {
				self.[00;38;05;75m_onXHRProgress[m()
			}
		}

		xhr.onerror = [00;38;05;171mfunction[m () {
			[00;38;05;171mif[m (self._destroyed)
				[00;38;05;171mreturn[m
			self.[00;38;05;75memit[m([00;38;05;196m'error'[m, [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'XHR error'[m))
		}

		[00;38;05;171mtry[m {
			xhr.[00;38;05;75msend[m(body)
		} [00;38;05;171mcatch[m (err) {
			process.[00;38;05;75mnextTick[m([00;38;05;171mfunction[m () {
				self.[00;38;05;75memit[m([00;38;05;196m'error'[m, err)
			})
			[00;38;05;171mreturn[m
		}
	}
}

[00;38;05;242m/**[m
[00;38;05;242m * Checks if xhr.status is readable and non-zero, indicating no error.[m
[00;38;05;242m * Even though the spec says it should be available in readyState 3,[m
[00;38;05;242m * accessing it throws an exception in IE8[m
[00;38;05;242m */[m
[00;38;05;171mfunction[m [00;38;05;75mstatusValid[m (xhr) {
	[00;38;05;171mtry[m {
		[00;38;05;171mvar[m status = xhr.status
		[00;38;05;171mreturn[m (status !== [00;38;05;171mnull[m && status !== 0)
	} [00;38;05;171mcatch[m (e) {
		[00;38;05;171mreturn[m [00;38;05;171mfalse[m
	}
}

ClientRequest.[00;38;05;171mprototype[m._onXHRProgress = [00;38;05;171mfunction[m () {
	[00;38;05;171mvar[m self = [00;38;05;171mthis[m

	[00;38;05;171mif[m (![00;38;05;75mstatusValid[m(self._xhr) || self._destroyed)
		[00;38;05;171mreturn[m

	[00;38;05;171mif[m (!self._response)
		self.[00;38;05;75m_connect[m()

	self._response.[00;38;05;75m_onXHRProgress[m()
}

ClientRequest.[00;38;05;171mprototype[m._connect = [00;38;05;171mfunction[m () {
	[00;38;05;171mvar[m self = [00;38;05;171mthis[m

	[00;38;05;171mif[m (self._destroyed)
		[00;38;05;171mreturn[m

	self._response = [00;38;05;171mnew[m [00;38;05;75mIncomingMessage[m(self._xhr, self._fetchResponse, self._mode)
	self._response.[00;38;05;75mon[m([00;38;05;196m'error'[m, [00;38;05;171mfunction[m(err) {
		self.[00;38;05;75memit[m([00;38;05;196m'error'[m, err)
	})

	self.[00;38;05;75memit[m([00;38;05;196m'response'[m, self._response)
}

ClientRequest.[00;38;05;171mprototype[m._write = [00;38;05;171mfunction[m (chunk, encoding, cb) {
	[00;38;05;171mvar[m self = [00;38;05;171mthis[m

	self._body.[00;38;05;75mpush[m(chunk)
	[00;38;05;75mcb[m()
}

ClientRequest.[00;38;05;171mprototype[m.abort = ClientRequest.[00;38;05;171mprototype[m.destroy = [00;38;05;171mfunction[m () {
	[00;38;05;171mvar[m self = [00;38;05;171mthis[m
	self._destroyed = [00;38;05;171mtrue[m
	[00;38;05;171mif[m (self._response)
		self._response._destroyed = [00;38;05;171mtrue[m
	[00;38;05;171mif[m (self._xhr)
		self._xhr.[00;38;05;75mabort[m()
	[00;38;05;242m// Currently, there isn't a way to truly abort a fetch.[m
	[00;38;05;242m// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27[m
}

ClientRequest.[00;38;05;171mprototype[m.end = [00;38;05;171mfunction[m (data, encoding, cb) {
	[00;38;05;171mvar[m self = [00;38;05;171mthis[m
	[00;38;05;171mif[m ([00;38;05;171mtypeof[m data === [00;38;05;196m'function'[m) {
		cb = data
		data = undefined
	}

	stream.Writable.[00;38;05;171mprototype[m.end.[00;38;05;75mcall[m(self, data, encoding, cb)
}

ClientRequest.[00;38;05;171mprototype[m.flushHeaders = [00;38;05;171mfunction[m () {}
ClientRequest.[00;38;05;171mprototype[m.setTimeout = [00;38;05;171mfunction[m () {}
ClientRequest.[00;38;05;171mprototype[m.setNoDelay = [00;38;05;171mfunction[m () {}
ClientRequest.[00;38;05;171mprototype[m.setSocketKeepAlive = [00;38;05;171mfunction[m () {}

[00;38;05;242m// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method[m
[00;38;05;171mvar[m unsafeHeaders = [
	[00;38;05;196m'accept-charset'[m,
	[00;38;05;196m'accept-encoding'[m,
	[00;38;05;196m'access-control-request-headers'[m,
	[00;38;05;196m'access-control-request-method'[m,
	[00;38;05;196m'connection'[m,
	[00;38;05;196m'content-length'[m,
	[00;38;05;196m'cookie'[m,
	[00;38;05;196m'cookie2'[m,
	[00;38;05;196m'date'[m,
	[00;38;05;196m'dnt'[m,
	[00;38;05;196m'expect'[m,
	[00;38;05;196m'host'[m,
	[00;38;05;196m'keep-alive'[m,
	[00;38;05;196m'origin'[m,
	[00;38;05;196m'referer'[m,
	[00;38;05;196m'te'[m,
	[00;38;05;196m'trailer'[m,
	[00;38;05;196m'transfer-encoding'[m,
	[00;38;05;196m'upgrade'[m,
	[00;38;05;196m'user-agent'[m,
	[00;38;05;196m'via'[m
]

[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(1).Buffer, [00;38;05;75m__webpack_require__[m(0), [00;38;05;75m__webpack_require__[m(2)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 37 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(process, Buffer, global) {[00;38;05;171mvar[m capability = [00;38;05;75m__webpack_require__[m(16)
[00;38;05;171mvar[m inherits = [00;38;05;75m__webpack_require__[m(3)
[00;38;05;171mvar[m stream = [00;38;05;75m__webpack_require__[m(14)

[00;38;05;171mvar[m rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

[00;38;05;171mvar[m IncomingMessage = exports.IncomingMessage = [00;38;05;171mfunction[m (xhr, response, mode) {
	[00;38;05;171mvar[m self = [00;38;05;171mthis[m
	stream.Readable.[00;38;05;75mcall[m(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	[00;38;05;242m// Fake the 'close' event, but only once 'end' fires[m
	self.[00;38;05;75mon[m([00;38;05;196m'end'[m, [00;38;05;171mfunction[m () {
		[00;38;05;242m// The nextTick is necessary to prevent the 'request' module from causing an infinite loop[m
		process.[00;38;05;75mnextTick[m([00;38;05;171mfunction[m () {
			self.[00;38;05;75memit[m([00;38;05;196m'close'[m)
		})
	})

	[00;38;05;171mif[m (mode === [00;38;05;196m'fetch'[m) {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.[00;38;05;75mforEach[m([00;38;05;171mfunction[m(header, key){
			self.headers[key.[00;38;05;75mtoLowerCase[m()] = header
			self.rawHeaders.[00;38;05;75mpush[m(key, header)
		})


		[00;38;05;242m// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed[m
		[00;38;05;171mvar[m reader = response.body.[00;38;05;75mgetReader[m()
		[00;38;05;171mfunction[m [00;38;05;75mread[m () {
			reader.[00;38;05;75mread[m().[00;38;05;75mthen[m([00;38;05;171mfunction[m (result) {
				[00;38;05;171mif[m (self._destroyed)
					[00;38;05;171mreturn[m
				[00;38;05;171mif[m (result.done) {
					self.[00;38;05;75mpush[m([00;38;05;171mnull[m)
					[00;38;05;171mreturn[m
				}
				self.[00;38;05;75mpush[m([00;38;05;171mnew[m [00;38;05;75mBuffer[m(result.value))
				[00;38;05;75mread[m()
			}).[00;38;05;171mcatch[m([00;38;05;171mfunction[m(err) {
				self.[00;38;05;75memit[m([00;38;05;196m'error'[m, err)
			})
		}
		[00;38;05;75mread[m()

	} [00;38;05;171melse[m {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		[00;38;05;171mvar[m headers = xhr.[00;38;05;75mgetAllResponseHeaders[m().[00;38;05;75msplit[m([00;38;05;208m/\r?\n/[m)
		headers.[00;38;05;75mforEach[m([00;38;05;171mfunction[m (header) {
			[00;38;05;171mvar[m matches = header.[00;38;05;75mmatch[m([00;38;05;208m/^([^:]+):\s*(.*)/[m)
			[00;38;05;171mif[m (matches) {
				[00;38;05;171mvar[m key = matches[1].[00;38;05;75mtoLowerCase[m()
				[00;38;05;171mif[m (key === [00;38;05;196m'set-cookie'[m) {
					[00;38;05;171mif[m (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].[00;38;05;75mpush[m(matches[2])
				} [00;38;05;171melse[m [00;38;05;171mif[m (self.headers[key] !== undefined) {
					self.headers[key] += [00;38;05;196m', '[m + matches[2]
				} [00;38;05;171melse[m {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.[00;38;05;75mpush[m(matches[1], matches[2])
			}
		})

		self._charset = [00;38;05;196m'x-user-defined'[m
		[00;38;05;171mif[m (!capability.overrideMimeType) {
			[00;38;05;171mvar[m mimeType = self.rawHeaders[[00;38;05;196m'mime-type'[m]
			[00;38;05;171mif[m (mimeType) {
				[00;38;05;171mvar[m charsetMatch = mimeType.[00;38;05;75mmatch[m([00;38;05;208m/;\s*charset=([^;])(;|$)/[m)
				[00;38;05;171mif[m (charsetMatch) {
					self._charset = charsetMatch[1].[00;38;05;75mtoLowerCase[m()
				}
			}
			[00;38;05;171mif[m (!self._charset)
				self._charset = [00;38;05;196m'utf-8'[m [00;38;05;242m// best guess[m
		}
	}
}

[00;38;05;75minherits[m(IncomingMessage, stream.Readable)

IncomingMessage.[00;38;05;171mprototype[m._read = [00;38;05;171mfunction[m () {}

IncomingMessage.[00;38;05;171mprototype[m._onXHRProgress = [00;38;05;171mfunction[m () {
	[00;38;05;171mvar[m self = [00;38;05;171mthis[m

	[00;38;05;171mvar[m xhr = self._xhr

	[00;38;05;171mvar[m response = [00;38;05;171mnull[m
	[00;38;05;171mswitch[m (self._mode) {
		[00;38;05;171mcase[m [00;38;05;196m'text:vbarray'[m: [00;38;05;242m// For IE9[m
			[00;38;05;171mif[m (xhr.readyState !== rStates.DONE)
				[00;38;05;171mbreak[m
			[00;38;05;171mtry[m {
				[00;38;05;242m// This fails in IE8[m
				response = [00;38;05;171mnew[m global.[00;38;05;75mVBArray[m(xhr.responseBody).[00;38;05;75mtoArray[m()
			} [00;38;05;171mcatch[m (e) {}
			[00;38;05;171mif[m (response !== [00;38;05;171mnull[m) {
				self.[00;38;05;75mpush[m([00;38;05;171mnew[m [00;38;05;75mBuffer[m(response))
				[00;38;05;171mbreak[m
			}
			[00;38;05;242m// Falls through in IE8	[m
		[00;38;05;171mcase[m [00;38;05;196m'text'[m:
			[00;38;05;171mtry[m { [00;38;05;242m// This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4[m
				response = xhr.responseText
			} [00;38;05;171mcatch[m (e) {
				self._mode = [00;38;05;196m'text:vbarray'[m
				[00;38;05;171mbreak[m
			}
			[00;38;05;171mif[m (response.length > self._pos) {
				[00;38;05;171mvar[m newData = response.[00;38;05;75msubstr[m(self._pos)
				[00;38;05;171mif[m (self._charset === [00;38;05;196m'x-user-defined'[m) {
					[00;38;05;171mvar[m buffer = [00;38;05;171mnew[m [00;38;05;75mBuffer[m(newData.length)
					[00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < newData.length; i++)
						buffer[i] = newData.[00;38;05;75mcharCodeAt[m(i) & 0xff

					self.[00;38;05;75mpush[m(buffer)
				} [00;38;05;171melse[m {
					self.[00;38;05;75mpush[m(newData, self._charset)
				}
				self._pos = response.length
			}
			[00;38;05;171mbreak[m
		[00;38;05;171mcase[m [00;38;05;196m'arraybuffer'[m:
			[00;38;05;171mif[m (xhr.readyState !== rStates.DONE || !xhr.response)
				[00;38;05;171mbreak[m
			response = xhr.response
			self.[00;38;05;75mpush[m([00;38;05;171mnew[m [00;38;05;75mBuffer[m([00;38;05;171mnew[m [00;38;05;75mUint8Array[m(response)))
			[00;38;05;171mbreak[m
		[00;38;05;171mcase[m [00;38;05;196m'moz-chunked-arraybuffer'[m: [00;38;05;242m// take whole[m
			response = xhr.response
			[00;38;05;171mif[m (xhr.readyState !== rStates.LOADING || !response)
				[00;38;05;171mbreak[m
			self.[00;38;05;75mpush[m([00;38;05;171mnew[m [00;38;05;75mBuffer[m([00;38;05;171mnew[m [00;38;05;75mUint8Array[m(response)))
			[00;38;05;171mbreak[m
		[00;38;05;171mcase[m [00;38;05;196m'ms-stream'[m:
			response = xhr.response
			[00;38;05;171mif[m (xhr.readyState !== rStates.LOADING)
				[00;38;05;171mbreak[m
			[00;38;05;171mvar[m reader = [00;38;05;171mnew[m global.[00;38;05;75mMSStreamReader[m()
			reader.onprogress = [00;38;05;171mfunction[m () {
				[00;38;05;171mif[m (reader.result.byteLength > self._pos) {
					self.[00;38;05;75mpush[m([00;38;05;171mnew[m [00;38;05;75mBuffer[m([00;38;05;171mnew[m [00;38;05;75mUint8Array[m(reader.result.[00;38;05;75mslice[m(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = [00;38;05;171mfunction[m () {
				self.[00;38;05;75mpush[m([00;38;05;171mnull[m)
			}
			[00;38;05;242m// reader.onerror = ??? // TODO: this[m
			reader.[00;38;05;75mreadAsArrayBuffer[m(response)
			[00;38;05;171mbreak[m
	}

	[00;38;05;242m// The ms-stream case handles end separately in reader.onload()[m
	[00;38;05;171mif[m (self._xhr.readyState === rStates.DONE && self._mode !== [00;38;05;196m'ms-stream'[m) {
		self.[00;38;05;75mpush[m([00;38;05;171mnull[m)
	}
}

[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(2), [00;38;05;75m__webpack_require__[m(1).Buffer, [00;38;05;75m__webpack_require__[m(0)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 38 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;171mvar[m apply = Function.[00;38;05;171mprototype[m.apply;

[00;38;05;242m// DOM APIs, for completeness[m

exports.setTimeout = [00;38;05;171mfunction[m() {
  [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mTimeout[m(apply.[00;38;05;75mcall[m(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = [00;38;05;171mfunction[m() {
  [00;38;05;171mreturn[m [00;38;05;171mnew[m [00;38;05;75mTimeout[m(apply.[00;38;05;75mcall[m(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = [00;38;05;171mfunction[m(timeout) {
  [00;38;05;171mif[m (timeout) {
    timeout.[00;38;05;75mclose[m();
  }
};

[00;38;05;171mfunction[m [00;38;05;75mTimeout[m(id, clearFn) {
  [00;38;05;171mthis[m._id = id;
  [00;38;05;171mthis[m._clearFn = clearFn;
}
Timeout.[00;38;05;171mprototype[m.unref = Timeout.[00;38;05;171mprototype[m.ref = [00;38;05;171mfunction[m() {};
Timeout.[00;38;05;171mprototype[m.close = [00;38;05;171mfunction[m() {
  [00;38;05;171mthis[m._clearFn.[00;38;05;75mcall[m(window, [00;38;05;171mthis[m._id);
};

[00;38;05;242m// Does not start the time, just sets up the members needed.[m
exports.enroll = [00;38;05;171mfunction[m(item, msecs) {
  [00;38;05;75mclearTimeout[m(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = [00;38;05;171mfunction[m(item) {
  [00;38;05;75mclearTimeout[m(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = [00;38;05;171mfunction[m(item) {
  [00;38;05;75mclearTimeout[m(item._idleTimeoutId);

  [00;38;05;171mvar[m msecs = item._idleTimeout;
  [00;38;05;171mif[m (msecs >= 0) {
    item._idleTimeoutId = [00;38;05;75msetTimeout[m([00;38;05;171mfunction[m [00;38;05;75monTimeout[m() {
      [00;38;05;171mif[m (item._onTimeout)
        item.[00;38;05;75m_onTimeout[m();
    }, msecs);
  }
};

[00;38;05;242m// setimmediate attaches itself to the global object[m
[00;38;05;75m__webpack_require__[m(35);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 39 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;171mvar[m Buffer = [00;38;05;75m__webpack_require__[m(1).Buffer

module.exports = [00;38;05;171mfunction[m (buf) {
	[00;38;05;242m// If the buffer is backed by a Uint8Array, a faster version will work[m
	[00;38;05;171mif[m (buf [00;38;05;171minstanceof[m Uint8Array) {
		[00;38;05;242m// If the buffer isn't a subarray, return the underlying ArrayBuffer[m
		[00;38;05;171mif[m (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			[00;38;05;171mreturn[m buf.buffer
		} [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;171mtypeof[m buf.buffer.slice === [00;38;05;196m'function'[m) {
			[00;38;05;242m// Otherwise we need to get a proper copy[m
			[00;38;05;171mreturn[m buf.buffer.[00;38;05;75mslice[m(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	[00;38;05;171mif[m (Buffer.[00;38;05;75misBuffer[m(buf)) {
		[00;38;05;242m// This is the slow version that will work with any Buffer[m
		[00;38;05;242m// implementation (even in old browsers)[m
		[00;38;05;171mvar[m arrayCopy = [00;38;05;171mnew[m [00;38;05;75mUint8Array[m(buf.length)
		[00;38;05;171mvar[m len = buf.length
		[00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		[00;38;05;171mreturn[m arrayCopy.buffer
	} [00;38;05;171melse[m {
		[00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m([00;38;05;196m'Argument must be a Buffer'[m)
	}
}


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 40 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;
[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(global) {

[00;38;05;242m/**[m
[00;38;05;242m * These properties should not be copied or inherited from. This is only needed[m
[00;38;05;242m * for all non blob URL's as the a blob URL does not include a hash, only the[m
[00;38;05;242m * origin.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@type[m[00;38;05;242m {Object}[m
[00;38;05;242m * [m[00;38;05;70m@private[m
[00;38;05;242m */[m
[00;38;05;171mvar[m ignore = { hash: 1, query: 1 }
  , URL;

[00;38;05;242m/**[m
[00;38;05;242m * The location object differs when your code is loaded through a normal page,[m
[00;38;05;242m * Worker or through a worker using a blob. And with the blobble begins the[m
[00;38;05;242m * trouble as the location object will contain the URL of the blob, not the[m
[00;38;05;242m * location of the page where our code is loaded in. The actual origin is[m
[00;38;05;242m * encoded in the `pathname` so we can thankfully generate a good "default"[m
[00;38;05;242m * location from it so we can generate proper relative URL's again.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {Object} loc Optional default location object.[m
[00;38;05;242m * [m[00;38;05;70m@returns[m[00;38;05;242m {Object} lolcation object.[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m public[m
[00;38;05;242m */[m
module.exports = [00;38;05;171mfunction[m [00;38;05;75mlolcation[m(loc) {
  loc = loc || global.location || {};
  URL = URL || [00;38;05;75m__webpack_require__[m(18);

  [00;38;05;171mvar[m finaldestination = {}
    , type = [00;38;05;171mtypeof[m loc
    , key;

  [00;38;05;171mif[m ([00;38;05;196m'blob:'[m === loc.protocol) {
    finaldestination = [00;38;05;171mnew[m [00;38;05;75mURL[m([00;38;05;75munescape[m(loc.pathname), {});
  } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;196m'string'[m === type) {
    finaldestination = [00;38;05;171mnew[m [00;38;05;75mURL[m(loc, {});
    [00;38;05;171mfor[m (key [00;38;05;171min[m ignore) [00;38;05;171mdelete[m finaldestination[key];
  } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;196m'object'[m === type) [00;38;05;171mfor[m (key [00;38;05;171min[m loc) {
    [00;38;05;171mif[m (key [00;38;05;171min[m ignore) [00;38;05;171mcontinue[m;
    finaldestination[key] = loc[key];
  }

  [00;38;05;171mreturn[m finaldestination;
};

[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(0)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 41 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;196m"use strict"[m;


module.exports = {
  isString: [00;38;05;171mfunction[m(arg) {
    [00;38;05;171mreturn[m [00;38;05;171mtypeof[m(arg) === [00;38;05;196m'string'[m;
  },
  isObject: [00;38;05;171mfunction[m(arg) {
    [00;38;05;171mreturn[m [00;38;05;171mtypeof[m(arg) === [00;38;05;196m'object'[m && arg !== [00;38;05;171mnull[m;
  },
  isNull: [00;38;05;171mfunction[m(arg) {
    [00;38;05;171mreturn[m arg === [00;38;05;171mnull[m;
  },
  isNullOrUndefined: [00;38;05;171mfunction[m(arg) {
    [00;38;05;171mreturn[m arg == [00;38;05;171mnull[m;
  }
};


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 42 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(global) {
[00;38;05;242m/**[m
[00;38;05;242m * Module exports.[m
[00;38;05;242m */[m

module.exports = deprecate;

[00;38;05;242m/**[m
[00;38;05;242m * Mark that a method should not be used.[m
[00;38;05;242m * Returns a modified function which warns once by default.[m
[00;38;05;242m *[m
[00;38;05;242m * If `localStorage.noDeprecation = true` is set, then it is a no-op.[m
[00;38;05;242m *[m
[00;38;05;242m * If `localStorage.throwDeprecation = true` is set, then deprecated functions[m
[00;38;05;242m * will throw an Error when invoked.[m
[00;38;05;242m *[m
[00;38;05;242m * If `localStorage.traceDeprecation = true` is set, then deprecated functions[m
[00;38;05;242m * will invoke `console.trace()` instead of `console.error()`.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {Function} fn - the function to deprecate[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {String} msg - the string to print to the console when `fn` is invoked[m
[00;38;05;242m * [m[00;38;05;70m@returns[m[00;38;05;242m {Function} a new "deprecated" version of `fn`[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m public[m
[00;38;05;242m */[m

[00;38;05;171mfunction[m [00;38;05;75mdeprecate[m (fn, msg) {
  [00;38;05;171mif[m ([00;38;05;75mconfig[m([00;38;05;196m'noDeprecation'[m)) {
    [00;38;05;171mreturn[m fn;
  }

  [00;38;05;171mvar[m warned = [00;38;05;171mfalse[m;
  [00;38;05;171mfunction[m [00;38;05;75mdeprecated[m() {
    [00;38;05;171mif[m (!warned) {
      [00;38;05;171mif[m ([00;38;05;75mconfig[m([00;38;05;196m'throwDeprecation'[m)) {
        [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m(msg);
      } [00;38;05;171melse[m [00;38;05;171mif[m ([00;38;05;75mconfig[m([00;38;05;196m'traceDeprecation'[m)) {
        console.[00;38;05;75mtrace[m(msg);
      } [00;38;05;171melse[m {
        console.[00;38;05;75mwarn[m(msg);
      }
      warned = [00;38;05;171mtrue[m;
    }
    [00;38;05;171mreturn[m fn.[00;38;05;75mapply[m([00;38;05;171mthis[m, arguments);
  }

  [00;38;05;171mreturn[m deprecated;
}

[00;38;05;242m/**[m
[00;38;05;242m * Checks `localStorage` for boolean values for the given `name`.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {String} name[m
[00;38;05;242m * [m[00;38;05;70m@returns[m[00;38;05;242m {Boolean}[m
[00;38;05;242m * [m[00;38;05;70m@api[m[00;38;05;242m private[m
[00;38;05;242m */[m

[00;38;05;171mfunction[m [00;38;05;75mconfig[m (name) {
  [00;38;05;242m// accessing global.localStorage can trigger a DOMException in sandboxed iframes[m
  [00;38;05;171mtry[m {
    [00;38;05;171mif[m (!global.localStorage) [00;38;05;171mreturn[m [00;38;05;171mfalse[m;
  } [00;38;05;171mcatch[m (_) {
    [00;38;05;171mreturn[m [00;38;05;171mfalse[m;
  }
  [00;38;05;171mvar[m val = global.localStorage[name];
  [00;38;05;171mif[m ([00;38;05;171mnull[m == val) [00;38;05;171mreturn[m [00;38;05;171mfalse[m;
  [00;38;05;171mreturn[m [00;38;05;75mString[m(val).[00;38;05;75mtoLowerCase[m() === [00;38;05;196m'true'[m;
}

[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(0)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 43 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports) {

[00;38;05;171mif[m ([00;38;05;171mtypeof[m Object.create === [00;38;05;196m'function'[m) {
  [00;38;05;242m// implementation from standard node.js 'util' module[m
  module.exports = [00;38;05;171mfunction[m [00;38;05;75minherits[m(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.[00;38;05;171mprototype[m = Object.[00;38;05;75mcreate[m(superCtor.[00;38;05;171mprototype[m, {
      constructor: {
        value: ctor,
        enumerable: [00;38;05;171mfalse[m,
        writable: [00;38;05;171mtrue[m,
        configurable: [00;38;05;171mtrue[m
      }
    });
  };
} [00;38;05;171melse[m {
  [00;38;05;242m// old school shim for old browsers[m
  module.exports = [00;38;05;171mfunction[m [00;38;05;75minherits[m(ctor, superCtor) {
    ctor.super_ = superCtor
    [00;38;05;171mvar[m TempCtor = [00;38;05;171mfunction[m () {}
    TempCtor.[00;38;05;171mprototype[m = superCtor.[00;38;05;171mprototype[m
    ctor.[00;38;05;171mprototype[m = [00;38;05;171mnew[m [00;38;05;75mTempCtor[m()
    ctor.[00;38;05;171mprototype[m.constructor = ctor
  }
}


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 44 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports) {

module.exports = [00;38;05;171mfunction[m [00;38;05;75misBuffer[m(arg) {
  [00;38;05;171mreturn[m arg && [00;38;05;171mtypeof[m arg === [00;38;05;196m'object'[m
    && [00;38;05;171mtypeof[m arg.copy === [00;38;05;196m'function'[m
    && [00;38;05;171mtypeof[m arg.fill === [00;38;05;196m'function'[m
    && [00;38;05;171mtypeof[m arg.readUInt8 === [00;38;05;196m'function'[m;
}

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 45 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports, __webpack_require__) {

[00;38;05;242m/* WEBPACK VAR INJECTION */[m([00;38;05;171mfunction[m(global, process) {[00;38;05;242m// Copyright Joyent, Inc. and other Node contributors.[m
[00;38;05;242m//[m
[00;38;05;242m// Permission is hereby granted, free of charge, to any person obtaining a[m
[00;38;05;242m// copy of this software and associated documentation files (the[m
[00;38;05;242m// "Software"), to deal in the Software without restriction, including[m
[00;38;05;242m// without limitation the rights to use, copy, modify, merge, publish,[m
[00;38;05;242m// distribute, sublicense, and/or sell copies of the Software, and to permit[m
[00;38;05;242m// persons to whom the Software is furnished to do so, subject to the[m
[00;38;05;242m// following conditions:[m
[00;38;05;242m//[m
[00;38;05;242m// The above copyright notice and this permission notice shall be included[m
[00;38;05;242m// in all copies or substantial portions of the Software.[m
[00;38;05;242m//[m
[00;38;05;242m// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS[m
[00;38;05;242m// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF[m
[00;38;05;242m// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN[m
[00;38;05;242m// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,[m
[00;38;05;242m// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR[m
[00;38;05;242m// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE[m
[00;38;05;242m// USE OR OTHER DEALINGS IN THE SOFTWARE.[m

[00;38;05;171mvar[m formatRegExp = [00;38;05;208m/%[sdj%]/g[m;
exports.format = [00;38;05;171mfunction[m(f) {
  [00;38;05;171mif[m (![00;38;05;75misString[m(f)) {
    [00;38;05;171mvar[m objects = [];
    [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < arguments.length; i++) {
      objects.[00;38;05;75mpush[m([00;38;05;75minspect[m(arguments[i]));
    }
    [00;38;05;171mreturn[m objects.[00;38;05;75mjoin[m([00;38;05;196m' '[m);
  }

  [00;38;05;171mvar[m i = 1;
  [00;38;05;171mvar[m args = arguments;
  [00;38;05;171mvar[m len = args.length;
  [00;38;05;171mvar[m str = [00;38;05;75mString[m(f).[00;38;05;75mreplace[m(formatRegExp, [00;38;05;171mfunction[m(x) {
    [00;38;05;171mif[m (x === [00;38;05;196m'%%'[m) [00;38;05;171mreturn[m [00;38;05;196m'%'[m;
    [00;38;05;171mif[m (i >= len) [00;38;05;171mreturn[m x;
    [00;38;05;171mswitch[m (x) {
      [00;38;05;171mcase[m [00;38;05;196m'%s'[m: [00;38;05;171mreturn[m [00;38;05;75mString[m(args[i++]);
      [00;38;05;171mcase[m [00;38;05;196m'%d'[m: [00;38;05;171mreturn[m [00;38;05;75mNumber[m(args[i++]);
      [00;38;05;171mcase[m [00;38;05;196m'%j'[m:
        [00;38;05;171mtry[m {
          [00;38;05;171mreturn[m JSON.[00;38;05;75mstringify[m(args[i++]);
        } [00;38;05;171mcatch[m (_) {
          [00;38;05;171mreturn[m [00;38;05;196m'[Circular]'[m;
        }
      [00;38;05;171mdefault[m:
        [00;38;05;171mreturn[m x;
    }
  });
  [00;38;05;171mfor[m ([00;38;05;171mvar[m x = args[i]; i < len; x = args[++i]) {
    [00;38;05;171mif[m ([00;38;05;75misNull[m(x) || ![00;38;05;75misObject[m(x)) {
      str += [00;38;05;196m' '[m + x;
    } [00;38;05;171melse[m {
      str += [00;38;05;196m' '[m + [00;38;05;75minspect[m(x);
    }
  }
  [00;38;05;171mreturn[m str;
};


[00;38;05;242m// Mark that a method should not be used.[m
[00;38;05;242m// Returns a modified function which warns once by default.[m
[00;38;05;242m// If --no-deprecation is set, then it is a no-op.[m
exports.deprecate = [00;38;05;171mfunction[m(fn, msg) {
  [00;38;05;242m// Allow for deprecating things in the process of starting up.[m
  [00;38;05;171mif[m ([00;38;05;75misUndefined[m(global.process)) {
    [00;38;05;171mreturn[m [00;38;05;171mfunction[m() {
      [00;38;05;171mreturn[m exports.[00;38;05;75mdeprecate[m(fn, msg).[00;38;05;75mapply[m([00;38;05;171mthis[m, arguments);
    };
  }

  [00;38;05;171mif[m (process.noDeprecation === [00;38;05;171mtrue[m) {
    [00;38;05;171mreturn[m fn;
  }

  [00;38;05;171mvar[m warned = [00;38;05;171mfalse[m;
  [00;38;05;171mfunction[m [00;38;05;75mdeprecated[m() {
    [00;38;05;171mif[m (!warned) {
      [00;38;05;171mif[m (process.throwDeprecation) {
        [00;38;05;171mthrow[m [00;38;05;171mnew[m [00;38;05;75mError[m(msg);
      } [00;38;05;171melse[m [00;38;05;171mif[m (process.traceDeprecation) {
        console.[00;38;05;75mtrace[m(msg);
      } [00;38;05;171melse[m {
        console.[00;38;05;75merror[m(msg);
      }
      warned = [00;38;05;171mtrue[m;
    }
    [00;38;05;171mreturn[m fn.[00;38;05;75mapply[m([00;38;05;171mthis[m, arguments);
  }

  [00;38;05;171mreturn[m deprecated;
};


[00;38;05;171mvar[m debugs = {};
[00;38;05;171mvar[m debugEnviron;
exports.debuglog = [00;38;05;171mfunction[m(set) {
  [00;38;05;171mif[m ([00;38;05;75misUndefined[m(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || [00;38;05;196m''[m;
  set = set.[00;38;05;75mtoUpperCase[m();
  [00;38;05;171mif[m (!debugs[set]) {
    [00;38;05;171mif[m ([00;38;05;171mnew[m [00;38;05;75mRegExp[m([00;38;05;196m'[m\\[00;38;05;196mb'[m + set + [00;38;05;196m'[m\\[00;38;05;196mb'[m, [00;38;05;196m'i'[m).[00;38;05;75mtest[m(debugEnviron)) {
      [00;38;05;171mvar[m pid = process.pid;
      debugs[set] = [00;38;05;171mfunction[m() {
        [00;38;05;171mvar[m msg = exports.format.[00;38;05;75mapply[m(exports, arguments);
        console.[00;38;05;75merror[m([00;38;05;196m'%s %d: %s'[m, set, pid, msg);
      };
    } [00;38;05;171melse[m {
      debugs[set] = [00;38;05;171mfunction[m() {};
    }
  }
  [00;38;05;171mreturn[m debugs[set];
};


[00;38;05;242m/**[m
[00;38;05;242m * Echos the value of a value. Trys to print the value out[m
[00;38;05;242m * in the best way possible given the different types.[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {Object} obj The object to print out.[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {Object} opts Optional options object that alters the output.[m
[00;38;05;242m */[m
[00;38;05;242m/* legacy: obj, showHidden, depth, colors*/[m
[00;38;05;171mfunction[m [00;38;05;75minspect[m(obj, opts) {
  [00;38;05;242m// default options[m
  [00;38;05;171mvar[m ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  [00;38;05;242m// legacy...[m
  [00;38;05;171mif[m (arguments.length >= 3) ctx.depth = arguments[2];
  [00;38;05;171mif[m (arguments.length >= 4) ctx.colors = arguments[3];
  [00;38;05;171mif[m ([00;38;05;75misBoolean[m(opts)) {
    [00;38;05;242m// legacy...[m
    ctx.showHidden = opts;
  } [00;38;05;171melse[m [00;38;05;171mif[m (opts) {
    [00;38;05;242m// got an "options" object[m
    exports.[00;38;05;75m_extend[m(ctx, opts);
  }
  [00;38;05;242m// set default options[m
  [00;38;05;171mif[m ([00;38;05;75misUndefined[m(ctx.showHidden)) ctx.showHidden = [00;38;05;171mfalse[m;
  [00;38;05;171mif[m ([00;38;05;75misUndefined[m(ctx.depth)) ctx.depth = 2;
  [00;38;05;171mif[m ([00;38;05;75misUndefined[m(ctx.colors)) ctx.colors = [00;38;05;171mfalse[m;
  [00;38;05;171mif[m ([00;38;05;75misUndefined[m(ctx.customInspect)) ctx.customInspect = [00;38;05;171mtrue[m;
  [00;38;05;171mif[m (ctx.colors) ctx.stylize = stylizeWithColor;
  [00;38;05;171mreturn[m [00;38;05;75mformatValue[m(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


[00;38;05;242m// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics[m
inspect.colors = {
  [00;38;05;196m'bold'[m : [1, 22],
  [00;38;05;196m'italic'[m : [3, 23],
  [00;38;05;196m'underline'[m : [4, 24],
  [00;38;05;196m'inverse'[m : [7, 27],
  [00;38;05;196m'white'[m : [37, 39],
  [00;38;05;196m'grey'[m : [90, 39],
  [00;38;05;196m'black'[m : [30, 39],
  [00;38;05;196m'blue'[m : [34, 39],
  [00;38;05;196m'cyan'[m : [36, 39],
  [00;38;05;196m'green'[m : [32, 39],
  [00;38;05;196m'magenta'[m : [35, 39],
  [00;38;05;196m'red'[m : [31, 39],
  [00;38;05;196m'yellow'[m : [33, 39]
};

[00;38;05;242m// Don't use 'blue' not visible on cmd.exe[m
inspect.styles = {
  [00;38;05;196m'special'[m: [00;38;05;196m'cyan'[m,
  [00;38;05;196m'number'[m: [00;38;05;196m'yellow'[m,
  [00;38;05;196m'boolean'[m: [00;38;05;196m'yellow'[m,
  [00;38;05;196m'undefined'[m: [00;38;05;196m'grey'[m,
  [00;38;05;196m'null'[m: [00;38;05;196m'bold'[m,
  [00;38;05;196m'string'[m: [00;38;05;196m'green'[m,
  [00;38;05;196m'date'[m: [00;38;05;196m'magenta'[m,
  [00;38;05;242m// "name": intentionally not styling[m
  [00;38;05;196m'regexp'[m: [00;38;05;196m'red'[m
};


[00;38;05;171mfunction[m [00;38;05;75mstylizeWithColor[m(str, styleType) {
  [00;38;05;171mvar[m style = inspect.styles[styleType];

  [00;38;05;171mif[m (style) {
    [00;38;05;171mreturn[m [00;38;05;196m'[m\u[00;38;05;196m001b['[m + inspect.colors[style][0] + [00;38;05;196m'm'[m + str +
           [00;38;05;196m'[m\u[00;38;05;196m001b['[m + inspect.colors[style][1] + [00;38;05;196m'm'[m;
  } [00;38;05;171melse[m {
    [00;38;05;171mreturn[m str;
  }
}


[00;38;05;171mfunction[m [00;38;05;75mstylizeNoColor[m(str, styleType) {
  [00;38;05;171mreturn[m str;
}


[00;38;05;171mfunction[m [00;38;05;75marrayToHash[m(array) {
  [00;38;05;171mvar[m hash = {};

  array.[00;38;05;75mforEach[m([00;38;05;171mfunction[m(val, idx) {
    hash[val] = [00;38;05;171mtrue[m;
  });

  [00;38;05;171mreturn[m hash;
}


[00;38;05;171mfunction[m [00;38;05;75mformatValue[m(ctx, value, recurseTimes) {
  [00;38;05;242m// Provide a hook for user-specified inspect functions.[m
  [00;38;05;242m// Check that value is an object with an inspect function on it[m
  [00;38;05;171mif[m (ctx.customInspect &&
      value &&
      [00;38;05;75misFunction[m(value.inspect) &&
      [00;38;05;242m// Filter out the util module, it's inspect function is special[m
      value.inspect !== exports.inspect &&
      [00;38;05;242m// Also filter out any prototype objects using the circular check.[m
      !(value.constructor && value.constructor.[00;38;05;171mprototype[m === value)) {
    [00;38;05;171mvar[m ret = value.[00;38;05;75minspect[m(recurseTimes, ctx);
    [00;38;05;171mif[m (![00;38;05;75misString[m(ret)) {
      ret = [00;38;05;75mformatValue[m(ctx, ret, recurseTimes);
    }
    [00;38;05;171mreturn[m ret;
  }

  [00;38;05;242m// Primitive types cannot have properties[m
  [00;38;05;171mvar[m primitive = [00;38;05;75mformatPrimitive[m(ctx, value);
  [00;38;05;171mif[m (primitive) {
    [00;38;05;171mreturn[m primitive;
  }

  [00;38;05;242m// Look up the keys of the object.[m
  [00;38;05;171mvar[m keys = Object.[00;38;05;75mkeys[m(value);
  [00;38;05;171mvar[m visibleKeys = [00;38;05;75marrayToHash[m(keys);

  [00;38;05;171mif[m (ctx.showHidden) {
    keys = Object.[00;38;05;75mgetOwnPropertyNames[m(value);
  }

  [00;38;05;242m// IE doesn't make error fields non-enumerable[m
  [00;38;05;242m// http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx[m
  [00;38;05;171mif[m ([00;38;05;75misError[m(value)
      && (keys.[00;38;05;75mindexOf[m([00;38;05;196m'message'[m) >= 0 || keys.[00;38;05;75mindexOf[m([00;38;05;196m'description'[m) >= 0)) {
    [00;38;05;171mreturn[m [00;38;05;75mformatError[m(value);
  }

  [00;38;05;242m// Some type of object without properties can be shortcutted.[m
  [00;38;05;171mif[m (keys.length === 0) {
    [00;38;05;171mif[m ([00;38;05;75misFunction[m(value)) {
      [00;38;05;171mvar[m name = value.name ? [00;38;05;196m': '[m + value.name : [00;38;05;196m''[m;
      [00;38;05;171mreturn[m ctx.[00;38;05;75mstylize[m([00;38;05;196m'[Function'[m + name + [00;38;05;196m']'[m, [00;38;05;196m'special'[m);
    }
    [00;38;05;171mif[m ([00;38;05;75misRegExp[m(value)) {
      [00;38;05;171mreturn[m ctx.[00;38;05;75mstylize[m(RegExp.[00;38;05;171mprototype[m.toString.[00;38;05;75mcall[m(value), [00;38;05;196m'regexp'[m);
    }
    [00;38;05;171mif[m ([00;38;05;75misDate[m(value)) {
      [00;38;05;171mreturn[m ctx.[00;38;05;75mstylize[m(Date.[00;38;05;171mprototype[m.toString.[00;38;05;75mcall[m(value), [00;38;05;196m'date'[m);
    }
    [00;38;05;171mif[m ([00;38;05;75misError[m(value)) {
      [00;38;05;171mreturn[m [00;38;05;75mformatError[m(value);
    }
  }

  [00;38;05;171mvar[m base = [00;38;05;196m''[m, array = [00;38;05;171mfalse[m, braces = [[00;38;05;196m'{'[m, [00;38;05;196m'}'[m];

  [00;38;05;242m// Make Array say that they are Array[m
  [00;38;05;171mif[m ([00;38;05;75misArray[m(value)) {
    array = [00;38;05;171mtrue[m;
    braces = [[00;38;05;196m'['[m, [00;38;05;196m']'[m];
  }

  [00;38;05;242m// Make functions say that they are functions[m
  [00;38;05;171mif[m ([00;38;05;75misFunction[m(value)) {
    [00;38;05;171mvar[m n = value.name ? [00;38;05;196m': '[m + value.name : [00;38;05;196m''[m;
    base = [00;38;05;196m' [Function'[m + n + [00;38;05;196m']'[m;
  }

  [00;38;05;242m// Make RegExps say that they are RegExps[m
  [00;38;05;171mif[m ([00;38;05;75misRegExp[m(value)) {
    base = [00;38;05;196m' '[m + RegExp.[00;38;05;171mprototype[m.toString.[00;38;05;75mcall[m(value);
  }

  [00;38;05;242m// Make dates with properties first say the date[m
  [00;38;05;171mif[m ([00;38;05;75misDate[m(value)) {
    base = [00;38;05;196m' '[m + Date.[00;38;05;171mprototype[m.toUTCString.[00;38;05;75mcall[m(value);
  }

  [00;38;05;242m// Make error with message first say the error[m
  [00;38;05;171mif[m ([00;38;05;75misError[m(value)) {
    base = [00;38;05;196m' '[m + [00;38;05;75mformatError[m(value);
  }

  [00;38;05;171mif[m (keys.length === 0 && (!array || value.length == 0)) {
    [00;38;05;171mreturn[m braces[0] + base + braces[1];
  }

  [00;38;05;171mif[m (recurseTimes < 0) {
    [00;38;05;171mif[m ([00;38;05;75misRegExp[m(value)) {
      [00;38;05;171mreturn[m ctx.[00;38;05;75mstylize[m(RegExp.[00;38;05;171mprototype[m.toString.[00;38;05;75mcall[m(value), [00;38;05;196m'regexp'[m);
    } [00;38;05;171melse[m {
      [00;38;05;171mreturn[m ctx.[00;38;05;75mstylize[m([00;38;05;196m'[Object]'[m, [00;38;05;196m'special'[m);
    }
  }

  ctx.seen.[00;38;05;75mpush[m(value);

  [00;38;05;171mvar[m output;
  [00;38;05;171mif[m (array) {
    output = [00;38;05;75mformatArray[m(ctx, value, recurseTimes, visibleKeys, keys);
  } [00;38;05;171melse[m {
    output = keys.[00;38;05;75mmap[m([00;38;05;171mfunction[m(key) {
      [00;38;05;171mreturn[m [00;38;05;75mformatProperty[m(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.[00;38;05;75mpop[m();

  [00;38;05;171mreturn[m [00;38;05;75mreduceToSingleString[m(output, base, braces);
}


[00;38;05;171mfunction[m [00;38;05;75mformatPrimitive[m(ctx, value) {
  [00;38;05;171mif[m ([00;38;05;75misUndefined[m(value))
    [00;38;05;171mreturn[m ctx.[00;38;05;75mstylize[m([00;38;05;196m'undefined'[m, [00;38;05;196m'undefined'[m);
  [00;38;05;171mif[m ([00;38;05;75misString[m(value)) {
    [00;38;05;171mvar[m simple = [00;38;05;196m'[m\'[00;38;05;196m'[m + JSON.[00;38;05;75mstringify[m(value).[00;38;05;75mreplace[m([00;38;05;208m/^"|"$/g[m, [00;38;05;196m''[m)
                                             .[00;38;05;75mreplace[m([00;38;05;208m/'/g[m, [00;38;05;196m"[m\\[00;38;05;196m'"[m)
                                             .[00;38;05;75mreplace[m([00;38;05;208m/\\"/g[m, [00;38;05;196m'"'[m) + [00;38;05;196m'[m\'[00;38;05;196m'[m;
    [00;38;05;171mreturn[m ctx.[00;38;05;75mstylize[m(simple, [00;38;05;196m'string'[m);
  }
  [00;38;05;171mif[m ([00;38;05;75misNumber[m(value))
    [00;38;05;171mreturn[m ctx.[00;38;05;75mstylize[m([00;38;05;196m''[m + value, [00;38;05;196m'number'[m);
  [00;38;05;171mif[m ([00;38;05;75misBoolean[m(value))
    [00;38;05;171mreturn[m ctx.[00;38;05;75mstylize[m([00;38;05;196m''[m + value, [00;38;05;196m'boolean'[m);
  [00;38;05;242m// For some reason typeof null is "object", so special case here.[m
  [00;38;05;171mif[m ([00;38;05;75misNull[m(value))
    [00;38;05;171mreturn[m ctx.[00;38;05;75mstylize[m([00;38;05;196m'null'[m, [00;38;05;196m'null'[m);
}


[00;38;05;171mfunction[m [00;38;05;75mformatError[m(value) {
  [00;38;05;171mreturn[m [00;38;05;196m'['[m + Error.[00;38;05;171mprototype[m.toString.[00;38;05;75mcall[m(value) + [00;38;05;196m']'[m;
}


[00;38;05;171mfunction[m [00;38;05;75mformatArray[m(ctx, value, recurseTimes, visibleKeys, keys) {
  [00;38;05;171mvar[m output = [];
  [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0, l = value.length; i < l; ++i) {
    [00;38;05;171mif[m ([00;38;05;75mhasOwnProperty[m(value, [00;38;05;75mString[m(i))) {
      output.[00;38;05;75mpush[m([00;38;05;75mformatProperty[m(ctx, value, recurseTimes, visibleKeys,
          [00;38;05;75mString[m(i), [00;38;05;171mtrue[m));
    } [00;38;05;171melse[m {
      output.[00;38;05;75mpush[m([00;38;05;196m''[m);
    }
  }
  keys.[00;38;05;75mforEach[m([00;38;05;171mfunction[m(key) {
    [00;38;05;171mif[m (!key.[00;38;05;75mmatch[m([00;38;05;208m/^\d+$/[m)) {
      output.[00;38;05;75mpush[m([00;38;05;75mformatProperty[m(ctx, value, recurseTimes, visibleKeys,
          key, [00;38;05;171mtrue[m));
    }
  });
  [00;38;05;171mreturn[m output;
}


[00;38;05;171mfunction[m [00;38;05;75mformatProperty[m(ctx, value, recurseTimes, visibleKeys, key, array) {
  [00;38;05;171mvar[m name, str, desc;
  desc = Object.[00;38;05;75mgetOwnPropertyDescriptor[m(value, key) || { value: value[key] };
  [00;38;05;171mif[m (desc.get) {
    [00;38;05;171mif[m (desc.set) {
      str = ctx.[00;38;05;75mstylize[m([00;38;05;196m'[Getter/Setter]'[m, [00;38;05;196m'special'[m);
    } [00;38;05;171melse[m {
      str = ctx.[00;38;05;75mstylize[m([00;38;05;196m'[Getter]'[m, [00;38;05;196m'special'[m);
    }
  } [00;38;05;171melse[m {
    [00;38;05;171mif[m (desc.set) {
      str = ctx.[00;38;05;75mstylize[m([00;38;05;196m'[Setter]'[m, [00;38;05;196m'special'[m);
    }
  }
  [00;38;05;171mif[m (![00;38;05;75mhasOwnProperty[m(visibleKeys, key)) {
    name = [00;38;05;196m'['[m + key + [00;38;05;196m']'[m;
  }
  [00;38;05;171mif[m (!str) {
    [00;38;05;171mif[m (ctx.seen.[00;38;05;75mindexOf[m(desc.value) < 0) {
      [00;38;05;171mif[m ([00;38;05;75misNull[m(recurseTimes)) {
        str = [00;38;05;75mformatValue[m(ctx, desc.value, [00;38;05;171mnull[m);
      } [00;38;05;171melse[m {
        str = [00;38;05;75mformatValue[m(ctx, desc.value, recurseTimes - 1);
      }
      [00;38;05;171mif[m (str.[00;38;05;75mindexOf[m([00;38;05;196m'[m\n[00;38;05;196m'[m) > -1) {
        [00;38;05;171mif[m (array) {
          str = str.[00;38;05;75msplit[m([00;38;05;196m'[m\n[00;38;05;196m'[m).[00;38;05;75mmap[m([00;38;05;171mfunction[m(line) {
            [00;38;05;171mreturn[m [00;38;05;196m'  '[m + line;
          }).[00;38;05;75mjoin[m([00;38;05;196m'[m\n[00;38;05;196m'[m).[00;38;05;75msubstr[m(2);
        } [00;38;05;171melse[m {
          str = [00;38;05;196m'[m\n[00;38;05;196m'[m + str.[00;38;05;75msplit[m([00;38;05;196m'[m\n[00;38;05;196m'[m).[00;38;05;75mmap[m([00;38;05;171mfunction[m(line) {
            [00;38;05;171mreturn[m [00;38;05;196m'   '[m + line;
          }).[00;38;05;75mjoin[m([00;38;05;196m'[m\n[00;38;05;196m'[m);
        }
      }
    } [00;38;05;171melse[m {
      str = ctx.[00;38;05;75mstylize[m([00;38;05;196m'[Circular]'[m, [00;38;05;196m'special'[m);
    }
  }
  [00;38;05;171mif[m ([00;38;05;75misUndefined[m(name)) {
    [00;38;05;171mif[m (array && key.[00;38;05;75mmatch[m([00;38;05;208m/^\d+$/[m)) {
      [00;38;05;171mreturn[m str;
    }
    name = JSON.[00;38;05;75mstringify[m([00;38;05;196m''[m + key);
    [00;38;05;171mif[m (name.[00;38;05;75mmatch[m([00;38;05;208m/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/[m)) {
      name = name.[00;38;05;75msubstr[m(1, name.length - 2);
      name = ctx.[00;38;05;75mstylize[m(name, [00;38;05;196m'name'[m);
    } [00;38;05;171melse[m {
      name = name.[00;38;05;75mreplace[m([00;38;05;208m/'/g[m, [00;38;05;196m"[m\\[00;38;05;196m'"[m)
                 .[00;38;05;75mreplace[m([00;38;05;208m/\\"/g[m, [00;38;05;196m'"'[m)
                 .[00;38;05;75mreplace[m([00;38;05;208m/(^"|"$)/g[m, [00;38;05;196m"'"[m);
      name = ctx.[00;38;05;75mstylize[m(name, [00;38;05;196m'string'[m);
    }
  }

  [00;38;05;171mreturn[m name + [00;38;05;196m': '[m + str;
}


[00;38;05;171mfunction[m [00;38;05;75mreduceToSingleString[m(output, base, braces) {
  [00;38;05;171mvar[m numLinesEst = 0;
  [00;38;05;171mvar[m length = output.[00;38;05;75mreduce[m([00;38;05;171mfunction[m(prev, cur) {
    numLinesEst++;
    [00;38;05;171mif[m (cur.[00;38;05;75mindexOf[m([00;38;05;196m'[m\n[00;38;05;196m'[m) >= 0) numLinesEst++;
    [00;38;05;171mreturn[m prev + cur.[00;38;05;75mreplace[m([00;38;05;208m/\u001b\[\d\d?m/g[m, [00;38;05;196m''[m).length + 1;
  }, 0);

  [00;38;05;171mif[m (length > 60) {
    [00;38;05;171mreturn[m braces[0] +
           (base === [00;38;05;196m''[m ? [00;38;05;196m''[m : base + [00;38;05;196m'[m\n[00;38;05;196m '[m) +
           [00;38;05;196m' '[m +
           output.[00;38;05;75mjoin[m([00;38;05;196m',[m\n[00;38;05;196m  '[m) +
           [00;38;05;196m' '[m +
           braces[1];
  }

  [00;38;05;171mreturn[m braces[0] + base + [00;38;05;196m' '[m + output.[00;38;05;75mjoin[m([00;38;05;196m', '[m) + [00;38;05;196m' '[m + braces[1];
}


[00;38;05;242m// NOTE: These type checking functions intentionally don't use `instanceof`[m
[00;38;05;242m// because it is fragile and can be easily faked with `Object.create()`.[m
[00;38;05;171mfunction[m [00;38;05;75misArray[m(ar) {
  [00;38;05;171mreturn[m Array.[00;38;05;75misArray[m(ar);
}
exports.isArray = isArray;

[00;38;05;171mfunction[m [00;38;05;75misBoolean[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'boolean'[m;
}
exports.isBoolean = isBoolean;

[00;38;05;171mfunction[m [00;38;05;75misNull[m(arg) {
  [00;38;05;171mreturn[m arg === [00;38;05;171mnull[m;
}
exports.isNull = isNull;

[00;38;05;171mfunction[m [00;38;05;75misNullOrUndefined[m(arg) {
  [00;38;05;171mreturn[m arg == [00;38;05;171mnull[m;
}
exports.isNullOrUndefined = isNullOrUndefined;

[00;38;05;171mfunction[m [00;38;05;75misNumber[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'number'[m;
}
exports.isNumber = isNumber;

[00;38;05;171mfunction[m [00;38;05;75misString[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'string'[m;
}
exports.isString = isString;

[00;38;05;171mfunction[m [00;38;05;75misSymbol[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'symbol'[m;
}
exports.isSymbol = isSymbol;

[00;38;05;171mfunction[m [00;38;05;75misUndefined[m(arg) {
  [00;38;05;171mreturn[m arg === void 0;
}
exports.isUndefined = isUndefined;

[00;38;05;171mfunction[m [00;38;05;75misRegExp[m(re) {
  [00;38;05;171mreturn[m [00;38;05;75misObject[m(re) && [00;38;05;75mobjectToString[m(re) === [00;38;05;196m'[object RegExp]'[m;
}
exports.isRegExp = isRegExp;

[00;38;05;171mfunction[m [00;38;05;75misObject[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'object'[m && arg !== [00;38;05;171mnull[m;
}
exports.isObject = isObject;

[00;38;05;171mfunction[m [00;38;05;75misDate[m(d) {
  [00;38;05;171mreturn[m [00;38;05;75misObject[m(d) && [00;38;05;75mobjectToString[m(d) === [00;38;05;196m'[object Date]'[m;
}
exports.isDate = isDate;

[00;38;05;171mfunction[m [00;38;05;75misError[m(e) {
  [00;38;05;171mreturn[m [00;38;05;75misObject[m(e) &&
      ([00;38;05;75mobjectToString[m(e) === [00;38;05;196m'[object Error]'[m || e [00;38;05;171minstanceof[m Error);
}
exports.isError = isError;

[00;38;05;171mfunction[m [00;38;05;75misFunction[m(arg) {
  [00;38;05;171mreturn[m [00;38;05;171mtypeof[m arg === [00;38;05;196m'function'[m;
}
exports.isFunction = isFunction;

[00;38;05;171mfunction[m [00;38;05;75misPrimitive[m(arg) {
  [00;38;05;171mreturn[m arg === [00;38;05;171mnull[m ||
         [00;38;05;171mtypeof[m arg === [00;38;05;196m'boolean'[m ||
         [00;38;05;171mtypeof[m arg === [00;38;05;196m'number'[m ||
         [00;38;05;171mtypeof[m arg === [00;38;05;196m'string'[m ||
         [00;38;05;171mtypeof[m arg === [00;38;05;196m'symbol'[m ||  [00;38;05;242m// ES6 symbol[m
         [00;38;05;171mtypeof[m arg === [00;38;05;196m'undefined'[m;
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = [00;38;05;75m__webpack_require__[m(44);

[00;38;05;171mfunction[m [00;38;05;75mobjectToString[m(o) {
  [00;38;05;171mreturn[m Object.[00;38;05;171mprototype[m.toString.[00;38;05;75mcall[m(o);
}


[00;38;05;171mfunction[m [00;38;05;75mpad[m(n) {
  [00;38;05;171mreturn[m n < 10 ? [00;38;05;196m'0'[m + n.[00;38;05;75mtoString[m(10) : n.[00;38;05;75mtoString[m(10);
}


[00;38;05;171mvar[m months = [[00;38;05;196m'Jan'[m, [00;38;05;196m'Feb'[m, [00;38;05;196m'Mar'[m, [00;38;05;196m'Apr'[m, [00;38;05;196m'May'[m, [00;38;05;196m'Jun'[m, [00;38;05;196m'Jul'[m, [00;38;05;196m'Aug'[m, [00;38;05;196m'Sep'[m,
              [00;38;05;196m'Oct'[m, [00;38;05;196m'Nov'[m, [00;38;05;196m'Dec'[m];

[00;38;05;242m// 26 Feb 16:19:34[m
[00;38;05;171mfunction[m [00;38;05;75mtimestamp[m() {
  [00;38;05;171mvar[m d = [00;38;05;171mnew[m [00;38;05;75mDate[m();
  [00;38;05;171mvar[m time = [[00;38;05;75mpad[m(d.[00;38;05;75mgetHours[m()),
              [00;38;05;75mpad[m(d.[00;38;05;75mgetMinutes[m()),
              [00;38;05;75mpad[m(d.[00;38;05;75mgetSeconds[m())].[00;38;05;75mjoin[m([00;38;05;196m':'[m);
  [00;38;05;171mreturn[m [d.[00;38;05;75mgetDate[m(), months[d.[00;38;05;75mgetMonth[m()], time].[00;38;05;75mjoin[m([00;38;05;196m' '[m);
}


[00;38;05;242m// log is just a thin wrapper to console.log that prepends a timestamp[m
exports.log = [00;38;05;171mfunction[m() {
  console.[00;38;05;75mlog[m([00;38;05;196m'%s - %s'[m, [00;38;05;75mtimestamp[m(), exports.format.[00;38;05;75mapply[m(exports, arguments));
};


[00;38;05;242m/**[m
[00;38;05;242m * Inherit the prototype methods from one constructor into another.[m
[00;38;05;242m *[m
[00;38;05;242m * The Function.prototype.inherits from lang.js rewritten as a standalone[m
[00;38;05;242m * function (not on Function.prototype). NOTE: If this file is to be loaded[m
[00;38;05;242m * during bootstrapping this function needs to be rewritten using some native[m
[00;38;05;242m * functions as prototype setup using normal JavaScript does not work as[m
[00;38;05;242m * expected during bootstrapping (see mirror.js in r114903).[m
[00;38;05;242m *[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {function} ctor Constructor function which needs to inherit the[m
[00;38;05;242m *     prototype.[m
[00;38;05;242m * [m[00;38;05;70m@param[m[00;38;05;242m {function} superCtor Constructor function to inherit prototype from.[m
[00;38;05;242m */[m
exports.inherits = [00;38;05;75m__webpack_require__[m(43);

exports._extend = [00;38;05;171mfunction[m(origin, add) {
  [00;38;05;242m// Don't do anything if add isn't an object[m
  [00;38;05;171mif[m (!add || ![00;38;05;75misObject[m(add)) [00;38;05;171mreturn[m origin;

  [00;38;05;171mvar[m keys = Object.[00;38;05;75mkeys[m(add);
  [00;38;05;171mvar[m i = keys.length;
  [00;38;05;171mwhile[m (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  [00;38;05;171mreturn[m origin;
};

[00;38;05;171mfunction[m [00;38;05;75mhasOwnProperty[m(obj, prop) {
  [00;38;05;171mreturn[m Object.[00;38;05;171mprototype[m.hasOwnProperty.[00;38;05;75mcall[m(obj, prop);
}

[00;38;05;242m/* WEBPACK VAR INJECTION */[m}.[00;38;05;75mcall[m(exports, [00;38;05;75m__webpack_require__[m(0), [00;38;05;75m__webpack_require__[m(2)))

[00;38;05;242m/***/[m }),
[00;38;05;242m/* 46 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports) {

module.exports = [00;38;05;171mfunction[m(module) {
	[00;38;05;171mif[m(!module.webpackPolyfill) {
		module.deprecate = [00;38;05;171mfunction[m() {};
		module.paths = [];
		[00;38;05;242m// module.parent = undefined by default[m
		[00;38;05;171mif[m(!module.children) module.children = [];
		Object.[00;38;05;75mdefineProperty[m(module, [00;38;05;196m"loaded"[m, {
			enumerable: [00;38;05;171mtrue[m,
			get: [00;38;05;171mfunction[m() {
				[00;38;05;171mreturn[m module.l;
			}
		});
		Object.[00;38;05;75mdefineProperty[m(module, [00;38;05;196m"id"[m, {
			enumerable: [00;38;05;171mtrue[m,
			get: [00;38;05;171mfunction[m() {
				[00;38;05;171mreturn[m module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	[00;38;05;171mreturn[m module;
};


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 47 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports) {

module.exports = extend

[00;38;05;171mvar[m hasOwnProperty = Object.[00;38;05;171mprototype[m.hasOwnProperty;

[00;38;05;171mfunction[m [00;38;05;75mextend[m() {
    [00;38;05;171mvar[m target = {}

    [00;38;05;171mfor[m ([00;38;05;171mvar[m i = 0; i < arguments.length; i++) {
        [00;38;05;171mvar[m source = arguments[i]

        [00;38;05;171mfor[m ([00;38;05;171mvar[m key [00;38;05;171min[m source) {
            [00;38;05;171mif[m (hasOwnProperty.[00;38;05;75mcall[m(source, key)) {
                target[key] = source[key]
            }
        }
    }

    [00;38;05;171mreturn[m target
}


[00;38;05;242m/***/[m }),
[00;38;05;242m/* 48 */[m
[00;38;05;242m/***/[m ([00;38;05;171mfunction[m(module, exports) {

[00;38;05;242m/* (ignored) */[m

[00;38;05;242m/***/[m })
[00;38;05;242m/******/[m ]);